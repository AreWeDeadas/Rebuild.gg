-- ESP Library
local ESPLibrary = {}
local a = {
    rs = game:GetService("RunService"),
    players = game:GetService("Players"),
    coregui = game:GetService("CoreGui"),
    camera = workspace.CurrentCamera,
    localplayer = game:GetService("Players").LocalPlayer,
    httpservice = game:GetService("HttpService"),
    guiservice = game:GetService("GuiService"),
    math = math,
    tick = tick,
    os = os,
    pcall = pcall,
    pairs = pairs,
    ipairs = ipairs,
    Vector2 = Vector2.new,
    Vector3 = Vector3.new,
    UDim2 = UDim2.new,
    Color3 = Color3.fromRGB
}
-- Default config
local Config = {
    Box = {
        Enable = true, --boxes enabled 
        Font = "ProggyClean", --fallback for fonts, dont need UI, just keep it
        Color = a.Color3(255, 255, 255),
        Filled = { 
            Enable = true, --box fill enabled
            Gradient = {
                Enable = true, 
                Color = {Start = a.Color3(255, 255, 255), End = a.Color3(0, 0, 255)},
                Rotation = {Enable = true, Auto = true},
                Transparency = 0.9
            }
        }
    },
    Text = {
        Spacing = 12,
        Name = {
            Enable = true,
            Side = "Top",
            Teamcheck = true,
            Font = "TahomaBold",
            Size = 13,
            Color = a.Color3(255, 255, 255),
            StrokeTransparency = 0.0,
            StrokeColor = a.Color3(0, 0, 0)
        },
        Studs = {
            Enable = true,
            Side = "Bot",
            Font = "TahomaBold",
            Size = 12,
            Color = a.Color3(255, 255, 255),
            StrokeTransparency = 0.0,
            StrokeColor = a.Color3(0, 0, 0)
        },
        Tool = {
            Enable = true,
            Side = "Bot",
            Font = "TahomaBold",
            Size = 13,
            Color = a.Color3(255, 255, 255),
            StrokeTransparency = 0.3,
            StrokeColor = a.Color3(0, 0, 0)
        },
        State = {
            Enable = true,
            Side = "Bot",
            Font = "TahomaBold",
            Size = 12,
            Color = a.Color3(255, 255, 255),
            StrokeTransparency = 0.0,
            StrokeColor = a.Color3(0, 0, 0)
        }
    },
    Bars = {
        Enable = true,
        Health = {
            ShowOutline = false,
            Enable = true,
            Lerp = true,
            Side = "Right",
            Offset = 4,
            Pad = 0,
            Width = 3,
            Color1 = a.Color3(0, 255, 0),
            Color2 = a.Color3(0, 255, 0),
            Color3 = a.Color3(0, 255, 0)
        },
        Armor = {
            ShowOutline = false,
            Enable = true,
            Lerp = true,
            Side = "Bot",
            Offset = 4,
            Pad = 0,
            Width = 3,
            Color1 = a.Color3(0, 89, 255),
            Color2 = a.Color3(60, 97, 219),
            Color3 = a.Color3(81, 84, 255)
        }
    }
}
do
    local b = {}
    function b.NewFont(c, d, e, f)
        if not isfile(f.Id) then
            writefile(f.Id, f.Font)
        end
        if isfile(c .. ".font") then
            delfile(c .. ".font")
        end
        local g = {name = c, faces = {{name = "Regular", weight = d, style = e, assetId = getcustomasset(f.Id)}}}
        writefile(c .. ".font", a.httpservice:JSONEncode(g))
        return getcustomasset(c .. ".font")
    end
end
local function decode_base64(f)
    local h, i
    h, i =
        a.pcall(
        function()
            return syn and syn.crypt and syn.crypt.base64 and syn.crypt.base64.decode(f)
        end
    )
    if h and i then
        return i
    end
    h, i =
        a.pcall(
        function()
            return crypt and crypt.base64decode and crypt.base64decode(f)
        end
    )
    if h and i then
        return i
    end
    h, i =
        a.pcall(
        function()
            return bit and bit.b64_decode and bit.b64_decode(f)
        end
    )
    if h and i then
        return i
    end
    if base64_decode then
        local j, k = a.pcall(base64_decode, f)
        if j and k then
            return k
        end
    end
    h, i =
        a.pcall(
        function()
            return a.httpservice:Base64Decode(f)
        end
    )
    if h and i then
        return i
    end
    return f
end
local o = {
    {
        "ProggyClean.ttf",
        "ProggyClean.json",
        "https://raw.githubusercontent.com/suspendthread/uwu/refs/heads/main/dependencies/assets/fonts/ProggyClean.txt"
    },
    {
        "ProggyTiny.ttf",
        "ProggyTiny.json",
        "https://raw.githubusercontent.com/suspendthread/uwu/refs/heads/main/dependencies/assets/fonts/ProggyTiny.txt"
    },
    {
        "Minecraftia.ttf",
        "Minecraftia.json",
        "https://raw.githubusercontent.com/suspendthread/uwu/refs/heads/main/dependencies/assets/fonts/Minecraftia.txt"
    },
    {
        "SmallestPixel7.ttf",
        "SmallestPixel7.json",
        "https://raw.githubusercontent.com/suspendthread/uwu/refs/heads/main/dependencies/assets/fonts/SmallestPixel7.txt"
    },
    {
        "Verdana.ttf",
        "Verdana.json",
        "https://raw.githubusercontent.com/suspendthread/uwu/refs/heads/main/dependencies/assets/fonts/Verdana.txt"
    },
    {
        "VerdanaBold.ttf",
        "VerdanaBold.json",
        "https://raw.githubusercontent.com/suspendthread/uwu/refs/heads/main/dependencies/assets/fonts/VerdanaBold.txt"
    },
    {
        "Tahoma.ttf",
        "Tahoma.json",
        "https://raw.githubusercontent.com/suspendthread/uwu/refs/heads/main/dependencies/assets/fonts/Tahoma.txt"
    },
    {
        "TahomaBold.ttf",
        "TahomaBold.json",
        "https://raw.githubusercontent.com/suspendthread/uwu/refs/heads/main/dependencies/assets/fonts/TahomaBold.txt"
    },
    {
        "CSGO.ttf",
        "CSGO.json",
        "https://raw.githubusercontent.com/suspendthread/uwu/refs/heads/main/dependencies/assets/fonts/CSGO.txt"
    },
    {
        "WindowsXPTahoma.ttf",
        "WindowsXPTahoma.json",
        "https://raw.githubusercontent.com/suspendthread/uwu/refs/heads/main/dependencies/assets/fonts/WindowsXPTahoma.txt"
    },
    {
        "Stratum2.ttf",
        "Stratum2.json",
        "https://raw.githubusercontent.com/suspendthread/uwu/refs/heads/main/dependencies/assets/fonts/Stratum2.txt"
    },
    {
        "Visitor.ttf",
        "Visitor.json",
        "https://raw.githubusercontent.com/suspendthread/uwu/refs/heads/main/dependencies/assets/fonts/Visitor.txt"
    }
}
for l, m in a.pairs(o) do
    local n, p, q = m[1], m[2], m[3]
    if not isfile(n) then
        local r = game:HttpGet(q)
        writefile(n, decode_base64(r))
    end
    if not isfile(p) then
        local s = n:match("([^%.]+)")
        local t = {name = s, faces = {{name = "Regular", weight = 200, style = "normal", assetId = getcustomasset(n)}}}
        writefile(p, a.httpservice:JSONEncode(t))
    end
end
local u = {}
for l, m in a.pairs(o) do
    local s = m[1]:match("([^%.]+)")
    u[s] = Font.new(getcustomasset(m[2]), Enum.FontWeight.Regular)
end
local v = {
    ProggyClean = {size = 13, stroke_t = 0.0, stroke_c = Color3.fromRGB(0, 0, 0)},
    ProggyTiny = {size = 12, stroke_t = 0.0, stroke_c = Color3.fromRGB(0, 0, 0)},
    Minecraftia = {size = 16, stroke_t = 0.2, stroke_c = Color3.fromRGB(0, 0, 0)},
    SmallestPixel7 = {size = 12, stroke_t = 0.0, stroke_c = Color3.fromRGB(0, 0, 0)},
    Verdana = {size = 13, stroke_t = 0.3, stroke_c = Color3.fromRGB(0, 0, 0)},
    VerdanaBold = {size = 13, stroke_t = 0.4, stroke_c = Color3.fromRGB(0, 0, 0)},
    Tahoma = {size = 13, stroke_t = 0.3, stroke_c = Color3.fromRGB(0, 0, 0)},
    TahomaBold = {size = 13, stroke_t = 0.4, stroke_c = Color3.fromRGB(0, 0, 0)},
    CSGO = {size = 16, stroke_t = 0.2, stroke_c = Color3.fromRGB(0, 0, 0)},
    WindowsXPTahoma = {size = 13, stroke_t = 0.3, stroke_c = Color3.fromRGB(0, 0, 0)},
    Stratum2 = {size = 14, stroke_t = 0.2, stroke_c = Color3.fromRGB(0, 0, 0)},
    Visitor = {size = 14, stroke_t = 0.0, stroke_c = Color3.fromRGB(0, 0, 0)}
}
do
    local w, x =
        a.pcall(
        function()
            return getgenv().Config and getgenv().Config.FontTuning
        end
    )
    if w and type(x) == "table" then
        for y, z in a.pairs(x) do
            local A = v[y] or {}
            v[y] = {
                size = z.size or A.size or 12,
                stroke_t = z.stroke_t ~= nil and z.stroke_t or A.stroke_t or 0.0,
                stroke_c = z.stroke_c or A.stroke_c or a.Color3(0, 0, 0)
            }
        end
    end
end
local function B(C)
    local D = getgenv().Config and getgenv().Config.Text and getgenv().Config.Text[C] or {}
    local E = D.Font or getgenv().Config and getgenv().Config.Box and getgenv().Config.Box.Font or "ProggyClean"
    local A = v[E] or {size = 12, stroke_t = 0.0, stroke_c = a.Color3(0, 0, 0)}
    return {
        fontName = E,
        size = D.Size or A.size,
        stroke_t = D.StrokeTransparency ~= nil and D.StrokeTransparency or A.stroke_t,
        stroke_c = D.StrokeColor or A.stroke_c,
        text_c = D.Color or a.Color3(255, 255, 255)
    }
end
local F = a.guiservice:GetGuiInset()
local G, H, I = {}, {}, {}
local J = {last_update = 0, update_interval = 0.05, data = {}}
if getgenv().ESP_CLEANUP then
    pcall(getgenv().ESP_CLEANUP)
end
local K = a.tick and a.tick() or a.os.clock()
getgenv().ESP_SESSION = K
getgenv().ESP_CLEANUP = function()
    if H and H.main then
        for l, L in pairs(H.main) do
            if L and typeof(L) == "RBXScriptConnection" then
                pcall(
                    function()
                        L:Disconnect()
                    end
                )
            elseif L and L.Disconnect then
                pcall(
                    function()
                        L:Disconnect()
                    end
                )
            end
        end
    end
    if I then
        for M, N in pairs(I) do
            if N.Text then
                for l, O in pairs(N.Text) do
                    if O and O.Parent then
                        pcall(
                            function()
                                local P = O.Parent
                                if P and P.Destroy then
                                    P:Destroy()
                                end
                            end
                        )
                    end
                end
            end
            if N.Bars then
                if N.Bars.Health and N.Bars.Health.Gui then
                    pcall(
                        function()
                            N.Bars.Health.Gui:Destroy()
                        end
                    )
                end
                if N.Bars.Armor and N.Bars.Armor.Gui then
                    pcall(
                        function()
                            N.Bars.Armor.Gui:Destroy()
                        end
                    )
                end
            end
            if N.Box and N.Box.Full then
                local Q = N.Box.Full
                for l, R in ipairs({Q.Square, Q.Inline, Q.Outline}) do
                    if R and R.Remove then
                        pcall(
                            function()
                                R:Remove()
                            end
                        )
                    end
                end
                if Q.Filled then
                    pcall(
                        function()
                            local S = Q.Filled.Parent
                            if S and S.Destroy then
                                S:Destroy()
                            else
                                Q.Filled:Destroy()
                            end
                        end
                    )
                end
            end
            I[M] = nil
        end
    end
    H.main = {}
end
G.funcs = G.funcs or {}
G.funcs.make_text = function(T, C)
    local R = Instance.new("TextLabel")
    R.Parent = T
    R.Size = UDim2.new(0, 4, 0, 4)
    R.BackgroundTransparency = 1
    R.TextScaled = false
    local U = B(C or "Name")
    R.TextColor3 = U.text_c
    R.TextStrokeColor3 = U.stroke_c
    R.TextStrokeTransparency = U.stroke_t
    R.TextSize = U.size
    R.FontFace = u[U.fontName] or u["ProggyClean"]
    return R
end
G.funcs.render = function(V)
    if not V then
        return
    end
    I[V] = I[V] or {}
    I[V].Box = {}
    I[V].Bars = {}
    I[V].Text = {}
    I[V].Box.Full = {
        Square = Drawing.new("Square"),
        Inline = Drawing.new("Square"),
        Outline = Drawing.new("Square"),
        Filled = Instance.new("Frame", Instance.new("ScreenGui", game.CoreGui))
    }
    local W = Instance.new("ScreenGui")
    W.Parent = game.CoreGui
    local X = Instance.new("ScreenGui")
    X.Parent = game.CoreGui
    local Y = Instance.new("ScreenGui")
    Y.Parent = game.CoreGui
    I[V].Text.Studs = G.funcs.make_text(W, "Studs")
    I[V].Text.Tool = G.funcs.make_text(Y, "Tool")
    I[V].Text.Name = G.funcs.make_text(X, "Name")
    local Z = Instance.new("ScreenGui")
    Z.Parent = game.CoreGui
    I[V].Text.State = G.funcs.make_text(Z, "State")
    local _ = Instance.new("ScreenGui")
    _.Name = V.Name .. "_ArmorBar"
    _.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    _.Parent = game.CoreGui
    local a0 = Instance.new("Frame")
    a0.BackgroundColor3 = Color3.new(0, 0, 0)
    a0.BorderSizePixel = 0
    a0.Name = "Outline"
    a0.Parent = _
    local a1 = Instance.new("Frame")
    a1.BackgroundTransparency = 0
    a1.BorderSizePixel = 0
    a1.Name = "Fill"
    a1.Parent = a0
    local a2 = Instance.new("UIGradient", a1)
    a2.Color =
        ColorSequence.new(
        {ColorSequenceKeypoint.new(0, Config.Bars.Armor.Color1), ColorSequenceKeypoint.new(1, Config.Bars.Armor.Color2)}
    )
    a2.Rotation = 90
    I[V].Bars.Armor = {Gui = _, Outline = a0, Frame = a1, Gradient = a2}
    local a3 = Instance.new("ScreenGui")
    a3.Name = V.Name .. "_HealthBar"
    a3.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    a3.Parent = game.CoreGui
    local a4 = Instance.new("Frame")
    a4.BackgroundColor3 = Color3.new(0, 0, 0)
    a4.BorderSizePixel = 0
    a4.Name = "Outline"
    a4.Parent = a3
    local a5 = Instance.new("Frame")
    a5.BackgroundTransparency = 0
    a5.BorderSizePixel = 0
    a5.Name = "Fill"
    a5.Parent = a4
    local a6 = Instance.new("UIGradient", a5)
    a6.Color =
        ColorSequence.new(
        {
            ColorSequenceKeypoint.new(0, Config.Bars.Health.Color1),
            ColorSequenceKeypoint.new(1, Config.Bars.Health.Color2)
        }
    )
    a6.Rotation = 90
    I[V].Bars.Health = {Gui = a3, Outline = a4, Frame = a5, Gradient = a6}
end
G.funcs.clear_esp = function(V)
    if not I[V] then
        return
    end
    if I[V].Box and I[V].Box.Full then
        I[V].Box.Full.Square.Visible = false
        I[V].Box.Full.Outline.Visible = false
        I[V].Box.Full.Inline.Visible = false
        if I[V].Box.Full.Filled then
            I[V].Box.Full.Filled.Visible = false
        end
    end
    if I[V].Text then
        if I[V].Text.Studs then
            I[V].Text.Studs.Visible = false
        end
        if I[V].Text.Tool then
            I[V].Text.Tool.Visible = false
        end
        if I[V].Text.Name then
            I[V].Text.Name.Visible = false
        end
        if I[V].Text.State then
            I[V].Text.State.Visible = false
        end
    end
    if I[V].Bars then
        if I[V].Bars.Health and I[V].Bars.Health.Frame then
            I[V].Bars.Health.Frame.Visible = false
            I[V].Bars.Health.Outline.Visible = false
        end
        if I[V].Bars.Armor and I[V].Bars.Armor.Frame then
            I[V].Bars.Armor.Frame.Visible = false
            I[V].Bars.Armor.Outline.Visible = false
        end
    end
end
G.funcs.update = function(V)
    if not V or not I[V] then
        return
    end
    local a7 = V.Character
    local a8 = a.localplayer.Character
    local a9 = a.camera
    if not a7 or not a8 then
        return
    end
    local aa = a7:FindFirstChild("HumanoidRootPart")
    local ab = a7:FindFirstChildWhichIsA("Humanoid")
    if not aa or not ab then
        G.funcs.clear_esp(V)
        return
    end
    local ac = a9:WorldToViewportPoint(aa.Position)
    local ad =
        (a9:WorldToViewportPoint(aa.Position - Vector3.new(0, 1, 0)).Y -
        a9:WorldToViewportPoint(aa.Position + Vector3.new(0, 3, 0)).Y) /
        2
    local ae = Vector2.new(math.floor(ad * 1.5), math.floor(ad * 3.2))
    local af = Vector2.new(math.floor(ac.X - ad * 1.5 / 2), math.floor(ac.Y - ad * 3 / 2))
    local ag = I[V]
    local a0, ah = a9:WorldToViewportPoint(aa.Position)
    if not ah then
        G.funcs.clear_esp(V)
        return
    end
    if getgenv().Config.Box.Enable then
        local ai = ag.Box.Full
        local aj, ak, al, am = ai.Square, ai.Outline, ai.Inline, ai.Filled
        aj.Visible = Config.Box.Enable
        aj.Position = af
        aj.Size = ae
        aj.Color = getgenv().Config.Box.Color
        aj.Thickness = 2
        aj.Filled = false
        aj.ZIndex = 9e9
        ak.Visible = Config.Box.Enable
        ak.Position = af - Vector2.new(1, 1)
        ak.Size = ae + Vector2.new(2, 2)
        ak.Color = Color3.new(0, 0, 0)
        ak.Thickness = 1
        ak.Filled = false
        al.Visible = true
        al.Position = af + Vector2.new(1, 1)
        al.Size = ae - Vector2.new(2, 2)
        al.Color = Color3.new(0, 0, 0)
        al.Thickness = 1
        al.Filled = false
        if getgenv().Config.Box.Filled.Enable and am then
            am.Position = UDim2.new(0, af.X, 0, af.Y - F.Y)
            am.Size = UDim2.new(0, ae.X, 0, ae.Y)
            am.BackgroundTransparency = getgenv().Config.Box.Filled.Gradient.Transparency or 0.5
            am.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            am.Visible = getgenv().Config.Box.Filled.Enable
            am.ZIndex = -9e9
            if getgenv().Config.Box.Filled.Gradient.Enable then
                local an = am:FindFirstChild("Gradient") or Instance.new("UIGradient")
                an.Name = "Gradient"
                an.Color =
                    ColorSequence.new(
                    {
                        ColorSequenceKeypoint.new(0, getgenv().Config.Box.Filled.Gradient.Color.Start),
                        ColorSequenceKeypoint.new(1, getgenv().Config.Box.Filled.Gradient.Color.End)
                    }
                )
                an.Rotation = a.math.sin(a.tick() * 2) * 180
                if not an.Parent then
                    an.Parent = am
                end
            end
        elseif am then
            am.Visible = false
        end
    end
    local ao = ae.Y
    local ap = 3
    local aq = af.X
    local ar = af.Y - F.Y
    if Config.Bars.Health.Enable and ab then
        local as = math.clamp(ab.Health / 100, 0, 1)
        local at = ag.Bars.Health.LastHealth or as
        local au = at + (as - at) * 0.05
        ag.Bars.Health.LastHealth = au
        local av = Config.Bars.Health
        local aw = av.Side or "Left"
        local ax = av.Offset or 4
        local ay = av.Pad or 0
        local az = av.Width or ap
        local aA = af.X + ae.X
        local ak = ag.Bars.Health.Outline
        local aB = ag.Bars.Health.Frame
        local aC = ag.Bars.Health.Gradient
        if ak and aB then
            local aD = aw == "Left" or aw == "Right"
            if aC then
                aC.Rotation = aD and 90 or 0
            end
            if aD then
                local aE = math.max(0, ao - 2 * ay)
                local aF = 0
                local aG = Config.Bars and Config.Bars.Armor
                if aG and aG.Enable and aG.Side == aw then
                    local aH = aG.Width or ap
                    local aI = 2
                    local aJ = ax <= (aG.Offset or 4)
                    if not aJ then
                        aF = aH + aI
                    end
                end
                local aK = aw == "Left" and aq - ax - az - aF or aA + ax + aF
                ak.Visible = true
                ak.Position = UDim2.new(0, aK - 1, 0, ar - 1 + ay)
                ak.Size = UDim2.new(0, az + 2, 0, math.floor(aE + 2))
                ak.BackgroundTransparency = 0.2
                aB.Visible = true
                aB.Position = UDim2.new(0, 1, 0, (1 - au) * aE + 1)
                aB.Size = UDim2.new(0, az, 0, au * aE)
            else
                local aL = math.max(0, ae.X - 2 * ay)
                local aF = 0
                local aG = Config.Bars and Config.Bars.Armor
                if aG and aG.Enable and aG.Side == aw then
                    local aH = aG.Width or ap
                    local aJ = ax <= (aG.Offset or 4)
                    if not aJ then
                        local aM = Config.Bars and Config.Bars.Spacing or 2
                        local aN = 2
                        aF = aH + aM + aN
                    end
                end
                local aO = aw == "Top" and ar - ax - az - aF or ar + ae.Y + ax + aF
                ak.Visible = true
                ak.Position = UDim2.new(0, af.X + ay - 1, 0, aO - 1)
                ak.Size = UDim2.new(0, math.floor(aL + 2), 0, az + 2)
                ak.BackgroundTransparency = 0.2
                aB.Visible = true
                aB.Position = UDim2.new(0, 1, 0, 1)
                aB.Size = UDim2.new(0, au * aL, 0, az)
            end
        end
    end
    local aP = ag.Text.Name
    local aQ = ag.Text.Tool
    local aR = ag.Text.Studs
    local aS = 20
    local aT = af.X + ae.X / 2
    local aU = af.Y - F.Y
    local av = Config.Bars.Health
    local aG = Config.Bars.Armor
    local aV, aW = 0, 0
    local function aX(aY, aZ)
        return (aY or 4) + (aZ or 3)
    end
    local function a_(b0, b1, b2)
        return (b0 or 3) + (b1 or 4) + (b2 or 3)
    end
    local b3 = getgenv().Config.Bars.Health
    local b4 = getgenv().Config.Bars.Armor
    if b3 and b3.Enable and b3.Side == "Top" and (b4 and b4.Enable and b4.Side == "Top") then
        local b5 = (b3.Offset or 4) <= (b4.Offset or 4)
        if b5 then
            aV = a_(b3.Width, b4.Offset, b4.Width)
        else
            aV = a_(b4.Width, b3.Offset, b3.Width)
        end
        local b6 = Config.Text and (Config.Text.TopGap or Config.Text.BottomGap) or 6
        aV = aV + b6
    else
        if b3 and b3.Enable and b3.Side == "Top" then
            aV = math.max(aV, aX(b3.Offset, b3.Width))
        end
        if b4 and b4.Enable and b4.Side == "Top" then
            aV = math.max(aV, aX(b4.Offset, b4.Width))
        end
    end
    if b3 and b3.Enable and b3.Side == "Bot" and (b4 and b4.Enable and b4.Side == "Bot") then
        local b5 = (b3.Offset or 4) <= (b4.Offset or 4)
        if b5 then
            aW = a_(b3.Width, b4.Offset, b4.Width)
        else
            aW = a_(b4.Width, b3.Offset, b3.Width)
        end
        local b7 = Config.Text and Config.Text.BottomGap or 6
        aW = aW + b7
    else
        if b3 and b3.Enable and b3.Side == "Bot" then
            aW = math.max(aW, aX(b3.Offset, b3.Width))
        end
        if b4 and b4.Enable and b4.Side == "Bot" then
            aW = math.max(aW, aX(b4.Offset, b4.Width))
        end
    end
    local b8 = B("Name")
    local b9 = B("Tool")
    local ba = B("Studs")
    local bb = B("State")
    do
        local S = Config.Text or {}
        local bc = S.Spacing or 10
        local bd = S.FirstTopGap or 14
        local be = S.FirstBotGap or 5
        local bf = ag.Text.State
        local bg = {
            {
                key = "Name",
                label = aP,
                tune = b8,
                enable = S.Name and S.Name.Enable,
                side = S.Name and S.Name.Side or "Top"
            },
            {
                key = "Tool",
                label = aQ,
                tune = b9,
                enable = S.Tool and S.Tool.Enable,
                side = S.Tool and S.Tool.Side or "Bot"
            },
            {
                key = "Studs",
                label = aR,
                tune = ba,
                enable = S.Studs and S.Studs.Enable,
                side = S.Studs and S.Studs.Side or "Bot"
            },
            {
                key = "State",
                label = bf,
                tune = bb,
                enable = S.State and S.State.Enable,
                side = S.State and S.State.Side or "Bot"
            }
        }
        local bh = {Name = 1, Studs = 2, Tool = 3, State = 4}
        local bi = {Name = 1, Tool = 2, Studs = 3, State = 4}
        local bj = aU - aV
        local bk = aU + ae.Y + aW
        local bl = a.tick()
        local bm = tostring(V.UserId)
        local bn = J.data[bm]
        if not bn or bl - J.last_update >= J.update_interval then
            local bo = a7:FindFirstChildOfClass("Tool")
            local bp = (a9.CFrame.Position - aa.Position).Magnitude
            local bq = bp * 0.28
            local br = (ab.MoveDirection and ab.MoveDirection.Magnitude or 0) > 0.1
            local bs = br and "Moving" or "idle"
            J.data[bm] = {tool = bo and bo.Name or "none", studs = string.format("[%.0fm]", bq), state = bs}
            if not bn then
                J.last_update = bl
            end
        end
        bn = J.data[bm] or {tool = "none", studs = "[0m]", state = "idle"}
        local function bt(bu, bv, bw)
            local bx = bu == "Top" and bv - bw or bv + bw
            table.sort(
                bg,
                function(by, n)
                    if by.side ~= bu then
                        return false
                    end
                    if n.side ~= bu then
                        return true
                    end
                    local bz = bu == "Top" and (bh[by.key] or 99) or (bi[by.key] or 99)
                    local bA = bu == "Top" and (bh[n.key] or 99) or (bi[n.key] or 99)
                    return bz < bA
                end
            )
            for a0, bB in ipairs(bg) do
                if bB.side == bu then
                    local bC = bB.label
                    if bB.enable then
                        bC.Visible = true
                        bC.FontFace = u[bB.tune.fontName] or bC.FontFace
                        bC.TextSize = bB.tune.size
                        bC.TextColor3 = bB.tune.text_c
                        bC.TextStrokeColor3 = bB.tune.stroke_c
                        bC.TextStrokeTransparency = bB.tune.stroke_t
                        if bB.key == "Name" then
                            bC.Text = V.Name
                        elseif bB.key == "Tool" then
                            bC.Text = bn.tool
                        elseif bB.key == "Studs" then
                            bC.Text = bn.studs
                        elseif bB.key == "State" then
                            bC.Text = bn.state
                        end
                        local bD = bu == "Top" and math.floor(bx) or math.floor(bx)
                        bC.Position = UDim2.new(0, math.floor(aT - bC.AbsoluteSize.X / 2), 0, bD)
                        bx = bu == "Top" and bx - bc or bx + bc
                    else
                        bC.Visible = false
                    end
                end
            end
        end
        bt("Top", bj, bd)
        bt("Bot", bk, be)
        if not (S.Name and S.Name.Enable) and aP then
            aP.Visible = false
        end
        if not (S.Tool and S.Tool.Enable) and aQ then
            aQ.Visible = false
        end
        if not (S.Studs and S.Studs.Enable) and aR then
            aR.Visible = false
        end
        if not (S.State and S.State.Enable) and bf then
            bf.Visible = false
        end
    end
    if Config.Bars.Armor.Enable and a7 then
        local bE = a7:FindFirstChild("BodyEffects")
        local bF = bE and bE:FindFirstChild("Armor")
        local bG = bF and math.clamp(bF.Value / 200, 0, 1) or 0
        local bH = ag.Bars.Armor.LastArmor or bG
        local bI = bH + (bG - bH) * 0.05
        ag.Bars.Armor.LastArmor = bI
        local b3 = getgenv().Config.Bars.Health
        local b4 = getgenv().Config.Bars.Armor
        local bJ = av.Side or "Left"
        local bK = aG.Side or "Left"
        local bL = aG.Offset or 4
        local bM = aG.Pad or 0
        local bN = aG.Width or ap
        local bO = av.Offset or 4
        local bP = av.Width or ap
        local aA = af.X + ae.X
        local ak = ag.Bars.Armor.Outline
        local aB = ag.Bars.Armor.Frame
        local aC = ag.Bars.Armor.Gradient
        local aI = 2
        if ak and aB then
            local aD = bK == "Left" or bK == "Right"
            if aC then
                aC.Rotation = aD and 90 or 0
            end
            if aD then
                local aE = math.max(0, ao - 2 * bM)
                local aF = 0
                if Config.Bars.Health.Enable and bJ == bK then
                    local aJ = bO <= bL
                    if aJ then
                        aF = bP + aI
                    else
                        aF = 0
                    end
                end
                local aK
                if bK == "Left" then
                    aK = aq - bL - bN - aF
                else
                    aK = aA + bL + aF
                end
                ak.Visible = true
                ak.Position = UDim2.new(0, aK - 1, 0, ar - 1 + bM)
                ak.Size = UDim2.new(0, bN + 2, 0, math.floor(aE + 2))
                ak.BackgroundTransparency = 0.2
                aB.Visible = true
                aB.Position = UDim2.new(0, 1, 0, (1 - bI) * aE + 1)
                aB.Size = UDim2.new(0, bN, 0, bI * aE)
            else
                local aL = math.max(0, ae.X - 2 * bM)
                local aF = 0
                if Config.Bars.Health.Enable and bJ == bK then
                    local aJ = bO <= bL
                    if aJ then
                        local aM = Config.Bars and Config.Bars.Spacing or 2
                        local aN = 2
                        aF = (av.Width or ap) + aM + aN
                    else
                        aF = 0
                    end
                end
                local aO
                if bK == "Top" then
                    aO = ar - bL - bN - aF
                else
                    aO = ar + ae.Y + bL + aF
                end
                ak.Visible = true
                ak.Position = UDim2.new(0, af.X + bM - 1, 0, aO - 1)
                ak.Size = UDim2.new(0, math.floor(aL + 2), 0, bN + 2)
                ak.BackgroundTransparency = 0.2
                aB.Visible = true
                aB.Position = UDim2.new(0, 1, 0, 1)
                aB.Size = UDim2.new(0, bI * aL, 0, bN)
            end
        end
    end
end
for l, V in ipairs(game:GetService("Players"):GetPlayers()) do
    if V ~= game.Players.LocalPlayer then
        G.funcs.render(V)
    end
end
H.main = H.main or {}
do
    local bQ = game:GetService("Players")
    local bR = bQ.LocalPlayer
    H.main.NameplatePerPlayer = H.main.NameplatePerPlayer or {}
    local function bb(bS)
        if not bS then
            return
        end
        if Config and Config.Text and Config.Text.Name and Config.Text.Name.Enable then
            bS.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
        else
            bS.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
            bS.NameOcclusion = Enum.NameOcclusion.NoOcclusion
        end
    end
    local function bT(T, bU)
        if not T or T == bR or not bU then
            return
        end
        local bV = tostring(T.UserId)
        local bW = H.main.NameplatePerPlayer[bV]
        if bW then
            for l, L in pairs(bW) do
                pcall(
                    function()
                        L:Disconnect()
                    end
                )
            end
        end
        bW = {}
        H.main.NameplatePerPlayer[bV] = bW
        local bS = bU:FindFirstChildOfClass("Humanoid")
        if bS then
            bb(bS)
        end
        bW.HumAdded =
            bU.ChildAdded:Connect(
            function(bX)
                if bX:IsA("Humanoid") then
                    bb(bX)
                end
            end
        )
        bW.AppLoaded =
            T.CharacterAppearanceLoaded:Connect(
            function(bY)
                local bZ = (bY or T.Character) and (bY or T.Character):FindFirstChildOfClass("Humanoid")
                bb(bZ)
            end
        )
    end
    local function b_(T)
        if not T or T == bR then
            return
        end
        if T.Character then
            bT(T, T.Character)
        end
        H.main["Nameplate_CharAdded_" .. T.UserId] =
            T.CharacterAdded:Connect(
            function(bU)
                bT(T, bU)
            end
        )
    end
    for l, T in ipairs(bQ:GetPlayers()) do
        b_(T)
    end
    H.main.Nameplate_PlayerAdded =
        bQ.PlayerAdded:Connect(
        function(T)
            b_(T)
        end
    )
end
H.main.PlayerAdded =
    game:GetService("Players").PlayerAdded:Connect(
    function(V)
        if getgenv().ESP_SESSION ~= K then
            return
        end
        if not ESPLibrary.Started then
            return
        end
        if V ~= game.Players.LocalPlayer then
            G.funcs.render(V)
        end
    end
)
H.main.PlayerRemoving =
    game:GetService("Players").PlayerRemoving:Connect(
    function(V)
        if getgenv().ESP_SESSION ~= K then
            return
        end
        if V ~= game.Players.LocalPlayer then
            G.funcs.clear_esp(V)
        end
    end
)
do
    local c0 = 0
    local c1 = 1 / 60
    H.main.RenderStepped =
        game:GetService("RunService").Heartbeat:Connect(
        function()
            if getgenv().ESP_SESSION ~= K then
                return
            end
            if not ESPLibrary.Started then
                return
            end
            local c2 = tick and tick() or os.clock()
            if c2 - c0 < c1 then
                return
            end
            c0 = c2
            for z, l in pairs(I) do
                if z then
                    G.funcs.update(z)
                end
            end
        end
    )
end
-- Library API
local API = {}

-- Enable/Disable functions
function API:BoxEnable()
    Config.Box.Enable = true
end

function API:BoxDisable()
    Config.Box.Enable = false
end

function API:BoxFilledEnable()
    Config.Box.Filled.Enable = true
end

function API:BoxFilledDisable()
    Config.Box.Filled.Enable = false
end

function API:NameEnable()
    Config.Text.Name.Enable = true
end

function API:NameDisable()
    Config.Text.Name.Enable = false
end

function API:StudsEnable()
    Config.Text.Studs.Enable = true
end

function API:StudsDisable()
    Config.Text.Studs.Enable = false
end

function API:ToolEnable()
    Config.Text.Tool.Enable = true
end

function API:ToolDisable()
    Config.Text.Tool.Enable = false
end

function API:StateEnable()
    Config.Text.State.Enable = true
end

function API:StateDisable()
    Config.Text.State.Enable = false
end

function API:HealthBarEnable()
    Config.Bars.Health.Enable = true
end

function API:HealthBarDisable()
    Config.Bars.Health.Enable = false
end

function API:ArmorBarEnable()
    Config.Bars.Armor.Enable = true
end

function API:ArmorBarDisable()
    Config.Bars.Armor.Enable = false
end

-- Config setters
function API:SetBoxColor(color)
    Config.Box.Color = color
end

function API:SetBoxFilledGradient(startColor, endColor)
    Config.Box.Filled.Gradient.Color.Start = startColor
    Config.Box.Filled.Gradient.Color.End = endColor
end

function API:SetBoxFilledTransparency(transparency)
    Config.Box.Filled.Gradient.Transparency = transparency
end

function API:SetNameColor(color)
    Config.Text.Name.Color = color
end

function API:SetNameSize(size)
    Config.Text.Name.Size = size
end

function API:SetNameFont(font)
    Config.Text.Name.Font = font
end

function API:SetStudsColor(color)
    Config.Text.Studs.Color = color
end

function API:SetStudsSize(size)
    Config.Text.Studs.Size = size
end

function API:SetToolColor(color)
    Config.Text.Tool.Color = color
end

function API:SetStateColor(color)
    Config.Text.State.Color = color
end

function API:SetHealthBarColors(color1, color2, color3)
    Config.Bars.Health.Color1 = color1 or Config.Bars.Health.Color1
    Config.Bars.Health.Color2 = color2 or Config.Bars.Health.Color2
    Config.Bars.Health.Color3 = color3 or Config.Bars.Health.Color3
end

function API:SetArmorBarColors(color1, color2, color3)
    Config.Bars.Armor.Color1 = color1 or Config.Bars.Armor.Color1
    Config.Bars.Armor.Color2 = color2 or Config.Bars.Armor.Color2
    Config.Bars.Armor.Color3 = color3 or Config.Bars.Armor.Color3
end

function API:SetHealthBarSide(side)
    if side == "Left" or side == "Right" or side == "Top" or side == "Bot" then
        Config.Bars.Health.Side = side
    end
end

function API:SetArmorBarSide(side)
    if side == "Left" or side == "Right" or side == "Top" or side == "Bot" then
        Config.Bars.Armor.Side = side
    end
end

function API:SetTextSpacing(spacing)
    Config.Text.Spacing = spacing
end

-- Batch config
function API:SetConfig(newConfig)
    for key, value in pairs(newConfig) do
        if Config[key] then
            if type(value) == "table" then
                for subKey, subValue in pairs(value) do
                    if Config[key][subKey] ~= nil then
                        if type(subValue) == "table" then
                            for subSubKey, subSubValue in pairs(subValue) do
                                if Config[key][subKey][subSubKey] ~= nil then
                                    Config[key][subKey][subSubKey] = subSubValue
                                end
                            end
                        else
                            Config[key][subKey] = subValue
                        end
                    end
                end
            else
                Config[key] = value
            end
        end
    end
end

function API:GetConfig()
    return Config
end

-- Control functions
function API:Start()
    if not ESPLibrary.Started then
        ESPLibrary.Started = true
        -- Initialize ESP for all players
        for l, V in ipairs(game:GetService("Players"):GetPlayers()) do
            if V ~= game.Players.LocalPlayer then
                G.funcs.render(V)
            end
        end
    end
end

function API:Stop()
    if ESPLibrary.Started then
        ESPLibrary.Started = false
        if getgenv().ESP_CLEANUP then
            getgenv().ESP_CLEANUP()
        end
    end
end

function API:Destroy()
    API:Stop()
end

-- Export config to getgenv for internal use
getgenv().Config = Config

-- Return API
return API
