loadstring(game:HttpGet("https://pastebin.com/raw/gimbTwW1"))()
local a, b, c, d, e, f, g, h, i =
    loadstring(game:HttpGet("https://raw.githubusercontent.com/AreWeDeadas/Rebuild.gg/refs/heads/main/zzzzzzzzzzv1"))()
local j, k, l, m, n, o, p, q, r = a, b, c, d, e, f, g, h, i
j:set_font("CSGO")
local s =
    j:window(
    {
        name = os.date(
            "Rebuild.gg - skidded by 32vision - %b %d %Y - Private - onyxhub sucks - cursed by 32vision to win - creds to chagpt "
        ),
        size = k(0, 800, 0, 700)
    }
)
local t = s:tab({name = "Rage"})
local u = s:tab({name = "Misc"})
local v = s:tab({name = "Visuals"})
local w = s:tab({name = "Players"})
local x = s:tab({name = "Settings"})
local y = a:watermark({default = os.date("Rebuild.gg - fuckass - %b %d %Y - %H:%M:%S")})
local z = a:radar({size = 200, clamp = true})
local A = a:custom_hud({size = b(0, 280, 0, 32), position = b(0, 250, 0, 300), hud_type = "Rust"})
local B = {
    ps = game:GetService("Players"),
    run = game:GetService("RunService"),
    uis = game:GetService("UserInputService"),
    ts = game:GetService("TweenService"),
    hs = game:GetService("HttpService"),
    rs = game:GetService("ReplicatedStorage"),
    cam = workspace.CurrentCamera,
    camera = workspace.CurrentCamera,
    workspace = workspace,
    math = math,
    cf = CFrame,
    v2 = Vector2,
    v3 = Vector3,
    Vector3 = Vector3,
    RaycastParams = RaycastParams,
    task = task,
    tick = tick
}
g["Debug"] = true
print("[Rebuild] Debug enabled")
local C = {}
do
    local D = w:section({name = "Players"})
    C.relations = C.relations or {friend = {}, enemy = {}}
    local E = C.relations
    C.sel = C.sel
    D:playerlist(
        {callback = function(F)
                local G = F
                if G and not G.UserId then
                    local H = type(G) == "string" and G or G.Name
                    if H and B and B.ps then
                        for I, J in ipairs(B.ps:GetPlayers()) do
                            if J.Name == H or J.DisplayName == H then
                                G = J
                                break
                            end
                        end
                    end
                end
                if G and G.UserId then
                    C.sel = G
                    C.sel_uid = G.UserId
                    a:notification({text = "Selected: " .. (G.Name or "?"), time = 2})
                else
                    C.sel = nil
                    C.sel_uid = nil
                    a:notification({text = "NoSel", time = 2})
                end
            end}
    )
    do
        C.relations = C.relations or {friend = {}, enemy = {}, priority = {}}
        C.relations.priority = C.relations.priority or {}
    end
    D:dropdown(
        {
            name = "Priority",
            items = {"Enemy", "Priority", "Neutral", "Friendly"},
            default = "Neutral",
            flag = "PLAYERLIST_DROPDOWN",
            callback = function(K)
                if j and j.prioritize then
                    pcall(
                        function()
                            j.prioritize(K)
                        end
                    )
                end
                local L = C.sel
                if not L and C.sel_uid and B and B.ps then
                    L = B.ps:GetPlayerByUserId(C.sel_uid)
                    C.sel = L
                end
                if not L then
                    a:notification({text = "NoSel", time = 2})
                    return
                end
                C.relations = C.relations or {friend = {}, enemy = {}, priority = {}}
                C.relations.priority = C.relations.priority or {}
                local M = L.UserId
                if K == "Friendly" then
                    C.relations.enemy[M] = nil
                    C.relations.friend[M] = true
                    C.relations.priority[M] = nil
                elseif K == "Enemy" then
                    C.relations.friend[M] = nil
                    C.relations.enemy[M] = true
                    C.relations.priority[M] = nil
                elseif K == "Neutral" then
                    C.relations.friend[M] = nil
                    C.relations.enemy[M] = nil
                    C.relations.priority[M] = nil
                elseif K == "Priority" then
                    C.relations.friend[M] = nil
                    C.relations.enemy[M] = nil
                    C.relations.priority[M] = true
                end
                a:notification({text = K, time = 2})
            end
        }
    )
    local N = w:section({name = "Actions"})
    do
        local O = N
        local P = 0.2
        C._aura_cd = C._aura_cd or {}
        C._aura_gen = C._aura_gen or 0
        local function Q()
            if C._shoot_event and C._shoot_event.Parent then
                return C._shoot_event
            end
            local R = B.rs:FindFirstChild("ShootEvent")
            if not R then
                for I, S in ipairs(B.rs:GetDescendants()) do
                    if S.Name == "ShootEvent" then
                        R = S
                        break
                    end
                end
            end
            C._shoot_event = R
            return R
        end
        local function T(J)
            if not C:ValidateClient(J) then
                return
            end
            local r = B.ps.LocalPlayer
            local U = r and r.Character
            if not U then
                return
            end
            local V
            for I, W in ipairs(U:GetChildren()) do
                if W:IsA("Tool") then
                    V = W
                    break
                end
            end
            if not V then
                return
            end
            local X = V:FindFirstChild("Ammo")
            if X and X.Value <= 0 then
                return
            end
            local M = J and J.UserId
            local Y = false
            if C.relations and C.relations.friend and M and C.relations.friend[M] then
                Y = true
            end
            if not Y and j and j.get_priority then
                local Z, _ =
                    pcall(
                    function()
                        return j.get_priority(J)
                    end
                )
                if Z and _ == "Friendly" then
                    Y = true
                end
            end
            if Y then
                return
            end
            local a0 = g and g["aura_checks"]
            local a1, a2 = false, false
            if type(a0) == "table" then
                for I, a3 in ipairs(a0) do
                    if a3 == "KO" then
                        a1 = true
                    end
                    if a3 == "FF" then
                        a2 = true
                    end
                end
            end
            local a4 = J.Character
            if a2 and a4 and a4:FindFirstChildOfClass("ForceField") then
                return
            end
            if a1 and a4 then
                local a5 = a4:FindFirstChild("BodyEffects")
                local a6 = a5 and a5:FindFirstChild("K.O")
                if a6 and a6.Value then
                    return
                end
            end
            local a7 = J.Character and J.Character:FindFirstChild("Head")
            if not a7 then
                return
            end
            local a8 = V:FindFirstChild("Handle")
            if not a8 then
                return
            end
            local a9 = a7.Position
            local aa = {
                "ShootGun",
                a8,
                a9,
                {a9, a9, a9, a9, a9},
                {a7, a7, a7, a7, a7},
                {
                    Vector3.new(0, 1, 0),
                    Vector3.new(0, 1, 0),
                    Vector3.new(0, 1, 0),
                    Vector3.new(0, 1, 0),
                    Vector3.new(0, 1, 0)
                },
                {},
                os.clock(),
                math.huge,
                {a9, a9, a9, a9, a9},
                5,
                0.2,
                a9
            }
            local R = Q()
            if R and R.FireServer then
                pcall(
                    function()
                        R:FireServer(unpack(aa))
                    end
                )
            end
        end
        
        -- (apply_fov moved into World block after apply_time)

        
        local ab =
            O:toggle(
            {
                name = "Aura",
                flag = "target_aura_enabled",
                callback = function(ac)
                    if ac then
                        if C._aura_conn then
                            return
                        end
                        C._aura_conn =
                            B.run.Heartbeat:Connect(
                            function()
                                if not (g and g["target_aura_enabled"]) then
                                    return
                                end
                                local r = B.ps.LocalPlayer
                                local U = r and r.Character
                                local ad = U and (U:FindFirstChild("HumanoidRootPart") or U:FindFirstChild("Head"))
                                if not ad then
                                    return
                                end
                                local ae = {}
                                local af = g and g["aura_mode"] or "FromList"
                                for I, J in ipairs(B.ps:GetPlayers()) do
                                    if J ~= r then
                                        local ag = false
                                        if af == "All" then
                                            ag = true
                                        else
                                            local ah = false
                                            if C.relations and C.relations.priority and C.relations.priority[J.UserId] then
                                                ah = true
                                            end
                                            if not ah and j and j.get_priority then
                                                local Z, _ =
                                                    pcall(
                                                    function()
                                                        return j.get_priority(J)
                                                    end
                                                )
                                                if Z and _ == "Priority" then
                                                    ah = true
                                                end
                                            end
                                            ag = ah
                                        end
                                        do
                                            local M = J and J.UserId
                                            local Y = false
                                            if C.relations and C.relations.friend and M and C.relations.friend[M] then
                                                Y = true
                                            end
                                            if not Y and j and j.get_priority then
                                                local Z, _ =
                                                    pcall(
                                                    function()
                                                        return j.get_priority(J)
                                                    end
                                                )
                                                if Z and _ == "Friendly" then
                                                    Y = true
                                                end
                                            end
                                            if Y then
                                                ag = false
                                            end
                                        end
                                        if ag then
                                            local a4 = J.Character
                                            local ai =
                                                a4 and
                                                (a4:FindFirstChild("HumanoidRootPart") or a4:FindFirstChild("Head"))
                                            local aj = ai and (ad.Position - ai.Position).Magnitude or math.huge
                                            table.insert(ae, {plr = J, dist = aj})
                                        end
                                    end
                                end
                                table.sort(
                                    ae,
                                    function(a, b)
                                        return a.dist < b.dist
                                    end
                                )
                                if #ae == 0 then
                                    return
                                end
                                if C._fling_wave_running then
                                    return
                                end
                                if C._aura_wave_running then
                                    return
                                end
                                C._aura_wave_running = true
                                local ak = B and B.task or task
                                local al = B and B.math or math
                                local am = tonumber(g and g["aura_cd"]) or 0.03
                                local an = al.max(1, al.floor(tonumber(g and g["aura_batch"]) or 3))
                                ak.spawn(
                                    function()
                                        local ao = C._aura_gen
                                        local w = #ae
                                        local i = 1
                                        while i <= w do
                                            if ao ~= C._aura_gen or not (g and g["target_aura_enabled"]) then
                                                break
                                            end
                                            for t = i, al.min(i + an - 1, w) do
                                                if ao ~= C._aura_gen or not (g and g["target_aura_enabled"]) then
                                                    break
                                                end
                                                local ap = ae[t]
                                                if ap and ap.plr then
                                                    ak.spawn(T, ap.plr)
                                                end
                                            end
                                            i = i + an
                                            if i <= w and am > 0 then
                                                ak.wait(am)
                                            end
                                        end
                                        C._aura_wave_running = false
                                    end
                                )
                            end
                        )
                    else
                        if C._aura_conn then
                            pcall(
                                function()
                                    C._aura_conn:Disconnect()
                                end
                            )
                            C._aura_conn = nil
                        end
                        C._aura_gen = (C._aura_gen or 0) + 1
                        C._aura_wave_running = false
                    end
                end
            }
        )
        local aq =
            N:toggle(
            {
                name = "ViewPriority",
                flag = "fling_view_priority",
                callback = function(ac)
                    if ac then
                        if C._viewprio_conn then
                            return
                        end
                        C._view_idx = 1
                        C._view_next = B.tick() + 1.5
                        C._orig_cam_subj = B.cam and B.cam.CameraSubject or C._orig_cam_subj
                        C._viewprio_conn =
                            B.run.Heartbeat:Connect(
                            function()
                                local ar = B.cam
                                if not ar then
                                    return
                                end
                                local r = B.ps.LocalPlayer
                                local as = r and r.Character and r.Character:FindFirstChildOfClass("Humanoid")
                                local ae = {}
                                for I, J in ipairs(B.ps:GetPlayers()) do
                                    if J ~= r then
                                        local M = J.UserId
                                        local Y = false
                                        if C.relations and C.relations.friend and M and C.relations.friend[M] then
                                            Y = true
                                        end
                                        if not Y and j and j.get_priority then
                                            local Z, _ =
                                                pcall(
                                                function()
                                                    return j.get_priority(J)
                                                end
                                            )
                                            if Z and _ == "Friendly" then
                                                Y = true
                                            end
                                        end
                                        if not Y then
                                            local ah = false
                                            if C.relations and C.relations.priority and M and C.relations.priority[M] then
                                                ah = true
                                            end
                                            if not ah and j and j.get_priority then
                                                local Z, _ =
                                                    pcall(
                                                    function()
                                                        return j.get_priority(J)
                                                    end
                                                )
                                                if Z and _ == "Priority" then
                                                    ah = true
                                                end
                                            end
                                            if ah and C:ValidateClient(J) then
                                                local at = J.Character and J.Character:FindFirstChildOfClass("Humanoid")
                                                if at then
                                                    table.insert(ae, at)
                                                end
                                            end
                                        end
                                    end
                                end
                                if #ae == 0 then
                                    if as then
                                        ar.CameraSubject = as
                                    end
                                    return
                                end
                                local au = B.tick()
                                if au >= (C._view_next or 0) then
                                    C._view_idx = (C._view_idx or 1) % #ae + 1
                                    C._view_next = au + 1.5
                                end
                                local av = math.clamp(C._view_idx or 1, 1, #ae)
                                local aw = ae[av]
                                if aw then
                                    ar.CameraSubject = aw
                                end
                            end
                        )
                    else
                        if C._viewprio_conn then
                            pcall(
                                function()
                                    C._viewprio_conn:Disconnect()
                                end
                            )
                        end
                        C._viewprio_conn = nil
                        local r = B.ps.LocalPlayer
                        local as = r and r.Character and r.Character:FindFirstChildOfClass("Humanoid")
                        if as then
                            B.cam.CameraSubject = as
                        elseif C._orig_cam_subj then
                            B.cam.CameraSubject = C._orig_cam_subj
                        end
                    end
                end
            }
        )
        local ax = O:dependency_box()
        ax:setup_dependencies({{ab, true}})
        ax:dropdown(
            {
                name = "Mode",
                flag = "aura_mode",
                items = {"All", "FromList"},
                default = "FromList",
                callback = function(ay)
                end
            }
        )
        ax:dropdown(
            {
                name = "Checks",
                flag = "aura_checks",
                items = {"KO", "FF"},
                default = {"KO", "FF"},
                multi = true,
                callback = function()
                end
            }
        )
        function C:ValidateClient(az)
            if not az then
                return false
            end
            local a3 = az.Character
            if not a3 then
                return false
            end
            local aA = a3:FindFirstChildOfClass("Humanoid")
            if not aA or aA.Health <= 0 then
                return false
            end
            return aA.RootPart ~= nil
        end
        do
            local aB = {enabled = false, hb_conn = nil, next_tick = 0}
            local function aC(aD)
                local aE = B and B.math and B.math.random or math.random
                local function A()
                    return (aE() * 2 - 1) * aD
                end
                return B.v3.new(A(), A(), A())
            end
            local function aF()
                if aB.hb_conn then
                    return
                end
                aB.hb_conn =
                    B.run.Heartbeat:Connect(
                    function()
                        if not aB.enabled then
                            return
                        end
                        local aG = shared and shared.Rebuild_FlingActive or false
                        local aH = C and C._fling_wave_running == true or false
                        if aG or aH then
                            return
                        end
                        local r = B.ps.LocalPlayer
                        local aI = r and r.Character
                        local at = aI and aI:FindFirstChildOfClass("Humanoid")
                        local aJ = at and at.RootPart
                        if not aJ then
                            return
                        end
                        local au = B and B.tick and B.tick() or tick()
                        if au < (aB.next_tick or 0) then
                            return
                        end
                        aB.next_tick = au + 0.15
                        local aD = 1500
                        local aK = aC(aD)
                        local aL = (B and B.cf or CFrame).new(aK)
                        pcall(
                            function()
                                aJ.CFrame = aL
                                aI:SetPrimaryPartCFrame(aL)
                            end
                        )
                    end
                )
            end
            local function aM()
                if aB.hb_conn then
                    pcall(
                        function()
                            aB.hb_conn:Disconnect()
                        end
                    )
                end
                aB.hb_conn = nil
            end
            N:toggle(
                {name = "Safety", flag = "actions_safety_enabled", callback = function(ac)
                        aB.enabled = ac
                        if ac then
                            aF()
                        else
                            aM()
                        end
                    end}
            )
            C._safety = aB
        end
        do
            local aN = N
            local function aO(aP)
                local r = B.ps.LocalPlayer
                local aQ = r and r.Character
                local aR = aQ and aQ:FindFirstChildOfClass("Humanoid")
                local aS = aR and aR.RootPart
                local aT = aP and aP.Character
                if not (aQ and aR and aS and aT) then
                    return
                end
                local aU = aT:FindFirstChildOfClass("Humanoid")
                local aV = aU and aU.RootPart or nil
                local aW = aT:FindFirstChild("Head")
                local aX = aT:FindFirstChildOfClass("Accessory")
                local aY = aX and aX:FindFirstChild("Handle") or nil
                if aR then
                    if aR.Sit then
                        aR.Sit = false
                    end
                    pcall(
                        function()
                            if Enum and Enum.HumanoidStateType then
                                aR:ChangeState(Enum.HumanoidStateType.Jumping)
                            end
                        end
                    )
                    pcall(
                        function()
                            aR.PlatformStand = false
                        end
                    )
                end
                aS.Anchored = false
                pcall(
                    function()
                        for I, ai in ipairs(aQ:GetChildren()) do
                            if ai:IsA("BasePart") then
                                ai.CanCollide = true
                                ai.Massless = false
                            end
                        end
                    end
                )
                shared.Rebuild_FlingActive = true
                if aS.Velocity.Magnitude < 50 then
                    C._fling_oldpos = aS.CFrame
                end
                local function aZ(a_, b0, b1)
                    aS.CFrame = B.cf.new(a_.Position) * b0 * b1
                    aQ:SetPrimaryPartCFrame(B.cf.new(a_.Position) * b0 * b1)
                    aS.Velocity = B.v3.new(9e7, 9e7 * 10, 9e7)
                    aS.RotVelocity = B.v3.new(9e8, 9e8, 9e8)
                    aS.AssemblyLinearVelocity = B.v3.new(9e7, 9e7 * 10, 9e7)
                    aS.AssemblyAngularVelocity = B.v3.new(9e8, 9e8, 9e8)
                end
                local function b2(a_)
                    local b3 = 1.5
                    local b4 = B.tick()
                    local b5 = 0
                    repeat
                        if aS and aU then
                            if a_.Velocity.Magnitude < 50 then
                                b5 = b5 + 100
                                aZ(
                                    a_,
                                    B.cf.new(0, 1.5, 0) + aU.MoveDirection * a_.Velocity.Magnitude / 1.25,
                                    B.cf.Angles(math.rad(b5), 0, 0)
                                )
                                B.task.wait()
                                aZ(
                                    a_,
                                    B.cf.new(0, -1.5, 0) + aU.MoveDirection * a_.Velocity.Magnitude / 1.25,
                                    B.cf.Angles(math.rad(b5), 0, 0)
                                )
                                B.task.wait()
                                aZ(a_, B.cf.new(0, 1.5, 0) + aU.MoveDirection, B.cf.Angles(math.rad(b5), 0, 0))
                                B.task.wait()
                                aZ(a_, B.cf.new(0, -1.5, 0) + aU.MoveDirection, B.cf.Angles(math.rad(b5), 0, 0))
                                B.task.wait()
                            else
                                aZ(a_, B.cf.new(0, 1.5, aU.WalkSpeed), B.cf.Angles(math.rad(90), 0, 0))
                                B.task.wait()
                                aZ(a_, B.cf.new(0, -1.5, -aU.WalkSpeed), B.cf.Angles(0, 0, 0))
                                B.task.wait()
                                aZ(a_, B.cf.new(0, 1.5, aU.WalkSpeed), B.cf.Angles(math.rad(90), 0, 0))
                                B.task.wait()
                            end
                        end
                    until B.tick() - b4 > b3
                end
                local b6 = Instance.new("BodyVelocity")
                b6.Parent = aS
                b6.Velocity = B.v3.new(0, 0, 0)
                b6.MaxForce = B.v3.new(9e9, 9e9, 9e9)
                if aV then
                    b2(aV)
                elseif aW then
                    b2(aW)
                elseif aY then
                    b2(aY)
                end
                b6:Destroy()
                if C._fling_oldpos then
                    local aL = C._fling_oldpos * B.cf.new(0, 0.5, 0)
                    for I = 1, 10 do
                        aS.CFrame = aL
                        aQ:SetPrimaryPartCFrame(aL)
                        if aR and Enum and Enum.HumanoidStateType then
                            aR:ChangeState(Enum.HumanoidStateType.GettingUp)
                        end
                        for I, ai in ipairs(aQ:GetChildren()) do
                            if ai:IsA("BasePart") then
                                ai.Velocity, ai.RotVelocity = B.v3.new(), B.v3.new()
                            end
                        end
                        B.task.wait()
                    end
                end
                aS.AssemblyLinearVelocity = B.v3.new()
                aS.AssemblyAngularVelocity = B.v3.new()
                shared.Rebuild_FlingActive = false
            end
            C._fling_gen = C._fling_gen or 0
            C._fling_wave_running = false
            local b7 =
                aN:toggle(
                {
                    name = "Fling",
                    flag = "fling_priority_enabled",
                    callback = function(ac)
                        if ac then
                            if C._fling_conn then
                                return
                            end
                            shared.Rebuild_FlingActive = true
                            if C._voiding and C._voiding.enabled and C._void_stop then
                                C._void_paused_by_fling = true
                                pcall(C._void_stop)
                            end
                            C._fling_conn =
                                B.run.Heartbeat:Connect(
                                function()
                                    if C._fling_wave_running or C._aura_wave_running then
                                        return
                                    end
                                    local r = B.ps.LocalPlayer
                                    local ae = {}
                                    for I, J in ipairs(B.ps:GetPlayers()) do
                                        if J ~= r then
                                            local M = J.UserId
                                            local Y = false
                                            if C.relations and C.relations.friend and M and C.relations.friend[M] then
                                                Y = true
                                            end
                                            if not Y and j and j.get_priority then
                                                local Z, _ =
                                                    pcall(
                                                    function()
                                                        return j.get_priority(J)
                                                    end
                                                )
                                                if Z and _ == "Friendly" then
                                                    Y = true
                                                end
                                            end
                                            if not Y then
                                                local ah = false
                                                if
                                                    C.relations and C.relations.priority and M and
                                                        C.relations.priority[M]
                                                 then
                                                    ah = true
                                                end
                                                if not ah and j and j.get_priority then
                                                    local Z, _ =
                                                        pcall(
                                                        function()
                                                            return j.get_priority(J)
                                                        end
                                                    )
                                                    if Z and _ == "Priority" then
                                                        ah = true
                                                    end
                                                end
                                                if ah and C:ValidateClient(J) then
                                                    local a4 = J.Character
                                                    local a5 = a4 and a4:FindFirstChild("BodyEffects")
                                                    local a6 = a5 and a5:FindFirstChild("K.O")
                                                    if not (a6 and a6.Value) then
                                                        table.insert(ae, J)
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    if #ae == 0 then
                                        return
                                    end
                                    C._fling_wave_running = true
                                    local ak = B and B.task or task
                                    ak.spawn(
                                        function()
                                            local ao = C._fling_gen
                                            for i = 1, #ae do
                                                if ao ~= C._fling_gen or not (g and g["fling_priority_enabled"]) then
                                                    break
                                                end
                                                local b8 = ae[i]
                                                if b8 and b8.Parent then
                                                    local Z = pcall(aO, b8)
                                                    if not Z then
                                                        shared = shared or {}
                                                        shared.Rebuild_FlingActive = false
                                                    end
                                                    ak.wait(0.1)
                                                end
                                            end
                                            C._fling_wave_running = false
                                        end
                                    )
                                end
                            )
                        else
                            if C._fling_conn then
                                pcall(
                                    function()
                                        C._fling_conn:Disconnect()
                                    end
                                )
                                C._fling_conn = nil
                            end
                            shared.Rebuild_FlingActive = false
                            C._fling_gen = (C._fling_gen or 0) + 1
                            C._fling_wave_running = false
                            if C._voiding and C._voiding.enabled and C._void_start then
                                pcall(C._void_start)
                            end
                            C._void_paused_by_fling = false
                        end
                    end
                }
            )
        end
        local function ensure_visuals()
            if not state.viz_part then
                local b9 = Instance.new("Part")
                b9.Name = "RB_DesyncViz"
                b9.Anchored = true
                b9.CanCollide = false
                b9.Massless = true
                b9.Material = Enum.Material.Neon
                b9.Color = Color3.fromRGB(255, 80, 80)
                b9.Size = Vector3.new(0.6, 0.6, 0.6)
                b9.Transparency = 0.1
                b9.Parent = workspace
                state.viz_part = b9
            end
            if not state.viz_line then
                local ba = Drawing.new("Line")
                ba.Visible = false
                ba.Thickness = 2
                ba.Transparency = 1
                ba.Color = Color3.fromRGB(255, 80, 80)
                state.viz_line = ba
            end
        end
        local function bb()
            if state.followMode then
                local bc, bc, bd = desync_utility:getPlayerParts(LocalPlayer)
                return bd and bd.CFrame or nil
            end
            return state.targetCFrame or state.realCFrame
        end
        local function be()
            if not state.viz_enabled then
                return
            end
            if not desync_utility:ValidateClient(LocalPlayer) then
                return
            end
            ensure_visuals()
            local bf = bb()
            local bg = state.viz_part
            local ba = state.viz_line
            if not bf or not bg or not ba then
                return
            end
            bg.CFrame = bf
            local bh = bf.Position
            local bi, bj = desync_vars.cam:WorldToViewportPoint(bh)
            local bk = desync_vars.uis:GetMouseLocation()
            local bl = Vector2.new(bi.X, bi.Y)
            ba.From = bk
            ba.To = bl
            ba.Visible = bj == true
            bg.Transparency = 0.1
        end
        local function start_visuals()
            if state.viz_conn then
                return
            end
            state.viz_conn =
                desync_vars.RunService.RenderStepped:Connect(
                function()
                    if not state.viz_enabled then
                        return
                    end
                    be()
                end
            )
        end
        local function stop_visuals()
            if state.viz_conn then
                pcall(
                    function()
                        state.viz_conn:Disconnect()
                    end
                )
                state.viz_conn = nil
            end
            if state.viz_line then
                state.viz_line.Visible = false
            end
            if state.viz_part then
                state.viz_part.Transparency = 1
            end
        end
        function C:GetPreferredPart(a3)
            return a3 and
                (a3:FindFirstChild("HumanoidRootPart") or a3:FindFirstChild("Head") or a3:FindFirstChild("UpperTorso") or
                    a3:FindFirstChild("Torso")) or
                nil
        end
        function C:ToScreen(bh)
            local bi, bj = B.cam:WorldToViewportPoint(bh)
            return B.v2.new(bi.X, bi.Y), bj
        end
        function C:GetMouseLocation()
            return B.uis:GetMouseLocation()
        end
        function C:GetMouseDistance(bm)
            return (self:GetMouseLocation() - bm).Magnitude
        end
        function C:GetClosestToMouse()
            local bn, bo = nil, nil
            for bc, bp in ipairs(B.ps:GetPlayers()) do
                if bp ~= i and self:ValidateClient(bp) then
                    local a3 = bp.Character
                    local bg = self:GetPreferredPart(a3)
                    if bg then
                        local bq, bj = self:ToScreen(bg.Position)
                        if bj then
                            local br = self:GetMouseDistance(bq)
                            if not bo or br < bo then
                                bn, bo = bp, br
                            end
                        end
                    end
                end
            end
            return bn, bo or B.math.huge
        end
        C._hit_listeners = {}
        C._target = {info = nil, listeners = {}}
        function C:OnHit(bs)
            if typeof(bs) == "function" then
                table.insert(self._hit_listeners, bs)
            end
        end
        function C:OnTargetUpdate(bs)
            if typeof(bs) == "function" then
                table.insert(self._target.listeners, bs)
            end
        end
        function C:_emit_hit(aD)
            for bc, bt in ipairs(self._hit_listeners) do
                pcall(bt, aD)
            end
        end
        function C:_chat(bu)
            local bv = game:GetService("StarterGui")
            pcall(
                function()
                    bv:SetCore("ChatMakeSystemMessage", {Text = bu})
                end
            )
            print(bu)
        end
        function C:GetTargetInfo()
            local aD = self._target.info
            return aD ~= nil, aD
        end
        function C:SetTargetInfo(az)
            local aD = nil
            C._dd.override_player = az or nil
            if az and az.Character then
                local a3 = az.Character
                local aA = a3:FindFirstChildOfClass("Humanoid")
                local bw = aA and aA.RootPart or a3:FindFirstChild("HumanoidRootPart")
                local bx = aA and aA.Health or nil
                local by = aA and aA.MaxHealth or nil
                local bf = bw and bw.CFrame or (a3.GetPivot and a3:GetPivot() or nil)
                local bh = bw and bw.Position or (bf and bf.Position or nil)
                aD = {
                    isTarget = true,
                    player = az,
                    userId = az.UserId,
                    name = az.Name,
                    displayName = az.DisplayName,
                    character = a3,
                    humanoid = aA,
                    root = bw,
                    cframe = bf,
                    position = bh,
                    health = bx,
                    maxHealth = by,
                    alive = aA and aA.Health > 0,
                    time = os.clock()
                }
            end
            self._target.info = aD
            for bc, bt in ipairs(self._target.listeners) do
                pcall(bt, aD)
            end
            if g and g["Debug"] then
                if aD then
                    print("[TargetFeed] SetTargetInfo:", aD.name)
                else
                    print("[TargetFeed] SetTargetInfo (char not ready):", az and az.Name or "nil")
                end
            end
        end

        function C:ClearTargetInfo()
            self._target.info = nil
            C._dd.override_player = nil
            for bc, bt in ipairs(self._target.listeners) do
                pcall(bt, nil)
            end
            if g and g["Debug"] then
                print("[TargetFeed] ClearTargetInfo")
            end
        end
        C._dd = {
            last_target = nil,
            last_char = nil,
            hum = nil,
            last_health = nil,
            last_max = nil,
            conn = nil,
            hum_conn = nil,
            last_debug_t = 0,
            override_player = nil
        }
        function C:SetCurrentTarget(az)
            C._dd.override_player = az
            if g and g["Debug"] then
                print("[DD] SetCurrentTarget:", az and az.Name)
            end
        end
        function C:ClearCurrentTarget()
            C._dd.override_player = nil
            if g and g["Debug"] then
                print("[DD] ClearCurrentTarget")
            end
        end
        if not C._dd.conn then
            C._dd.conn =
                B.run.Heartbeat:Connect(
                function()
                    local bz = C._dd
                    local bA = C._dd.override_player or (targeting_state and targeting_state.current or nil)
                    if g and g["Debug"] then
                        local I = os.clock()
                        if I - (bz.last_debug_t or 0) > 1 then
                            bz.last_debug_t = I
                            print(
                                string.format(
                                    "[DD] hb: current=%s hum=%s lh=%s lm=%s",
                                    bA and bA.Name or "nil",
                                    bz.hum and "ok" or "nil",
                                    tostring(bz.last_health),
                                    tostring(bz.last_max)
                                )
                            )
                        end
                    end
                    if bA ~= bz.last_target then
                        bz.last_target = bA
                        bz.last_char = nil
                        bz.hum = nil
                        bz.last_health = nil
                        bz.last_max = nil
                        if bz.hum_conn then
                            pcall(
                                function()
                                    bz.hum_conn:Disconnect()
                                end
                            )
                            bz.hum_conn = nil
                        end
                        if g and g["Debug"] then
                            print("[DD] target switched to:", bA and bA.Name)
                        end
                    end
                    if not bA then
                        return
                    end
                    local a3 = bA.Character
                    if a3 ~= bz.last_char or bz.hum and not bz.hum.Parent then
                        bz.last_char = a3
                        bz.hum = a3 and a3:FindFirstChildOfClass("Humanoid") or nil
                        bz.last_health = nil
                        bz.last_max = nil
                        if bz.hum_conn then
                            pcall(
                                function()
                                    bz.hum_conn:Disconnect()
                                end
                            )
                            bz.hum_conn = nil
                        end
                        if bz.hum then
                            B.run.Heartbeat:Wait()
                            if g and g["Debug"] then
                                print("[DD] humanoid bound for:", bA and bA.Name)
                            end
                            bz.hum_conn =
                                bz.hum.HealthChanged:Connect(
                                function(bB)
                                    local bC = bz.hum and bz.hum.MaxHealth or 0
                                    if bz.last_health == nil or bz.last_max == nil or bC ~= bz.last_max then
                                        bz.last_health = bB
                                        bz.last_max = bC
                                        return
                                    end
                                    if bB ~= bz.last_health then
                                        local bD = bz.last_health - bB
                                        if bD > 0 then
                                            local bE = B.math.floor((bC > 0 and bB / bC or 0) * 100 + 0.5)
                                            local bF = {
                                                player = bA,
                                                damage = bD,
                                                health = bB,
                                                max = bC,
                                                percentage = bE
                                            }
                                            if g and g["Debug"] then
                                                print(
                                                    "[DD] hit:",
                                                    bF.player and bF.player.Name,
                                                    bF.damage,
                                                    bF.health,
                                                    bF.max,
                                                    bF.percentage
                                                )
                                            end
                                        end
                                        bz.last_health = bB
                                        bz.last_max = bC
                                    end
                                end
                            )
                        end
                    end
                    local aA = bz.hum
                    if not aA or not aA.Parent then
                        return
                    end
                    local bB = aA.Health
                    local bC = aA.MaxHealth
                    if bz.last_health == nil or bz.last_max == nil or bC ~= bz.last_max then
                        bz.last_health = bB
                        bz.last_max = bC
                        return
                    end
                    if bB ~= bz.last_health then
                        local bD = bz.last_health - bB
                        if bD > 0 then
                            local bE = B.math.floor((bC > 0 and bB / bC or 0) * 100 + 0.5)
                            local aD = {player = bA, damage = bD, health = bB, max = bC, percentage = bE}
                            C:_emit_hit(aD)
                        end
                        bz.last_health = bB
                        bz.last_max = bC
                    end
                end
            )
            C:OnHit(
                function(aD)
                    local bG = aD.player and aD.player.Name or "?"
                    local bD = B.math.floor(aD.damage + 0.5)
                    local bH = B.math.floor(aD.health + 0.5)
                    local bI = B.math.floor(aD.max + 0.5)
                    local bJ = B.math.floor(aD.percentage + 0.5)
                    C:_chat(string.format("[Hit] %s -%d HP | %d/%d (%d%%)", bG, bD, bH, bI, bJ))
                end
            )
        end
    end
    do
        local bK = {Desync = {Enabled = false, LogInterval = 2}}
        local desync_vars = {
            Players = game:GetService("Players"),
            RunService = game:GetService("RunService"),
            StarterGui = game:GetService("StarterGui"),
            newcf = CFrame.new,
            v3 = Vector3.new,
            typeof = typeof,
            task = task,
            math = math,
            cam = workspace.CurrentCamera,
            uis = game:GetService("UserInputService")
        }
        local LocalPlayer = desync_vars.Players.LocalPlayer
        local bL = task.wait
        local state = {
            enabled = false,
            targetCFrame = nil,
            realCFrame = nil,
            hookInstalled = false,
            logStarted = false,
            followMode = false,
            viz_enabled = false,
            viz_part = nil,
            viz_line = nil,
            viz_conn = nil
        }
        local desync_utility = {}
        function desync_utility:ValidateClient(az)
            if not az then
                return false
            end
            local a3 = az.Character
            if not a3 then
                return false
            end
            local aA = a3:FindFirstChildOfClass("Humanoid")
            if not aA or aA.Health <= 0 then
                return false
            end
            local bd = aA.RootPart
            return bd ~= nil
        end
        function desync_utility:getPlayerParts(az)
            local a3 = az and az.Character
            local aA = a3 and a3:FindFirstChildOfClass("Humanoid")
            local bd = aA and aA.RootPart
            return a3, aA, bd
        end
        local function bM(a0, bN, bO)
            local bP = desync_vars.typeof(a0)
            if bP == "CFrame" then
                return a0
            end
            if bP == "Vector3" then
                return desync_vars.newcf(a0)
            end
            if bP == "table" and a0[1] and a0[2] and a0[3] then
                return desync_vars.newcf(a0[1], a0[2], a0[3])
            end
            if bP == "number" and type(bN) == "number" and type(bO) == "number" then
                return desync_vars.newcf(a0, bN, bO)
            end
            return nil
        end
        local function bQ()
            if state.hookInstalled then
                return
            end
            if not hookmetamethod or not newcclosure or not checkcaller then
                state.hookInstalled = true
                return
            end
            local bR
            bR =
                hookmetamethod(
                game,
                "__index",
                newcclosure(
                    function(self, bS)
                        if not checkcaller() then
                            if bS == "CFrame" and state.enabled then
                                local bc, aA, bd = desync_utility:getPlayerParts(LocalPlayer)
                                if bd and self == bd and state.realCFrame then
                                    return state.realCFrame
                                end
                            end
                        end
                        return bR(self, bS)
                    end
                )
            )
            state.hookInstalled = true
        end
        local function bT()
            if state.heartbeatConn then
                return
            end
            state.heartbeatConn =
                desync_vars.RunService.Heartbeat:Connect(
                function()
                    if not bK.Desync.Enabled or not state.enabled then
                        return
                    end
                    if not desync_utility:ValidateClient(LocalPlayer) then
                        return
                    end
                    local bc, bc, bd = desync_utility:getPlayerParts(LocalPlayer)
                    if not bd then
                        return
                    end
                    state.realCFrame = bd.CFrame
                    local bU
                    if state.followMode then
                        bU = bd.CFrame
                    else
                        bU = state.targetCFrame or state.realCFrame
                    end
                    bd.CFrame = bU
                    desync_vars.RunService.RenderStepped:Wait()
                    bd.CFrame = state.realCFrame
                end
            )
        end
        local function bV()
            if state.logStarted then
                return
            end
            state.logStarted = true
            desync_vars.task.spawn(
                function()
                    while true do
                        desync_vars.task.wait(bK.Desync.LogInterval)
                        if bK.Desync.Enabled and state.enabled then
                            local bh
                            if state.targetCFrame then
                                bh = state.targetCFrame.Position
                            else
                                local bc, bc, bd = desync_utility:getPlayerParts(LocalPlayer)
                                bh = bd and bd.Position or nil
                            end
                            if bh then
                                print(string.format("[DesyncLibrary] Pos: (%.2f, %.2f, %.2f)", bh.X, bh.Y, bh.Z))
                            else
                                print("[DesyncLibrary] Pos: nil (not set)")
                            end
                        end
                    end
                end
            )
        end
        local bW = {}
        function bW.movedesyncto(a0, bN, bO)
            local bf = bM(a0, bN, bO)
            if not bf then
                error("movedesyncto: invalid coordinates")
            end
            state.targetCFrame = bf
            state.followMode = false
            bK.Desync.Enabled = true
            state.enabled = true
            bQ()
            bT()
            bV()
            return bf
        end
        function bW.checksyncposition()
            local bh
            if state.targetCFrame then
                bh = state.targetCFrame.Position
            else
                local bc, bc, bd = desync_utility:getPlayerParts(LocalPlayer)
                bh = bd and bd.Position or nil
            end
            if bh then
                print(string.format("[DesyncLibrary] Pos: (%.2f, %.2f, %.2f)", bh.X, bh.Y, bh.Z))
            else
                print("[DesyncLibrary] Pos: nil (not set)")
            end
            return bh
        end
        function bW.SynchronizeSyncWithPlayer()
            if not desync_utility:ValidateClient(LocalPlayer) then
                error("SynchronizeSyncWithPlayer: player not ready")
            end
            state.targetCFrame = nil
            state.followMode = true
            bK.Desync.Enabled = true
            state.enabled = true
            bQ()
            bT()
            bV()
            local bc, bc, bd = desync_utility:getPlayerParts(LocalPlayer)
            return bd and bd.CFrame or nil
        end
        function bW.SetVisualiseEnabled(bX)
            state.viz_enabled = bX and true or false
            if state.viz_enabled then
                ensure_visuals()
                start_visuals()
            else
                stop_visuals()
            end
            return state.viz_enabled
        end
        pcall(
            function()
                getgenv().DesyncLibrary = bW
            end
        )
        _G.DesyncLibrary = bW
    end
    local targeting_state = {current = nil}
    -- expose to global for cross-module access (e.g., crosshair AttachToTarget)
    pcall(function() _G.targeting_state = targeting_state end)
    do
        local bY = {}
        local bZ = {
            last_char = nil,
            hl = nil,
            occ_hl = nil,
            occ_model = nil,
            char_added_conn = nil,
            char_removing_conn = nil,
            died_conn = nil,
            bound_player = nil,
            update_counter = 0
        }
        local b_ = "RB_HL_32v"
        local function c0()
            local c1 = Instance.new("Highlight")
            c1.Name = b_
            c1.DepthMode = Enum.HighlightDepthMode.Occluded
            return c1
        end
        local function c2(a3)
            if bZ.occ_model then
                pcall(
                    function()
                        bZ.occ_model:Destroy()
                    end
                )
                bZ.occ_model = nil
            end
            if not a3 then
                return
            end
            local c3 = Instance.new("Model")
            c3.Name = "RB_TH_OCC"
            c3.Parent = workspace
            for bc, c4 in ipairs(a3:GetChildren()) do
                if c4:IsA("BasePart") then
                    local c5 = c4:Clone()
                    c5:ClearAllChildren()
                    c5.CanCollide = false
                    if c5:IsA("MeshPart") then
                        c5.TextureID = ""
                    end
                    c5.Size = c5.Size * 0.99
                    c5.Parent = c3
                    local c6 = Instance.new("WeldConstraint")
                    c6.Part0 = c5
                    c6.Part1 = c4
                    c6.Parent = c5
                end
            end
            bZ.occ_model = c3
        end
        local function c7()
            if bZ.hl then
                bZ.hl.Enabled = false
                bZ.hl.Adornee = nil
                bZ.hl.Parent = nil
            end
            if bZ.occ_hl then
                bZ.occ_hl.Enabled = false
                bZ.occ_hl.Adornee = nil
                bZ.occ_hl.Parent = nil
            end
            if bZ.occ_model then
                pcall(
                    function()
                        bZ.occ_model:Destroy()
                    end
                )
                bZ.occ_model = nil
            end
            if bZ.died_conn then
                pcall(
                    function()
                        bZ.died_conn:Disconnect()
                    end
                )
                bZ.died_conn = nil
            end
            if bZ.char_added_conn then
                pcall(
                    function()
                        bZ.char_added_conn:Disconnect()
                    end
                )
                bZ.char_added_conn = nil
            end
            if bZ.char_removing_conn then
                pcall(
                    function()
                        bZ.char_removing_conn:Disconnect()
                    end
                )
                bZ.char_removing_conn = nil
            end
            bZ.last_char = nil
            bZ.bound_player = nil
        end
        local function c8()
            if bZ.hl then
                bZ.hl.Enabled = false
                bZ.hl.Adornee = nil
            end
            if bZ.occ_hl then
                bZ.occ_hl.Enabled = false
                bZ.occ_hl.Adornee = nil
            end
            bZ.last_char = nil
        end
        local function c9(ca, cb)
            local cc = g and g[ca]
            if cc == nil then
                return cb
            end
            local bP = typeof(cc)
            if bP == "table" and cc.Color then
                return cc.Color
            end
            if bP == "Color3" then
                return cc
            end
            return cb
        end
        local function cd(ca, cb)
            local cc = g and g[ca]
            if typeof(cc) == "number" then
                return cc
            end
            return cb
        end
        local function ce(a3)
            if not a3 or not g or not g["target_highlight"] then
                c8()
                return
            end
            if not bZ.hl then
                bZ.hl = c0()
            end
            if not bZ.occ_hl then
                bZ.occ_hl = c0()
            end
            if not bZ.occ_model or not bZ.occ_model.Parent then
                c2(a3)
            end
            local c1 = bZ.hl
            c1.DepthMode = Enum.HighlightDepthMode.Occluded
            c1.FillColor = c9("th_fill", Color3.fromRGB(255, 255, 0))
            c1.OutlineColor = c9("th_out", Color3.fromRGB(0, 0, 0))
            c1.FillTransparency = cd("th_ftrs", 0.5)
            c1.OutlineTransparency = cd("th_otrs", 0.5)
            if c1.Adornee ~= a3 then
                c1.Adornee = a3
            end
            if c1.Parent ~= a3 then
                c1.Parent = a3
            end
            c1.Enabled = true
            local cf = bZ.occ_hl
            cf.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            cf.FillColor = c9("th_occ_fill", Color3.fromRGB(0, 170, 255))
            cf.OutlineColor = c9("th_occ_out", Color3.fromRGB(0, 0, 0))
            cf.FillTransparency = cd("th_occ_ftrs", 0.3)
            cf.OutlineTransparency = cd("th_occ_otrs", 0.7)
            if cf.Adornee ~= bZ.occ_model then
                cf.Adornee = bZ.occ_model
            end
            if cf.Parent ~= bZ.occ_model then
                cf.Parent = bZ.occ_model
            end
            cf.Enabled = true
            bZ.last_char = a3
        end
        local function cg(a3)
            if not a3 then
                return
            end
            local aA = a3:FindFirstChildOfClass("Humanoid")
            if aA then
                if bZ.died_conn then
                    pcall(
                        function()
                            bZ.died_conn:Disconnect()
                        end
                    )
                end
                bZ.died_conn =
                    aA.Died:Connect(
                    function()
                        print("[TH] Humanoid died for:", a3.Name, "- removing visual highlight")
                        c8()
                    end
                )
            end
        end
        local function ch(a3)
            if not a3 then
                return
            end
            print("[TH] Cleanup highlights for:", a3.Name)
            if bZ.hl then
                bZ.hl.Enabled = false
                bZ.hl.Adornee = nil
            end
            for bc, ci in ipairs(a3:GetDescendants()) do
                if typeof(ci) == "Instance" and ci:IsA("Highlight") and ci ~= bZ.hl then
                    pcall(
                        function()
                            ci:Destroy()
                        end
                    )
                end
            end
        end
        local function cj(az)
            if not az then
                return
            end
            if bZ.char_added_conn then
                pcall(
                    function()
                        bZ.char_added_conn:Disconnect()
                    end
                )
            end
            if bZ.char_removing_conn then
                pcall(
                    function()
                        bZ.char_removing_conn:Disconnect()
                    end
                )
            end
            bZ.bound_player = az
            bZ.char_removing_conn =
                az.CharacterRemoving:Connect(
                function()
                    print("[TH] CharacterRemoving for:", az.Name)
                    c8()
                end
            )
            bZ.char_added_conn =
                az.CharacterAdded:Connect(
                function(ck)
                    if not ck then
                        return
                    end
                    print("[TH] CharacterAdded for:", az.Name)
                    game:GetService("RunService").Heartbeat:Wait()
                    local cl =
                        targeting_state and targeting_state.current and
                        (targeting_state.current == az or
                            targeting_state.current.UserId and targeting_state.current.UserId == az.UserId)
                    if cl and g and g["target_highlight"] then
                        print("[TH] Reapplying highlight after respawn for:", az.Name)
                        ce(ck)
                        cg(ck)
                    end
                end
            )
            if az.Character then
                ce(az.Character)
                cg(az.Character)
            end
        end
        local function cm(a3)
            if not a3 then
                return false
            end
            local cn = workspace.CurrentCamera
            local bw = a3:FindFirstChild("HumanoidRootPart") or a3:FindFirstChild("Head")
            if not bw then
                return false
            end
            local co = cn.CFrame.Position
            local cp = bw.Position - co
            local cq = RaycastParams.new()
            cq.FilterType = Enum.RaycastFilterType.Blacklist
            cq.FilterDescendantsInstances = {i.Character, a3, bZ.occ_model}
            local cr = workspace:Raycast(co, cp, cq)
            return cr == nil
        end
        function bY:update_target_highlight()
            if not g or not g["target_highlight"] then
                c7()
                return
            end
            local bA = targeting_state and targeting_state.current
            local a3 = bA and bA.Character
            if not a3 then
                c7()
                return
            end
            if bZ.last_char ~= a3 then
                ce(a3)
                cg(a3)
            end
            local cs = cm(a3)
            if bZ.occ_hl then
                bZ.occ_hl.Enabled = not cs
            end
        end
        function bY:selectTarget()
            if not g or not g["Targeting_Enabled"] then
                return
            end
            if g and g["Debug"] then
                print("[Targeting] selectTarget called")
            end
            if targeting_state.current then
                if g and g["Debug"] then
                    print("[Targeting] Releasing target:", targeting_state.current.Name)
                end
                c7()
                targeting_state.current = nil
                C:ClearTargetInfo()
                C:ClearCurrentTarget()
                if targeting_keybind and targeting_keybind.update_visibility then
                    targeting_keybind.update_visibility()
                end
                if g and g["Debug"] then
                    print("[Targeting] Target cleared")
                end
            else
                local ct, cu = C:GetClosestToMouse()
                if ct then
                    targeting_state.current = ct
                    C:SetTargetInfo(ct)
                    C:SetCurrentTarget(ct)
                    if g and g["target_highlight"] then
                        cj(ct)
                    end
                    if targeting_keybind and targeting_keybind.update_visibility then
                        targeting_keybind.update_visibility()
                    end
                    if g and g["Debug"] then
                        print(
                            "[Targeting] Target acquired:",
                            targeting_state.current.Name,
                            "(MouseDist:",
                            B.math.floor(cu),
                            ")"
                        )
                    end
                else
                    if g and g["Debug"] then
                        print("[Targeting] No target found")
                    end
                end
            end
        end
        local cv = t:column()
        local cw, cx = cv:multi_section({names = {"Targeting", "Visuals"}})
        local targeting_keybind
        local cy =
            cw:toggle(
            {name = "Enabled", flag = "Targeting_Enabled", default = false, callback = function(state)
                    if not state then
                        if g and g["Debug"] then
                            print("[Targeting] Disabled -> clearing target")
                        end
                        c7()
                        targeting_state.current = nil
                        C:ClearTargetInfo()
                        C:ClearCurrentTarget()
                        if targeting_keybind and targeting_keybind.update_visibility then
                            targeting_keybind.update_visibility()
                        end
                    end
                end}
        )
        targeting_keybind =
            cy:keybind(
            {name = "Target", flag = "Target_Select_Bind", default = "t", visibility_condition = function()
                    return targeting_state and targeting_state.current ~= nil
                end, callback = function()
                    bY:selectTarget()
                end}
        )
        local cz =
            cw:dropdown(
            {name = "Selecting Mode", flag = "Targeting_Mode", items = {"Sticky", "Nuker"}, default = "Sticky"}
        )
        local function cA()
            if not g or not g["target_highlight"] then
                return
            end
            local a3 = bZ and bZ.last_char
            if not a3 and targeting_state and targeting_state.current then
                a3 = targeting_state.current.Character
                if a3 then
                    bZ.last_char = a3
                end
            end
            if a3 then
                ce(a3)
                cg(a3)
            end
        end
        local cB =
            cx:toggle(
            {name = "Target Highlight", flag = "target_highlight", default = false, callback = function(state)
                    if state then
                        cA()
                    else
                        c7()
                    end
                end}
        )
        cB:colorpicker(
            {name = "Fill", flag = "th_fill", default = Color3.fromRGB(255, 255, 0), callback = function()
                    cA()
                end}
        )
        cB:colorpicker(
            {name = "Outline", flag = "th_out", default = Color3.fromRGB(0, 0, 0), callback = function()
                    cA()
                end}
        )
        cB:colorpicker(
            {name = "OccludedFill", flag = "th_occ_fill", default = Color3.fromRGB(0, 170, 255), callback = function()
                    cA()
                end}
        )
        cB:colorpicker(
            {name = "OccludedOutline", flag = "th_occ_out", default = Color3.fromRGB(0, 0, 0), callback = function()
                    cA()
                end}
        )
        local cC = cx:dependency_box()
        cC:setup_dependencies({{cB, true}})
        cC:slider(
            {
                name = "Fill Transparency",
                flag = "th_ftrs",
                min = 0,
                max = 1,
                default = 0.5,
                interval = 0.01,
                callback = function()
                    cA()
                end
            }
        )
        cC:slider(
            {
                name = "Outline Transparency",
                flag = "th_otrs",
                min = 0,
                max = 1,
                default = 0.5,
                interval = 0.01,
                callback = function()
                    cA()
                end
            }
        )
        cC:slider(
            {
                name = "OccludedFill Transparency",
                flag = "th_occ_ftrs",
                min = 0,
                max = 1,
                default = 0.3,
                interval = 0.01,
                callback = function()
                    cA()
                end
            }
        )
        cC:slider(
            {
                name = "OccludedOutline Transparency",
                flag = "th_occ_otrs",
                min = 0,
                max = 1,
                default = 0.7,
                interval = 0.01,
                callback = function()
                    cA()
                end
            }
        )
        do
            local cD = {
                enabled = false,
                folder = nil,
                handles = {},
                fill_color = c("#ffffff"),
                fill_transparency = 0.5,
                last_target = nil
            }
            local function cE()
                for bc, cF in pairs(cD.handles) do
                    pcall(
                        function()
                            cF:Destroy()
                        end
                    )
                end
                cD.handles = {}
                if cD.folder then
                    pcall(
                        function()
                            cD.folder:Destroy()
                        end
                    )
                    cD.folder = nil
                end
            end
            local function cG(a3)
                if not a3 then
                    return
                end
                if not cD.folder then
                    cD.folder = Instance.new("Folder")
                    cD.folder.Name = "RB_Chams"
                    cD.folder.Parent = workspace.CurrentCamera
                end
                for bc, cF in pairs(cD.handles) do
                    pcall(
                        function()
                            cF:Destroy()
                        end
                    )
                end
                cD.handles = {}
                for bc, bg in ipairs(a3:GetChildren()) do
                    if
                        bg:IsA("BasePart") and
                            (bg.Name:find("Arm") or bg.Name:find("Leg") or bg.Name:find("Hand") or bg.Name:find("Feet") or
                                bg.Name:find("Foot") or
                                bg.Name:find("Torso") or
                                bg.Name == "Head")
                     then
                        local cF = Instance.new("BoxHandleAdornment")
                        cF.Size = bg.Size
                        cF.Adornee = bg
                        cF.AlwaysOnTop = true
                        cF.ZIndex = 0
                        cF.Transparency = cD.fill_transparency
                        cF.Color3 = cD.fill_color
                        cF.Parent = cD.folder
                        table.insert(cD.handles, cF)
                    end
                end
            end
            local function cH()
                if not cD.enabled then
                    cE()
                    return
                end
                local bU = targeting_state and targeting_state.current
                if not bU or not bU.Character then
                    cE()
                    cD.last_target = nil
                    return
                end
                if cD.last_target ~= bU.Character then
                    cG(bU.Character)
                    cD.last_target = bU.Character
                end
                for bc, cF in pairs(cD.handles) do
                    if cF and cF.Parent then
                        cF.Color3 = cD.fill_color
                        cF.Transparency = cD.fill_transparency
                        cF.AlwaysOnTop = true
                    end
                end
            end
            local cI =
                cx:toggle(
                {name = "Target Chams", flag = "target_chams", default = false, callback = function(state)
                        cD.enabled = state
                        if state then
                            cH()
                        else
                            cE()
                        end
                    end}
            )
            cI:colorpicker(
                {name = "Color", flag = "chams_color", default = c("#ffffff"), callback = function(cJ)
                        cD.fill_color = cJ
                        cH()
                    end}
            )
            local cK = cx:dependency_box()
            cK:setup_dependencies({{cI, true}})
            cK:slider(
                {
                    name = "Trs",
                    flag = "chams_trs",
                    min = 0,
                    max = 1,
                    default = 0.5,
                    interval = 0.01,
                    callback = function(cL)
                        cD.fill_transparency = cL
                        cH()
                    end
                }
            )
            table.insert(
                a.connections,
                B.run.RenderStepped:Connect(
                    function()
                        if cD.enabled then
                            cH()
                        end
                    end
                )
            )
            C:OnTargetUpdate(
                function(aD)
                    if not aD then
                        cE()
                        cD.last_target = nil
                    end
                end
            )
        end
        do
            local cM = {
                enabled = false,
                style = "Custom",
                c1 = Color3.fromRGB(128, 18, 255),
                c2 = Color3.fromRGB(255, 0, 128),
                c3 = Color3.fromRGB(0, 200, 255),
                c4 = Color3.fromRGB(255, 255, 0),
                height = 0.7,
                radius = 2,
                sides = 25,
                hat_trs = 0.35,
                line_trs = 1.0,
                drawings = {},
                conn = nil,
                speed = 0.2
            }
            local function cN(a5, cO, bP)
                return a5 + (cO - a5) * bP
            end
            local function cP(a5, cO, bP)
                return Color3.new(cN(a5.R, cO.R, bP), cN(a5.G, cO.G, bP), cN(a5.B, cO.B, bP))
            end
            local function cQ(bP, cR)
                local cS = (bP + cR * cM.speed) % 1
                if cS < 0.25 then
                    return cP(cM.c1, cM.c2, cS / 0.25)
                elseif cS < 0.5 then
                    return cP(cM.c2, cM.c3, (cS - 0.25) / 0.25)
                elseif cS < 0.75 then
                    return cP(cM.c3, cM.c4, (cS - 0.5) / 0.25)
                else
                    return cP(cM.c4, cM.c1, (cS - 0.75) / 0.25)
                end
            end
            local function cT(cU, bP, cR, cV)
                local cW = #cU
                if cW == 0 then
                    return Color3.new(1, 1, 1)
                end
                if cW == 1 then
                    return cU[1]
                end
                local cS = (bP + cR * (cV or cM.speed)) % 1
                local cX = cS * cW
                local cY = math.floor(cX) + 1
                local cZ = cX - math.floor(cX)
                local a5 = cU[cY]
                local cO = cU[cY % cW + 1]
                return cP(a5, cO, cZ)
            end
            local function c_(bP, cR)
                local cU = {Color3.fromRGB(255, 105, 180), Color3.fromRGB(255, 75, 150), Color3.fromRGB(135, 206, 250)}
                return cT(cU, bP, cR, 0.25)
            end
            local function d0(bP, cR)
                local d1 = (cR * 0.2 + bP) % 1
                return Color3.fromHSV(d1, 0.6, 1)
            end
            -- Create maximum possible drawings once
            local MAX_SIDES = 30 -- Maximum sides we'll ever need
            local function d2()
                if #cM.drawings >= MAX_SIDES then
                    return
                end
                
                -- Create all drawings once at startup
                for cY = 1, MAX_SIDES do
                    local ba = Drawing.new("Line")
                    local d4 = Drawing.new("Triangle")
                    ba.ZIndex = 2
                    ba.Thickness = 1
                    ba.Visible = false
                    d4.ZIndex = 1
                    d4.Filled = true
                    d4.Visible = false
                    table.insert(cM.drawings, {ba, d4})
                end
            end
            
            -- Initialize drawings on script load
            d2()
            local function d5(cc)
                -- Only show/hide the active sides
                for bc = 1, MAX_SIDES do
                    local d3 = cM.drawings[bc]
                    if d3 then
                        local ba, d4 = d3[1], d3[2]
                        if ba then
                            ba.Visible = cc and bc <= cM.sides
                        end
                        if d4 then
                            d4.Visible = cc and bc <= cM.sides
                        end
                    end
                end
            end
            local function d6()
                if cM.conn then
                    pcall(
                        function()
                            cM.conn:Disconnect()
                        end
                    )
                    cM.conn = nil
                end
                -- Don't remove drawings, just hide them
                d5(false)
            end
            local d7 = {
                CustomPalette1 = {Color3.fromRGB(255, 94, 58), Color3.fromRGB(255, 154, 0), Color3.fromRGB(255, 212, 0)},
                CustomPalette2 = {
                    Color3.fromRGB(0, 212, 255),
                    Color3.fromRGB(0, 128, 255),
                    Color3.fromRGB(0, 64, 128),
                    Color3.fromRGB(0, 40, 80)
                },
                CustomPalette3 = {Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 102, 0)},
                CustomPalette4 = {
                    Color3.fromRGB(200, 255, 255),
                    Color3.fromRGB(150, 220, 255),
                    Color3.fromRGB(100, 200, 255),
                    Color3.fromRGB(80, 160, 220),
                    Color3.fromRGB(60, 120, 190)
                },
                CustomPalette5 = {Color3.fromRGB(88, 0, 255), Color3.fromRGB(255, 0, 191), Color3.fromRGB(0, 160, 255)},
                CustomPalette6 = {Color3.fromRGB(0, 255, 128), Color3.fromRGB(255, 0, 255), Color3.fromRGB(0, 255, 255)},
                CustomPalette7 = {
                    Color3.fromRGB(255, 255, 255),
                    Color3.fromRGB(200, 200, 200),
                    Color3.fromRGB(150, 150, 150),
                    Color3.fromRGB(100, 100, 100)
                },
                CustomPalette8 = {
                    Color3.fromRGB(255, 20, 147),
                    Color3.fromRGB(186, 85, 211),
                    Color3.fromRGB(72, 61, 139)
                },
                CustomPalette9 = {
                    Color3.fromRGB(0, 255, 255),
                    Color3.fromRGB(173, 216, 230),
                    Color3.fromRGB(25, 25, 112)
                },
                CustomPalette10 = {Color3.fromRGB(255, 215, 0), Color3.fromRGB(255, 165, 0), Color3.fromRGB(255, 69, 0)},
                CustomPalette11 = {Color3.fromRGB(124, 252, 0), Color3.fromRGB(50, 205, 50), Color3.fromRGB(0, 128, 0)},
                CustomPalette12 = {
                    Color3.fromRGB(0, 0, 0),
                    Color3.fromRGB(45, 0, 80),
                    Color3.fromRGB(120, 0, 200),
                    Color3.fromRGB(255, 0, 255)
                },
                CustomPalette13 = {
                    Color3.fromRGB(0, 0, 128),
                    Color3.fromRGB(0, 0, 255),
                    Color3.fromRGB(0, 191, 255),
                    Color3.fromRGB(135, 206, 250)
                },
                CustomPalette14 = {
                    Color3.fromRGB(255, 105, 180),
                    Color3.fromRGB(255, 182, 193),
                    Color3.fromRGB(135, 206, 250)
                },
                CustomPalette15 = {
                    Color3.fromRGB(240, 255, 255),
                    Color3.fromRGB(176, 224, 230),
                    Color3.fromRGB(135, 206, 235),
                    Color3.fromRGB(70, 130, 180)
                },
                CustomPalette16 = {
                    Color3.fromRGB(255, 255, 240),
                    Color3.fromRGB(255, 250, 205),
                    Color3.fromRGB(250, 250, 210),
                    Color3.fromRGB(238, 232, 170)
                }
            }
            local function d8(d9, cR)
                local da = cM.style
                if da == "Rainbow" then
                    return d0(d9, cR)
                elseif da == "Astolfo" then
                    return c_(d9, cR)
                elseif d7[da] ~= nil then
                    return cT(d7[da], d9, cR, 0.2)
                else
                    return cQ(d9, cR)
                end
            end
            local function db()
                -- Always check for target, not just when enabled
                local bU = targeting_state and targeting_state.current
                local a3 = bU and bU.Character or nil
                local dc = a3 and a3:FindFirstChild("Head")
                local aA = a3 and a3:FindFirstChildOfClass("Humanoid")
                
                -- If no valid target or chinahat disabled, hide drawings
                if not cM.enabled or not (a3 and dc and aA and aA.Health > 0) then
                    d5(false)
                    return
                end
                
                local cn = workspace.CurrentCamera
                local head_pos = dc.Position
                
                -- Check camera distance (like in original code)
                local camera_distance = (cn.CFrame.Position - cn.Focus.Position).Magnitude
                if camera_distance < 1 then
                    d5(false)
                    return
                end
                
                -- Check if target is visible on screen
                local screen_pos, on_screen = cn:WorldToViewportPoint(head_pos)
                if not on_screen or screen_pos.Z <= 0 then
                    d5(false)
                    return
                end
                
                local dd = tick()
                local de = math.pi * 2
                local bh = head_pos + Vector3.new(0, 0.75, 0) -- offset from head
                local df = bh + Vector3.new(0, cM.height, 0) -- top of hat
                
                -- Update all sides at once (like original)
                for cY = 1, cM.sides do
                    local d3 = cM.drawings[cY]
                    if d3 then
                        local ba, d4 = d3[1], d3[2]
                        if ba and d4 then
                            -- Calculate angles using same formula as original
                            local last = ((cY - 1) / cM.sides) * de
                            local next = (cY / cM.sides) * de
                            
                            -- Calculate world positions
                            local lastWorld = bh + Vector3.new(math.cos(last), 0, math.sin(last)) * cM.radius
                            local nextWorld = bh + Vector3.new(math.cos(next), 0, math.sin(next)) * cM.radius
                            
                            -- Convert to screen positions
                            local lastScreen = cn:WorldToViewportPoint(lastWorld)
                            local nextScreen = cn:WorldToViewportPoint(nextWorld)
                            local topScreen = cn:WorldToViewportPoint(df)
                            
                            -- Get color for this segment
                            local segment_progress = (cY - 1) / cM.sides
                            local ds = d8(segment_progress, dd)
                            
                            -- Update line (circle base)
                            ba.From = Vector2.new(lastScreen.X, lastScreen.Y)
                            ba.To = Vector2.new(nextScreen.X, nextScreen.Y)
                            ba.Color = ds
                            ba.Transparency = cM.line_trs
                            ba.Visible = true
                            
                            -- Update triangle (hat face)
                            d4.PointA = Vector2.new(topScreen.X, topScreen.Y)
                            d4.PointB = ba.From
                            d4.PointC = ba.To
                            d4.Color = ds
                            d4.Transparency = cM.hat_trs
                            d4.Visible = true
                        end
                    end
                end
                
                -- Hide unused drawings
                for cY = cM.sides + 1, MAX_SIDES do
                    local d3 = cM.drawings[cY]
                    if d3 then
                        if d3[1] then d3[1].Visible = false end
                        if d3[2] then d3[2].Visible = false end
                    end
                end
            end
            local dt =
                cx:toggle(
                {name = "Target ChinaHat", flag = "china_hat", default = false, callback = function(state)
                        cM.enabled = state
                        if state then
                            db()
                        else
                            d6()
                        end
                    end}
            )
            dt:colorpicker(
                {name = "Color 1", flag = "hat_c1", default = cM.c1, callback = function(du)
                        cM.c1 = du
                    end}
            )
            dt:colorpicker(
                {name = "Color 2", flag = "hat_c2", default = cM.c2, callback = function(du)
                        cM.c2 = du
                    end}
            )
            dt:colorpicker(
                {name = "Color 3", flag = "hat_c3", default = cM.c3, callback = function(du)
                        cM.c3 = du
                    end}
            )
            dt:colorpicker(
                {name = "Color 4", flag = "hat_c4", default = cM.c4, callback = function(du)
                        cM.c4 = du
                    end}
            )
            local dv = cx:dependency_box()
            dv:setup_dependencies({{dt, true}})
            local dw =
                dv:dropdown(
                {
                    name = "Style",
                    flag = "hat_style",
                    items = {
                        "Custom",
                        "Rainbow",
                        "Astolfo",
                        "CustomPalette1",
                        "CustomPalette2",
                        "CustomPalette3",
                        "CustomPalette4",
                        "CustomPalette5",
                        "CustomPalette6",
                        "CustomPalette7",
                        "CustomPalette8",
                        "CustomPalette9",
                        "CustomPalette10",
                        "CustomPalette11",
                        "CustomPalette12",
                        "CustomPalette13",
                        "CustomPalette14",
                        "CustomPalette15",
                        "CustomPalette16"
                    },
                    default = "Custom",
                    callback = function(dx)
                        cM.style = dx
                    end
                }
            )
            -- palette-only UI; параметры высоты/радиуса/прозрачности фиксированы конфигом cM
            -- target china hat connection - always running
            local chinahat_conn = B.run.RenderStepped:Connect(db)
            table.insert(a.connections, chinahat_conn)
            -- No need for metatable hook since connection always runs
            -- Clear on target change is handled in db() function
        end
        do
            local dy = {
                enabled = false,
                color = c("#ffffff"),
                size = 1.0,
                speed = 1.0,
                bill = nil,
                img = nil,
                angle = 0,
                conn = nil,
                last_tick = os.clock(),
                asset_items = nil,
                asset_map = nil
            }
            local function dz(dA)
                if getcustomasset then
                    return getcustomasset(dA)
                end
                if getsynasset then
                    return getsynasset(dA)
                end
                return dA
            end
            local function dB()
                local cp = (a and a.directory or "Rebuild.gg") .. "/assets"
                local dC, dD = {}, {}
                local dE, dF =
                    pcall(
                    function()
                        return listfiles and listfiles(cp) or {}
                    end
                )
                if dE and dF and #dF > 0 then
                    table.sort(dF)
                    for bc, cZ in ipairs(dF) do
                        local dG = string.lower(cZ)
                        if dG:sub(-4) == ".png" or dG:sub(-4) == ".jpg" or dG:sub(-5) == ".jpeg" then
                            local bG = cZ:match("([^/\\]+)$") or cZ
                            table.insert(dC, bG)
                            dD[bG] = dz(cZ)
                        end
                    end
                end
                dy.asset_items = dC
                dy.asset_map = dD
                return dC, dD
            end
            local function dH(bG)
                if not bG or bG == "" then
                    return
                end
                local dD = dy.asset_map or select(2, dB())
                local dA = dD and dD[bG]
                if dy.img then
                    dy.img.Image = dA or dy.img.Image or ""
                end
            end
            local function dI()
                local cp = (a and a.directory or "Rebuild.gg") .. "/assets"
                local dE, dF =
                    pcall(
                    function()
                        return listfiles and listfiles(cp) or {}
                    end
                )
                if not dE or not dF or #dF == 0 then
                    return nil
                end
                table.sort(dF)
                for bc, cZ in ipairs(dF) do
                    local dG = string.lower(cZ)
                    if dG:sub(-4) == ".png" or dG:sub(-4) == ".jpg" or dG:sub(-5) == ".jpeg" then
                        return dz(cZ)
                    end
                end
                return dz(dF[1])
            end
            local function dJ()
                if dy.bill then
                    return
                end
                local dK = Instance.new("BillboardGui")
                dK.Name = "RB_TargetESP"
                dK.AlwaysOnTop = true
                dK.LightInfluence = 0
                dK.Size = UDim2.new(dy.size, 0, dy.size, 0)
                dK.Enabled = true
                local dL = Instance.new("ImageLabel")
                dL.Name = "CrosshairImage"
                dL.BackgroundTransparency = 1
                dL.Size = UDim2.new(1, 0, 1, 0)
                dL.Position = UDim2.fromScale(0, 0)
                if not dy.asset_items or not dy.asset_map then
                    dB()
                end
                local dM = g and g["target_esp_image"] or dy.asset_items and dy.asset_items[1]
                dL.Image = dM and dy.asset_map and dy.asset_map[dM] or (dI() or "")
                dL.ImageColor3 = dy.color
                dL.Parent = dK
                dy.bill = dK
                dy.img = dL
            end
            local function dN()
                if dy.bill then
                    pcall(
                        function()
                            dy.bill:Destroy()
                        end
                    )
                end
                dy.bill = nil
                dy.img = nil
            end
            local function dO()
                local az = targeting_state and targeting_state.current
                if not az or not az.Character then
                    return nil
                end
                local a3 = az.Character
                local dP = g and g["aimbot_part"]
                if dP and a3:FindFirstChild(dP) then
                    return a3[dP]
                end
                return C:GetPreferredPart(a3)
            end
            local function dQ()
                if not dy.enabled then
                    return
                end
                dJ()
                local bg = dO()
                if not bg then
                    if dy.bill then
                        dy.bill.Parent = nil
                    end
                    return
                end
                dy.bill.Adornee = bg
                dy.bill.Parent = bg
                local cn = B and B.cam or workspace.CurrentCamera
                local dR = (cn.CFrame.Position - bg.Position).Magnitude
                local dS = math.clamp(dR / 30, 0.8, 4)
                local dT = g and g["target_esp_size"] or dy.size
                dT = (dT or 1) * dS
                dy.bill.Size = UDim2.new(dT, 0, dT, 0)
                local I = os.clock()
                local dU = math.max(0, I - (dy.last_tick or I))
                dy.last_tick = I
                local dV = g and g["target_esp_speed"] or dy.speed
                dy.angle = (dy.angle + (dV or 1) * 180 * dU) % 360
                if dy.img then
                    dy.img.Rotation = dy.angle
                    local cJ = g and g["target_esp_color"] or dy.color
                    if type(cJ) == "table" then
                        if cJ.R and cJ.G and cJ.B then
                            dy.img.ImageColor3 = Color3.new(cJ.R, cJ.G, cJ.B)
                        elseif cJ.r and cJ.g and cJ.b then
                            dy.img.ImageColor3 = Color3.new(cJ.r, cJ.g, cJ.b)
                        else
                            dy.img.ImageColor3 = Color3.new(1, 1, 1)
                        end
                    else
                        dy.img.ImageColor3 = cJ
                    end
                end
            end
            local dW =
                cx:toggle(
                {
                    name = "Target Esp",
                    flag = "target_esp",
                    default = false,
                    callback = function(state)
                        dy.enabled = state
                        if state then
                            dJ()
                            if not dy.conn then
                                dy.conn = B.run.RenderStepped:Connect(dQ)
                                table.insert(a.connections, dy.conn)
                            end
                        else
                            if dy.conn then
                                pcall(
                                    function()
                                        dy.conn:Disconnect()
                                    end
                                )
                            end
                            dy.conn = nil
                            dN()
                        end
                    end
                }
            )
            dW:colorpicker(
                {name = "Color", flag = "target_esp_color", default = c("#ffffff"), callback = function(cJ)
                        dy.color = cJ
                        if dy.img then
                            dy.img.ImageColor3 = cJ
                        end
                    end}
            )
            local dX = cx:dependency_box()
            dX:setup_dependencies({{dW, true}})
            local dC = dB()
            local dY = dC and dC[1] or nil
            dX:dropdown(
                {name = "Image", flag = "target_esp_image", items = dC or {}, default = dY, callback = function(bG)
                        dH(bG)
                    end}
            )
            dX:slider(
                {
                    name = "Size",
                    flag = "target_esp_size",
                    min = 0.1,
                    max = 40,
                    default = 1,
                    interval = 0.05,
                    callback = function(cc)
                        dy.size = cc
                    end
                }
            )
            dX:slider(
                {
                    name = "Speed",
                    flag = "target_esp_speed",
                    min = 0.1,
                    max = 10,
                    default = 1,
                    interval = 0.1,
                    callback = function(cc)
                        dy.speed = cc
                    end
                }
            )
            C:OnTargetUpdate(
                function(aD)
                    if not aD then
                        dN()
                    end
                end
            )
            table.insert(
                a.connections,
                {
                    Disconnect = function()
                        if dy.conn then
                            pcall(
                                function()
                                    dy.conn:Disconnect()
                                end
                            )
                        end
                        dy.conn = nil
                        dN()
                    end
                }
            )
        end
        do
            local dZ = {
                enabled = false,
                body_part = "HumanoidRootPart",
                origin = "mouse",
                line = nil,
                outline = nil,
                connection = nil,
                line_thickness = 2,
                outline_thickness = 4,
                line_color = Color3.fromRGB(255, 255, 255),
                outline_color = Color3.fromRGB(0, 0, 0)
            }
            local function d_()
                if dZ.line then
                    pcall(
                        function()
                            dZ.line:Remove()
                        end
                    )
                    dZ.line = nil
                end
                if dZ.outline then
                    pcall(
                        function()
                            dZ.outline:Remove()
                        end
                    )
                    dZ.outline = nil
                end
                if dZ.connection then
                    dZ.connection:Disconnect()
                    dZ.connection = nil
                end
            end
            local function e0()
                if not dZ.enabled then
                    d_()
                    return
                end
                if not dZ.outline then
                    dZ.outline = Drawing.new("Line")
                    dZ.outline.Visible = false
                    dZ.outline.Color = dZ.outline_color
                    dZ.outline.Thickness = dZ.outline_thickness
                end
                if not dZ.line then
                    dZ.line = Drawing.new("Line")
                    dZ.line.Visible = false
                    dZ.line.Color = dZ.line_color
                    dZ.line.Thickness = dZ.line_thickness
                end
                if not dZ.connection then
                    local e1 = B and B.run or game:GetService("RunService")
                    local e2 = B and B.uis or game:GetService("UserInputService")
                    local e3 = workspace and workspace.CurrentCamera or game:GetService("Workspace").CurrentCamera
                    dZ.connection =
                        e1.RenderStepped:Connect(
                        function()
                            if not dZ.enabled or not targeting_state.current then
                                if dZ.line then
                                    dZ.line.Visible = false
                                end
                                if dZ.outline then
                                    dZ.outline.Visible = false
                                end
                                if dZ.beam_line then
                                    dZ.beam_line.Enabled = false
                                end
                                if dZ.beam_outline then
                                    dZ.beam_outline.Enabled = false
                                end
                                return
                            end
                            local bU = targeting_state.current
                            local a3 = bU and bU.Character
                            if not a3 then
                                if dZ.line then
                                    dZ.line.Visible = false
                                end
                                if dZ.outline then
                                    dZ.outline.Visible = false
                                end
                                return
                            end
                            local bg = a3:FindFirstChild(dZ.body_part)
                            if not bg then
                                if dZ.line then
                                    dZ.line.Visible = false
                                end
                                if dZ.outline then
                                    dZ.outline.Visible = false
                                end
                                return
                            end
                            local e4, e5 = e3:WorldToViewportPoint(bg.Position)
                            if not e5 then
                                if dZ.line then
                                    dZ.line.Visible = false
                                end
                                if dZ.outline then
                                    dZ.outline.Visible = false
                                end
                                if dZ.beam_line then
                                    dZ.beam_line.Enabled = false
                                end
                                if dZ.beam_outline then
                                    dZ.beam_outline.Enabled = false
                                end
                                return
                            end
                            local e6 = Vector2.new(e4.X, e4.Y)
                            local e7
                            if dZ.origin == "mouse" then
                                e7 = e2:GetMouseLocation()
                            elseif dZ.origin == "top" then
                                e7 = Vector2.new(e3.ViewportSize.X / 2, 0)
                            elseif dZ.origin == "bottom" then
                                e7 = Vector2.new(e3.ViewportSize.X / 2, e3.ViewportSize.Y)
                            elseif dZ.origin == "center" then
                                e7 = Vector2.new(e3.ViewportSize.X / 2, e3.ViewportSize.Y / 2)
                            end
                            if dZ.outline then
                                dZ.outline.From = e7
                                dZ.outline.To = e6
                                dZ.outline.Visible = true
                                dZ.outline.Thickness = dZ.outline_thickness
                            end
                            if dZ.line then
                                dZ.line.From = e7
                                dZ.line.To = e6
                                dZ.line.Visible = true
                                dZ.line.Thickness = dZ.line_thickness
                                dZ.line.Color = dZ.line_color
                            end
                        end
                    )
                end
            end
            local e8 =
                cx:toggle(
                {name = "Target Tracer", flag = "target_tracer", default = false, callback = function(state)
                        dZ.enabled = state
                        if state then
                            e0()
                        else
                            d_()
                        end
                    end}
            )
            e8:colorpicker(
                {name = "Outline", flag = "tt_out", default = Color3.fromRGB(0, 0, 0), callback = function(cJ)
                        dZ.outline_color = cJ
                        if dZ.outline then
                            dZ.outline.Color = cJ
                        end
                    end}
            )
            e8:colorpicker(
                {name = "Fill", flag = "tt_fill", default = Color3.fromRGB(255, 255, 255), callback = function(cJ)
                        dZ.line_color = cJ
                        if dZ.line then
                            dZ.line.Color = cJ
                        end
                    end}
            )
            local e9 = cx:dependency_box()
            e9:setup_dependencies({{e8, true}})
            e9:dropdown(
                {
                    name = "Part",
                    flag = "tt_part",
                    items = {
                        "HumanoidRootPart",
                        "Head",
                        "UpperTorso",
                        "LowerTorso",
                        "LeftUpperArm",
                        "LeftLowerArm",
                        "LeftHand",
                        "RightUpperArm",
                        "RightLowerArm",
                        "RightHand",
                        "LeftUpperLeg",
                        "LeftLowerLeg",
                        "LeftFoot",
                        "RightUpperLeg",
                        "RightLowerLeg",
                        "RightFoot"
                    },
                    default = "HumanoidRootPart",
                    callback = function(cL)
                        dZ.body_part = cL
                    end
                }
            )
            e9:dropdown(
                {
                    name = "Origin",
                    flag = "tt_origin",
                    items = {"mouse", "top", "bottom", "center"},
                    default = "mouse",
                    callback = function(cL)
                        dZ.origin = cL
                    end
                }
            )
            C:OnTargetUpdate(
                function(aD)
                    if not aD then
                        if dZ.line then
                            dZ.line.Visible = false
                        end
                        if dZ.outline then
                            dZ.outline.Visible = false
                        end
                        if dZ.beam_line then
                            dZ.beam_line.Enabled = false
                        end
                        if dZ.beam_outline then
                            dZ.beam_outline.Enabled = false
                        end
                    end
                end
            )
            table.insert(
                a.connections,
                {Disconnect = function()
                        d_()
                    end}
            )
        end
        do
            local ea = game:GetService("RunService")
            local w = game:GetService("Players")
            local LocalPlayer = w.LocalPlayer
            local e3 = workspace.CurrentCamera
            local e2 = game:GetService("UserInputService")
            local function eb(a3)
                return a3 and
                    (a3:FindFirstChild("HumanoidRootPart") or a3:FindFirstChild("Head") or
                        a3:FindFirstChild("UpperTorso") or
                        a3:FindFirstChild("Torso"))
            end
            local ec =
                ea.RenderStepped:Connect(
                function()
                    if not g then
                        return
                    end
                    if not g["Targeting_Enabled"] then
                        return
                    end
                    if g["Targeting_Mode"] ~= "Nuker" then
                        return
                    end
                    local ed = e2:GetMouseLocation()
                    local ct, cu
                    cu = math.huge
                    for bc, bp in ipairs(w:GetPlayers()) do
                        if bp ~= LocalPlayer then
                            local a3 = bp.Character
                            local bg = eb(a3)
                            if bg then
                                local ee, e5 = e3:WorldToViewportPoint(bg.Position)
                                if e5 then
                                    local br = (ed - Vector2.new(ee.X, ee.Y)).Magnitude
                                    if br < cu then
                                        cu = br
                                        ct = bp
                                    end
                                end
                            end
                        end
                    end
                    targeting_state.current = ct
                    if ct then
                        if g and g["target_highlight"] then
                            local a3 = ct.Character
                            if a3 and bZ.last_char ~= a3 then
                                ce(a3)
                            end
                        end
                    else
                        if bZ and bZ.hl then
                            c7()
                        end
                    end
                end
            )
            table.insert(a.connections, ec)
        end
    end
    do
        local ef = t:column()
        local eg, eh, ei = ef:multi_section({names = {"Aimbot", "Prediction", "Resolver"}})
        local ej, ek = ef:multi_section({names = {"Tweaks", "OnDamage"}})
        do
            local ea = game:GetService("RunService")
            local w = game:GetService("Players")
            local LocalPlayer = w.LocalPlayer
            local el, em = 0, 0.2
            local en
            local function eo()
                if en then
                    en:Disconnect()
                    en = nil
                end
            end
            local function ep()
                if en then
                    return
                end
                en =
                    ea.RenderStepped:Connect(
                    function()
                        if not (g and g["aimbot_enabled"]) then
                            return
                        end
                        local bU = targeting_state and targeting_state.current
                        if not (bU and bU.Character) then
                            return
                        end
                        local bd = bU.Character:FindFirstChild("HumanoidRootPart")
                        if not bd then
                            return
                        end
                        local eq = LocalPlayer.Character
                        if not eq then
                            return
                        end
                        local dc = eq:FindFirstChild("Head") or eq:FindFirstChild("HumanoidRootPart")
                        if not dc then
                            return
                        end
                        local co = dc.Position
                        local er = bd.Position - co
                        if er.Magnitude <= 0 then
                            return
                        end
                        local es = RaycastParams.new()
                        es.FilterType = Enum.RaycastFilterType.Blacklist
                        es.FilterDescendantsInstances = {eq, bU.Character}
                        local et = workspace:Raycast(co, er, es)
                        if et then
                            return
                        end
                        local eu = bd.AssemblyLinearVelocity or bd.Velocity or Vector3.zero
                        if eu.Y <= 15 then
                            return
                        end
                        local I = tick()
                        if I - el < em then
                            return
                        end
                        el = I
                        local ev = eq:FindFirstChildOfClass("Tool")
                        if ev then
                            pcall(
                                function()
                                    ev:Activate()
                                end
                            )
                        end
                    end
                )
                table.insert(a.connections, en)
            end
            ej:toggle(
                {name = "AutoAir", flag = "autoair_enabled", default = false, callback = function(bj)
                        if bj then
                            ep()
                        else
                            eo()
                        end
                    end}
            )
        end
        do
            local ea = game:GetService("RunService")
            local w = game:GetService("Players")
            local ew = game:GetService("ReplicatedStorage")
            local LocalPlayer = w.LocalPlayer
            local ex, em = 0, 1
            local ey
            local function ez()
                if ey then
                    ey:Disconnect()
                    ey = nil
                end
            end
            local function eA()
                if ey then
                    return
                end
                ey =
                    ea.Heartbeat:Connect(
                    function()
                        local a3 = LocalPlayer and LocalPlayer.Character
                        if not a3 then
                            return
                        end
                        local ev = a3:FindFirstChildOfClass("Tool")
                        if not ev then
                            return
                        end
                        local eB = ev:FindFirstChild("Ammo")
                        if not eB then
                            return
                        end
                        local cL = tonumber(eB.Value)
                        if not cL then
                            return
                        end
                        if cL > 0 then
                            return
                        end
                        local I = tick()
                        if I - ex < em then
                            return
                        end
                        ex = I
                        pcall(
                            function()
                                ew.MainEvent:FireServer("Reload", ev)
                            end
                        )
                    end
                )
                table.insert(a.connections, ey)
            end
            ej:toggle(
                {name = "AutoReload", flag = "autoreload_enabled", default = false, callback = function(bj)
                        if bj then
                            eA()
                        else
                            ez()
                        end
                    end}
            )
        end
        do
            local eC
            local function eD()
                if eC then
                    eC:Disconnect()
                    eC = nil
                end
            end
            local function eE()
                if eC then
                    return
                end
                eC =
                    B.run.RenderStepped:Connect(
                    function()
                        local bU = targeting_state and targeting_state.current
                        if not (bU and C:ValidateClient(bU)) then
                            return
                        end
                        local eF = i and i.Character
                        if not eF then
                            return
                        end
                        local eG = eF:FindFirstChild("HumanoidRootPart")
                        if not eG then
                            return
                        end
                        local bg = C:GetPreferredPart(bU.Character)
                        if not bg then
                            return
                        end
                        local eH = eG.Position
                        local cp = bg.Position - eH
                        cp = B.v3.new(cp.X, 0, cp.Z)
                        local eI = cp.Magnitude
                        if eI < 1e-6 then
                            return
                        end
                        local eJ = cp.Unit
                        eG.CFrame = B.cf.new(eH, eH + eJ)
                    end
                )
                table.insert(a.connections, eC)
            end
            ej:toggle(
                {name = "LookAtTarget", flag = "lookat_enabled", default = false, callback = function(bj)
                        if bj then
                            eE()
                        else
                            eD()
                        end
                    end}
            )
        end
        -- JumpCircles system start [removed here; moved to Local section]
        -- (see Local section Visuals below)
        -- JumpCircles system end
        do
            local eK = game:GetService("UserInputService")
            local ew = game:GetService("ReplicatedStorage")
            local ea = game:GetService("RunService")
            local w = game:GetService("Players")
            local LocalPlayer = w.LocalPlayer
            local eL, eM
            local el, em = 0, 0.15
            local eN, eO = 0, 1
            local function eP()
                local i = LocalPlayer
                if not i then
                    return
                end
                local eQ, eR = 0, 60
                local ec
                ec =
                    ea.Heartbeat:Connect(
                    function()
                        eQ = eQ + 1
                        if not (g and g["forcereload_enabled"] and g["forcereload_autoequip"]) then
                            if ec then
                                ec:Disconnect()
                            end
                            return
                        end
                        local a3 = i.Character
                        if not a3 then
                            if eQ >= eR and ec then
                                ec:Disconnect()
                            end
                            return
                        end
                        local aA = a3:FindFirstChildOfClass("Humanoid")
                        local eS = i:FindFirstChildOfClass("Backpack") or i:FindFirstChild("Backpack")
                        local function eT(eU)
                            if not eU then
                                return nil
                            end
                            local bP = eU:FindFirstChild("[Revolver]")
                            if bP and bP:IsA("Tool") and bP:FindFirstChild("Handle") then
                                return bP
                            end
                            return nil
                        end
                        local eV = eT(a3)
                        if eV then
                            if aA then
                                pcall(
                                    function()
                                        aA:EquipTool(eV)
                                    end
                                )
                            end
                            if ec then
                                ec:Disconnect()
                            end
                            return
                        end
                        local eW = eT(eS)
                        if eW then
                            pcall(
                                function()
                                    eW.Parent = a3
                                end
                            )
                            if aA then
                                pcall(
                                    function()
                                        aA:EquipTool(eW)
                                    end
                                )
                            end
                            if ec then
                                ec:Disconnect()
                            end
                            return
                        end
                        if eQ >= eR then
                            if ec then
                                ec:Disconnect()
                            end
                            return
                        end
                    end
                )
                table.insert(a.connections, ec)
            end
            local function eX()
                if eL then
                    eL:Disconnect()
                    eL = nil
                end
            end
            local function eY()
                if eL then
                    return
                end
                eL =
                    eK.InputBegan:Connect(
                    function(eZ, e_)
                        if e_ then
                            return
                        end
                        if eZ.UserInputType ~= Enum.UserInputType.Keyboard then
                            return
                        end
                        if eZ.KeyCode ~= Enum.KeyCode.R then
                            return
                        end
                        if eK:GetFocusedTextBox() then
                            return
                        end
                        local I = tick()
                        if I - el < em then
                            return
                        end
                        el = I
                        local f0 = {"ChangeLoadout", "[Knife]", "Slot3"}
                        pcall(
                            function()
                                ew:WaitForChild("MainEvent"):FireServer(unpack(f0))
                            end
                        )
                    end
                )
                table.insert(a.connections, eL)
            end
            local function f1()
                if eM then
                    eM:Disconnect()
                    eM = nil
                end
            end
            local function f2()
                if eM then
                    return
                end
                eM =
                    ea.Heartbeat:Connect(
                    function()
                        if not (g and g["forcereload_enabled"]) then
                            return
                        end
                        local a3 = LocalPlayer and LocalPlayer.Character
                        if not a3 then
                            return
                        end
                        local ev = a3:FindFirstChildOfClass("Tool")
                        if not ev then
                            return
                        end
                        local eB = ev:FindFirstChild("Ammo")
                        if not eB then
                            return
                        end
                        local cL = tonumber(eB.Value)
                        if not cL or cL > 0 then
                            return
                        end
                        local I = tick()
                        if I - eN < eO then
                            return
                        end
                        eN = I
                        local f0 = {"ChangeLoadout", "[Knife]", "Slot3"}
                        pcall(
                            function()
                                ew:WaitForChild("MainEvent"):FireServer(unpack(f0))
                            end
                        )
                        if g and g["forcereload_autoequip"] then
                            eP()
                        end
                    end
                )
                table.insert(a.connections, eM)
            end
            local function f3()
                if forcere_autoequip_conn then
                    forcere_autoequip_conn:Disconnect()
                    forcere_autoequip_conn = nil
                end
            end
            local function f4()
                if forcere_autoequip_conn then
                    return
                end
                forcere_autoequip_conn =
                    ea.Heartbeat:Connect(
                    function()
                        if not (g and g["forcereload_enabled"] and g["forcereload_autoequip"]) then
                            return
                        end
                        local i = LocalPlayer
                        if not i then
                            return
                        end
                        local a3 = i.Character
                        if not a3 then
                            return
                        end
                        local aA = a3:FindFirstChildOfClass("Humanoid")
                        if not aA then
                            return
                        end
                        local I = os.clock()
                        if I - (last_equip_try or 0) < 0.2 then
                            return
                        end
                        last_equip_try = I
                        local f5 = a3:FindFirstChild("[Revolver]")
                        if f5 then
                            pcall(
                                function()
                                    aA:EquipTool(f5)
                                end
                            )
                        else
                            eP()
                        end
                    end
                )
                table.insert(a.connections, forcere_autoequip_conn)
            end
            local f6 =
                ej:toggle(
                {name = "ForceReload", flag = "forcereload_enabled", default = false, callback = function(bj)
                        if bj then
                            eY()
                            if g and g["forcereload_auto"] then
                                f2()
                            end
                            if g and g["forcereload_autoequip"] then
                                f4()
                            end
                        else
                            eX()
                            f1()
                            f3()
                            if g then
                                g["forcereload_auto"] = false
                                g["forcereload_autoequip"] = false
                            end
                        end
                    end}
            )
            local f7 = ej:dependency_box()
            f7:setup_dependencies({{f6, true}})
            local f8 =
                f7:toggle(
                {name = "Auto", flag = "forcereload_auto", default = false, callback = function(bj)
                        if bj then
                            if g and g["forcereload_enabled"] then
                                f2()
                            end
                        else
                            f1()
                        end
                    end}
            )
            local f9 = ej:dependency_box()
            f9:setup_dependencies({{f6, true}, {f8, true}})
            f9:toggle(
                {name = "AutoEquip", flag = "forcereload_autoequip", default = false, callback = function(bj)
                        if g and g["forcereload_enabled"] and bj then
                            f4()
                        else
                            f3()
                        end
                    end}
            )
        end
        do
            local ea = B.run
            local w = B.ps
            local LocalPlayer = w.LocalPlayer
            local ew = game:GetService("ReplicatedStorage")
            local fa
            local fb = 0
            local fc = 0.00000000001
            local function fd(az)
                local a3 = az and az.Character
                local fe = a3 and a3:FindFirstChild("BodyEffects")
                local ff = fe and fe:FindFirstChild("K.O")
                return ff and ff.Value and true or false
            end
            local function fg(az)
                local a3 = az and az.Character
                return a3 and a3:FindFirstChildOfClass("ForceField") and true or false
            end
            local function fh()
                local a3 = LocalPlayer and LocalPlayer.Character
                if not a3 then
                    return nil
                end
                for bc, fi in ipairs(a3:GetChildren()) do
                    if fi:IsA("Tool") then
                        return fi
                    end
                end
                return nil
            end
            local function fj(az)
                if not (az and az.Character) then
                    return
                end
                local I = os.clock()
                if I - (fb or 0) < fc then
                    return
                end
                local ev = fh()
                if not ev then
                    return
                end
                local eB = ev:FindFirstChild("Ammo")
                if eB and eB.Value and eB.Value <= 0 then
                    return
                end
                local cF = ev:FindFirstChild("Handle")
                if not cF then
                    return
                end
                local dc = az.Character:FindFirstChild("Head")
                if not dc then
                    return
                end
                local fk = dc.Position
                local fl = {fk, fk, fk, fk, fk}
                local fm = {
                    Vector3.new(0, 1, 0),
                    Vector3.new(0, 1, 0),
                    Vector3.new(0, 1, 0),
                    Vector3.new(0, 1, 0),
                    Vector3.new(0, 1, 0)
                }
                local fn = {dc, dc, dc, dc, dc}
                local f0 = {"ShootGun", cF, fk, fl, fn, fm, {}, os.clock(), math.huge, fl, 5, 0.2, fk}
                local fo = ew:FindFirstChild("ShootEvent")
                if fo then
                    fb = I
                    pcall(
                        function()
                            fo:FireServer(unpack(f0))
                        end
                    )
                end
            end
            local function fp()
                if fa then
                    fa:Disconnect()
                    fa = nil
                end
            end
            local function fq()
                if fa then
                    return
                end
                fa =
                    ea.Heartbeat:Connect(
                    function()
                        if not (g and g["magicbullets_enabled"]) then
                            return
                        end
                        local bU = targeting_state and targeting_state.current
                        if not bU then
                            return
                        end
                        local dP = g and g["magicbullets_checks"]
                        local fr, fs = false, false
                        if typeof(dP) == "table" then
                            for bc, cc in ipairs(dP) do
                                if cc == "KO" then
                                    fr = true
                                end
                                if cc == "FF" then
                                    fs = true
                                end
                            end
                        end
                        if fr and fd(bU) then
                            return
                        end
                        if fs and fg(bU) then
                            return
                        end
                        fj(bU)
                    end
                )
                table.insert(a.connections, fa)
            end
            local ft =
                ej:toggle(
                {name = "MagicBullets", flag = "magicbullets_enabled", default = false, callback = function(bj)
                        if bj then
                            fq()
                        else
                            fp()
                        end
                    end}
            )
            local fu = ej:dependency_box()
            fu:setup_dependencies({{ft, true}})
            fu:label({name = "Checks"})
            fu:dropdown(
                {
                    name = "Checks",
                    flag = "magicbullets_checks",
                    items = {"KO", "FF"},
                    default = {"KO", "FF"},
                    multi = true,
                    callback = function()
                    end
                }
            )
        end
        do
            local function fv()
                local dC = {}
                local cp = (a and a.directory or "Rebuild.gg") .. "/sounds"
                local dE, dF =
                    pcall(
                    function()
                        return listfiles and listfiles(cp) or {}
                    end
                )
                if dE and type(dF) == "table" then
                    for bc, dA in ipairs(dF) do
                        local bG = dA:match("[^/\\]+$")
                        if bG then
                            table.insert(dC, bG)
                        end
                    end
                end
                table.sort(dC)
                return #dC > 0 and dC or {"ding.ogg", "bell.wav", "hit.mp3"}
            end
            function play_hitsound(fw)
                local fx = game:GetService("SoundService")
                local fy = fx:FindFirstChild("RB_HitSound")
                if not fy then
                    fy = Instance.new("Sound")
                    fy.Name = "RB_HitSound"
                    fy.Looped = false
                    fy.Parent = fx
                end
                local fz = (a and a.directory or "Rebuild.gg") .. "/sounds/" .. tostring(fw or "")
                local fA
                if getcustomasset then
                    fA = getcustomasset(fz)
                elseif getsynasset then
                    fA = getsynasset(fz)
                end
                if fA then
                    fy.SoundId = fA
                    fy.Volume = tonumber(g["hs_volume"]) or 0.5
                    local fB = tonumber(g["hs_pitch"]) or 1
                    fy.PlaybackSpeed = fB
                    pcall(
                        function()
                            fy:Play()
                        end
                    )
                end
            end
            local fC = ek:toggle({name = "Sounds", flag = "hitsound_enabled", default = false})
            local fD = ek:dependency_box()
            fD:setup_dependencies({{fC, true}})
            local fE = fD:dropdown({name = "Sound", flag = "hs_file", items = fv()})
            fD:slider({name = "Vol", flag = "hs_volume", min = 0, max = 10, default = 0.5, interval = 0.05})
            fD:slider({name = "Pitch", flag = "hs_pitch", min = 0.5, max = 2, default = 1, interval = 0.05})
            fD:toggle({name = "MuteOriginalSound", flag = "hs_mute_original", default = false})
            local fF = {Sound = {}}
            fF.Sound.TargetIds =
                fF.Sound.TargetIds or
                {"rbxassetid://6773912589", "6773912589", "http://www.roblox.com/asset/?id=6773912589"}
            function fF.Sound.MuteTargetSound(fy)
                if not fy or not fy:IsA("Sound") then
                    return false
                end
                local fG = tostring(fy.SoundId or ""):lower()
                for bc, fH in pairs(fF.Sound.TargetIds) do
                    if fG:find(tostring(fH):lower(), 1, true) then
                        if g and g["hs_mute_original"] then
                            pcall(
                                function()
                                    fy:Stop()
                                    fy.Volume = 0
                                    fy.Playing = false
                                end
                            )
                            if not fF.Sound._guarded then
                                fF.Sound._guarded = {}
                            end
                            if not fF.Sound._guarded[fy] then
                                fF.Sound._guarded[fy] =
                                    fy:GetPropertyChangedSignal("Playing"):Connect(
                                    function()
                                        if g and g["hs_mute_original"] and fy.Playing then
                                            pcall(
                                                function()
                                                    fy:Stop()
                                                    fy.Volume = 0
                                                end
                                            )
                                        end
                                    end
                                )
                            end
                            return true
                        end
                    end
                end
                return false
            end
            function fF.Sound.MuteExistingSounds()
                for bc, ci in ipairs(game:GetDescendants()) do
                    if ci:IsA("Sound") then
                        fF.Sound.MuteTargetSound(ci)
                    end
                end
            end
            task.defer(
                function()
                    fF.Sound.MuteExistingSounds()
                end
            )
            if not fF.Sound._conn then
                fF.Sound._conn =
                    game.DescendantAdded:Connect(
                    function(ci)
                        if ci:IsA("Sound") then
                            fF.Sound.MuteTargetSound(ci)
                        end
                    end
                )
            end
        end
        do
            local fI = ek:toggle({name = "Notifications", flag = "notif_enabled", default = false})
            local fJ = ek:dependency_box()
            fJ:setup_dependencies({{fI, true}})
            fJ:slider({name = "Duration", flag = "notif_duration", min = 0.5, max = 3, default = 1.5, interval = 0.1})
        end
        C:OnHit(
            function(aD)
                if g and g["hitsound_enabled"] then
                    local fw = g["hs_file"]
                    if fw and fw ~= "" then
                        play_hitsound(fw)
                    end
                end
                if g and g["hitchams_enabled"] and aD and aD.player then
                    HitChams(aD.player)
                end
                local cZ = g or a and a.flags or {}
                local bX = cZ["notif_enabled"] == true or cZ["notif_enabled"] == 1 or cZ["notif_enabled"] == "true"
                if not bX then
                    return
                end
                if aD and aD.player and aD.player.Character then
                    local a3 = aD.player.Character
                    local fK = a3:FindFirstChildOfClass("Humanoid")
                    if fK then
                        aD.health = fK.Health
                        aD.remaining_health = fK.Health
                    end
                end
                local bG = "Player"
                if aD then
                    if aD.player then
                        if typeof(aD.player) == "Instance" then
                            bG = aD.player.Name or "Player"
                        else
                            bG = tostring(aD.player)
                        end
                    elseif aD.name then
                        bG = tostring(aD.name)
                    end
                end
                local bH = 0
                if aD and aD.health then
                    local fL = tonumber(aD.health)
                    bH = fL and math.floor(fL) or 0
                end
                local fM = tostring(bG) .. " " .. tostring(bH)
                local fN = tonumber(cZ and cZ["notif_duration"] or g and g["notif_duration"]) or 1.5
                if fN <= 0 or fN > 10 or fN ~= fN then
                    fN = 1.5
                end
                if a and a.notification then
                    a:notification({text = fM, time = fN})
                end
            end
        )
        local HitChams
        do
            HitChams = function(fO)
                if not g["hitchams_enabled"] then
                    return
                end
                if fO and fO.Character and fO.Character:FindFirstChild("HumanoidRootPart") then
                    fO.Character.Archivable = true
                    local fP = fO.Character:Clone()
                    fP.Name = "Player Clone"
                    local fQ = {
                        "Head",
                        "UpperTorso",
                        "LowerTorso",
                        "LeftUpperArm",
                        "LeftLowerArm",
                        "LeftHand",
                        "RightUpperArm",
                        "RightLowerArm",
                        "RightHand",
                        "LeftUpperLeg",
                        "LeftLowerLeg",
                        "LeftFoot",
                        "RightUpperLeg",
                        "RightLowerLeg",
                        "RightFoot"
                    }
                    for bc, fR in ipairs(fP:GetChildren()) do
                        if fR:IsA("BasePart") then
                            local fS = false
                            for bc, fT in ipairs(fQ) do
                                if fR.Name == fT then
                                    fS = true
                                    break
                                end
                            end
                            if not fS then
                                fR:Destroy()
                            end
                        elseif
                            fR:IsA("Accessory") or fR:IsA("Tool") or fR.Name == "face" or fR:IsA("Shirt") or
                                fR:IsA("Pants") or
                                fR:IsA("Hat")
                         then
                            fR:Destroy()
                        end
                    end
                    if fP:FindFirstChild("Humanoid") then
                        fP.Humanoid:Destroy()
                    end
                    local fU = a and a.flags or {}
                    local fV = fU["hitchams_color"] or fU["hitcham_color"] or nil
                    local fW = fV and (fV.Color or fV) or nil
                    for bc, fX in ipairs(fP:GetChildren()) do
                        if fX:IsA("BasePart") then
                            fX.CanCollide = false
                            fX.Anchored = true
                            fX.Transparency = g["hitchams_transparency"] or 0.5
                            if fW then
                                fX.Color = fW
                            end
                            fX.Material = g["hitchams_material"] or Enum.Material.Neon
                        end
                    end
                    if fP:FindFirstChild("Head") then
                        local fY = fP.Head
                        fY.Transparency = g["hitchams_transparency"] or 0.5
                        if fW then
                            fY.Color = fW
                        end
                        fY.Material = g["hitchams_material"] or Enum.Material.Neon
                        if fY:FindFirstChild("face") then
                            fY.face:Destroy()
                        end
                    end
                    fP.Parent = game.Workspace
                    local fZ =
                        TweenInfo.new(
                        g["hitchams_duration"] or 2,
                        Enum.EasingStyle.Sine,
                        Enum.EasingDirection.InOut,
                        0,
                        true
                    )
                    for bc, fX in ipairs(fP:GetChildren()) do
                        if fX:IsA("BasePart") then
                            local f_ = game:GetService("TweenService"):Create(fX, fZ, {Transparency = 1})
                            f_:Play()
                        end
                    end
                    task.delay(
                        g["hitchams_duration"] or 2,
                        function()
                            if fP and fP.Parent then
                                fP:Destroy()
                            end
                        end
                    )
                end
            end
            local g0 = ek:toggle({name = "Chams", flag = "hitchams_enabled", default = false})
            g0:colorpicker({name = "Color", flag = "hitchams_color", default = Color3.fromRGB(255, 0, 0)})
            local g1 = ek:dependency_box()
            g1:setup_dependencies({{g0, true}})
            g1:dropdown(
                {
                    name = "Material",
                    flag = "hitchams_material",
                    items = {"Neon", "ForceField", "Glass", "Plastic", "Metal", "Concrete"},
                    default = "Neon"
                }
            )
            g1:slider({name = "Duration", flag = "hitchams_duration", min = 0.5, max = 5, default = 2, interval = 0.1})
            g1:slider({name = "Trs", flag = "hitchams_transparency", min = 0, max = 1, default = 0.5, interval = 0.05})
        end
        do
            local g2 = {}
            local R = nil
            local function g3()
                if not R or not R.Parent then
                    R = workspace:FindFirstChild("RebuildHitEffects") or Instance.new("Folder")
                    R.Name = "RebuildHitEffects"
                    R.Parent = workspace
                end
                return R
            end
            local function g4()
                local g5 = Instance.new("Attachment")
                local g6 = Instance.new("ParticleEmitter")
                g6.Name = "Foam"
                g6.LightInfluence = 0.5
                g6.Lifetime = NumberRange.new(1, 1)
                g6.SpreadAngle = Vector2.new(360, -360)
                g6.VelocitySpread = 360
                g6.Speed = NumberRange.new(20, 20)
                g6.Brightness = 2.5
                g6.Size =
                    NumberSequence.new(
                    {
                        NumberSequenceKeypoint.new(0, 0),
                        NumberSequenceKeypoint.new(0.1, 0.65),
                        NumberSequenceKeypoint.new(0.65, 1.42),
                        NumberSequenceKeypoint.new(1, 0)
                    }
                )
                g6.Enabled = false
                g6.Acceleration = Vector3.new(0, -66, 0)
                g6.Rate = 100
                g6.Texture = "rbxassetid://8297030850"
                g6.Rotation = NumberRange.new(-90, -90)
                g6.Orientation = Enum.ParticleOrientation.VelocityParallel
                g6.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
                g6.Parent = g5
                g2["Cum"] = g5
                local g7 = Instance.new("Attachment")
                local g8 = Instance.new("ParticleEmitter")
                g8.Name = "Dots 1"
                g8.LightEmission = 1
                g8.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
                g8.LockedToPart = false
                g8.ZOffset = 10
                g8.Texture = "rbxassetid://7216849075"
                g8.VelocitySpread = 360
                g8.Transparency =
                    NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0.663)})
                g8.Lifetime = NumberRange.new(1, 5)
                g8.Speed = NumberRange.new(1, 210)
                g8.SpreadAngle = Vector2.new(360, -360)
                g8.Rate = 60
                g8.Size =
                    NumberSequence.new(
                    {
                        NumberSequenceKeypoint.new(0, 0.1),
                        NumberSequenceKeypoint.new(0.428, 0),
                        NumberSequenceKeypoint.new(1, 0.627)
                    }
                )
                g8.Enabled = false
                g8.Parent = g7
                local g9 = Instance.new("ParticleEmitter")
                g9.Name = "Dots 2"
                g9.LightEmission = 1
                g9.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
                g9.LockedToPart = false
                g9.ZOffset = 10
                g9.Texture = "rbxassetid://7216849075"
                g9.VelocitySpread = 360
                g9.Transparency =
                    NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0.663)})
                g9.Lifetime = NumberRange.new(1, 5)
                g9.Speed = NumberRange.new(1, 210)
                g9.SpreadAngle = Vector2.new(360, -360)
                g9.Rate = 100
                g9.Size =
                    NumberSequence.new(
                    {
                        NumberSequenceKeypoint.new(0, 0.1),
                        NumberSequenceKeypoint.new(0.502, 1.438),
                        NumberSequenceKeypoint.new(0.925, 1.125),
                        NumberSequenceKeypoint.new(1, 0.397)
                    }
                )
                g9.Enabled = false
                g9.Orientation = Enum.ParticleOrientation.FacingCamera
                g9.Parent = g7
                g2["Particle"] = g7
                local ga = Instance.new("Attachment")
                local gb = Instance.new("ParticleEmitter")
                gb.Name = "Break2"
                gb.RotSpeed = NumberRange.new(1000)
                gb.VelocitySpread = -360
                gb.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
                gb.Rate = 1
                gb.Texture = "rbxassetid://11973936966"
                gb.Rotation = NumberRange.new(-360, 360)
                gb.Transparency =
                    NumberSequence.new(
                    {
                        NumberSequenceKeypoint.new(0, 1, 0),
                        NumberSequenceKeypoint.new(0.10972569137811661, 0.27699530124664307, 0),
                        NumberSequenceKeypoint.new(0.5, 0, 0),
                        NumberSequenceKeypoint.new(1, 1, 0)
                    }
                )
                gb.Lifetime = NumberRange.new(0.5)
                gb.Speed = NumberRange.new(0.01)
                gb.LightEmission = 0.5
                gb.SpreadAngle = Vector2.new(-360, 360)
                gb.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 6, 0), NumberSequenceKeypoint.new(1, 6, 0)})
                gb.Enabled = false
                gb.Parent = ga
                local gc = Instance.new("ParticleEmitter")
                gc.Name = "Break3"
                gc.RotSpeed = NumberRange.new(-150, 150)
                gc.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
                gc.ZOffset = 4
                gc.Rotation = NumberRange.new(-360, 360)
                gc.Texture = "rbxassetid://5726444189"
                gc.Lifetime = NumberRange.new(0.5)
                gc.Speed = NumberRange.new(0.01)
                gc.LightEmission = 1
                gc.Rate = 1
                gc.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 7, 0), NumberSequenceKeypoint.new(1, 7, 0)})
                gc.Enabled = false
                gc.Parent = ga
                local gd = Instance.new("ParticleEmitter")
                gd.Name = "Break1"
                gd.VelocitySpread = -360
                gd.Texture = "rbxassetid://12239789629"
                gd.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
                gd.LockedToPart = true
                gd.ZOffset = 3
                gd.LightEmission = 0.5
                gd.Rotation = NumberRange.new(-360, 360)
                gd.Transparency =
                    NumberSequence.new(
                    {
                        NumberSequenceKeypoint.new(0, 1, 0),
                        NumberSequenceKeypoint.new(0.5, 0, 0),
                        NumberSequenceKeypoint.new(1, 1, 0)
                    }
                )
                gd.Lifetime = NumberRange.new(0.5)
                gd.Speed = NumberRange.new(0.01)
                gd.SpreadAngle = Vector2.new(-360, 360)
                gd.Rate = 1
                gd.Size =
                    NumberSequence.new({NumberSequenceKeypoint.new(0, 10, 0), NumberSequenceKeypoint.new(1, 10, 0)})
                gd.Enabled = false
                gd.Parent = ga
                g2["Break"] = ga
            end
            local function ge(cc)
                if typeof(cc) == "Color3" then
                    return cc
                end
                if typeof(cc) == "table" then
                    local gf = cc.Color or cc.color or cc.Value or cc.value
                    if gf and typeof(gf) == "Color3" then
                        return gf
                    end
                    local gg, gh, cO = cc.r or cc.R or cc[1], cc.g or cc.G or cc[2], cc.b or cc.B or cc[3]
                    if gg and gh and cO then
                        if gg <= 1 and gh <= 1 and cO <= 1 then
                            return Color3.new(gg, gh, cO)
                        else
                            return Color3.fromRGB(gg, gh, cO)
                        end
                    end
                end
                if typeof(cc) == "string" then
                    local c = cc:match("#?([%da-fA-F]+)")
                    if c and #c == 6 then
                        local gg = tonumber(c:sub(1, 2), 16)
                        local gh = tonumber(c:sub(3, 4), 16)
                        local cO = tonumber(c:sub(5, 6), 16)
                        if gg and gh and cO then
                            return Color3.fromRGB(gg, gh, cO)
                        end
                    end
                end
                return Color3.fromRGB(255, 0, 0)
            end
            function HitEffect(bU, gi)
                if not bU or not bU.Character then
                    return
                end
                local bd = bU.Character:FindFirstChild("HumanoidRootPart")
                if not bd then
                    return
                end
                if not next(g2) then
                    g4()
                end
                local gj = g2[gi]
                if not gj then
                    return
                end
                local gk = gj:Clone()
                local fU = a and a.flags or {}
                local cJ = ge(fU["hiteffects_color"] or fU["hiteffect_color"] or Color3.fromRGB(255, 255, 255))
                for bc, ci in pairs(gk:GetDescendants()) do
                    if ci:IsA("ParticleEmitter") then
                        ci.Color = ColorSequence.new(cJ)
                    elseif ci:IsA("Trail") then
                        ci.Color = ColorSequence.new(cJ)
                    elseif ci:IsA("Beam") then
                        ci.Color = ColorSequence.new(cJ)
                    end
                end
                gk.Parent = bd
                for bc, ci in pairs(gk:GetDescendants()) do
                    if ci:IsA("ParticleEmitter") then
                        ci:Emit(ci.Rate or 100)
                    end
                end
                task.delay(
                    2,
                    function()
                        if gk and gk.Parent then
                            gk:Destroy()
                        end
                    end
                )
            end
            _G.HitEffect = HitEffect
            local gl = ek:toggle({name = "Effects", flag = "hiteffect_enabled", default = false})
            gl:colorpicker({name = "Color", flag = "hiteffects_color", default = Color3.fromRGB(255, 255, 255)})
            local gm = ek:dependency_box()
            gm:setup_dependencies({{gl, true}})
            gm:dropdown({name = "Type", flag = "hiteffect_type", items = {"Cum", "Particle", "Break"}, default = "Cum"})
        end
        do
            local gn = nil
            local go = nil
            local gp = 0
            local gq = 0.1
            local gr = 0.5
            local function gs()
                local bU = targeting_state and targeting_state.current
                if not bU or not bU.Character then
                    gn = nil
                    go = nil
                    return
                end
                local fK = bU.Character:FindFirstChildOfClass("Humanoid")
                if not fK then
                    gn = nil
                    return
                end
                if go ~= bU then
                    gn = fK.Health
                    go = bU
                    gp = 0
                    return
                end
                local gt = fK.Health
                local gu = tick()
                if gn and gt < gn then
                    local gv = gn - gt
                    if gv >= gr and gu - gp >= gq then
                        gp = gu
                        if g and g["hitchams_enabled"] then
                            HitChams(bU)
                        end
                        if g and g["hiteffect_enabled"] then
                            local gi = g["hiteffect_type"] or "Cum"
                            if _G.HitEffect then
                                _G.HitEffect(bU, gi)
                            end
                        end
                        if g and g["hitsound_enabled"] then
                            local fw = g["hs_file"]
                            if fw and fw ~= "" then
                                play_hitsound(fw)
                            end
                        end
                        local bX = g and g["notif_enabled"]
                        if bX then
                            local bG = bU.Name or "Player"
                            local bH = math.floor(math.max(gt, 0))
                            local fM = tostring(bG) .. " " .. tostring(bH)
                            local fN = tonumber(g["notif_duration"]) or 1.5
                            if fN <= 0 or fN > 10 or fN ~= fN then
                                fN = 1.5
                            end
                            if a and a.notification then
                                a:notification({text = fM, time = fN})
                            end
                        end
                    end
                end
                gn = gt
            end
            B.run.Stepped:Connect(
                function()
                    gs()
                end
            )
        end
        local gw = eg:toggle({name = "Enabled", flag = "aimbot_enabled", default = false})
        local gx = eg:dependency_box()
        gx:setup_dependencies({{gw, true}})
        gx:dropdown(
            {
                name = "Part",
                flag = "aimbot_part",
                items = {
                    "HumanoidRootPart",
                    "Head",
                    "UpperTorso",
                    "LowerTorso",
                    "LeftUpperArm",
                    "LeftLowerArm",
                    "LeftHand",
                    "RightUpperArm",
                    "RightLowerArm",
                    "RightHand",
                    "LeftUpperLeg",
                    "LeftLowerLeg",
                    "LeftFoot",
                    "RightUpperLeg",
                    "RightLowerLeg",
                    "RightFoot"
                },
                default = "HumanoidRootPart"
            }
        )
        local gy = eh:toggle({name = "Enabled", flag = "pred_enabled", default = false})
        local gz = eh:dependency_box()
        gz:setup_dependencies({{gy, true}})
        local gA =
            gz:dropdown({name = "Prediction Mode", flag = "pred_mode", items = {"Sets", "Auto"}, default = "Auto"})
        local gB = eh:dependency_box()
        gB:setup_dependencies({{gy, true}, {gA, "Sets"}})
        gB:label({name = "PredictionX"})
        gB:textbox({flag = "pred_x", default = "0"})
        gB:label({name = "PredictionY"})
        gB:textbox({flag = "pred_y", default = "0"})
        gB:label({name = "PredictionZ"})
        gB:textbox({flag = "pred_z", default = "0"})
        eh:toggle({name = "ShowPrediction", flag = "show_prediction", default = false}):colorpicker(
            {name = "Color", flag = "prediction_color", default = c("#ffffff")}
        )
        local gC = ei:toggle({name = "Enabled", flag = "resolver_enabled", default = false})
        local gD = ei:dependency_box()
        gD:setup_dependencies({{gC, true}})
        gD:dropdown(
            {
                name = "Resolver Mode",
                flag = "resolver_mode",
                items = {"Velocity", "Recalculate", "MoveDirection", "LookVector", "CalculateCFrame"},
                default = "Velocity"
            }
        )
    end
    do
        local gE = {"HumanoidRootPart", "Head", "UpperTorso", "Torso"}
        local gF = {
            {20, 0.08960952},
            {21, 0.091171428},
            {22, 0.092733336},
            {23, 0.094295244},
            {24, 0.095857152},
            {25, 0.09741906},
            {26, 0.098980968},
            {27, 0.100542876},
            {28, 0.102104784},
            {29, 0.103666692},
            {30, 0.11252476},
            {31, 0.112978758},
            {32, 0.113432756},
            {33, 0.113886754},
            {34, 0.114340752},
            {35, 0.11479475},
            {36, 0.115248748},
            {37, 0.115702746},
            {38, 0.116156744},
            {39, 0.116610742},
            {40, 0.11706474},
            {41, 0.117518738},
            {42, 0.117972736},
            {43, 0.118426734},
            {44, 0.118880732},
            {45, 0.11933473},
            {46, 0.119788728},
            {47, 0.120242726},
            {48, 0.120696724},
            {49, 0.121150722},
            {50, 0.13544},
            {51, 0.1348236},
            {52, 0.1342072},
            {53, 0.1335908},
            {54, 0.1329744},
            {55, 0.132358},
            {56, 0.1317416},
            {57, 0.1311252},
            {58, 0.1305088},
            {59, 0.1298924},
            {60, 0.129276},
            {61, 0.1286596},
            {62, 0.1280432},
            {63, 0.1274268},
            {64, 0.1268104},
            {65, 0.1264236},
            {66, 0.1262627},
            {67, 0.1261018},
            {68, 0.1259409},
            {69, 0.12578},
            {70, 0.12533},
            {71, 0.125474},
            {72, 0.125618},
            {73, 0.125762},
            {74, 0.125906},
            {75, 0.12605},
            {76, 0.126194},
            {77, 0.126338},
            {78, 0.126482},
            {79, 0.126626},
            {80, 0.13934},
            {81, 0.1395937},
            {82, 0.1398474},
            {83, 0.1401011},
            {84, 0.1403548},
            {85, 0.1406085},
            {86, 0.1408622},
            {87, 0.1411159},
            {88, 0.1413696},
            {89, 0.1416233},
            {90, 0.141877},
            {91, 0.1421307},
            {92, 0.1423844},
            {93, 0.1426381},
            {94, 0.1428918},
            {95, 0.1431455},
            {96, 0.1433992},
            {97, 0.1436529},
            {98, 0.1439066},
            {99, 0.1441603},
            {100, 0.141987},
            {101, 0.1423107},
            {102, 0.1426344},
            {103, 0.1429581},
            {104, 0.1432818},
            {105, 0.1436055},
            {106, 0.1439292},
            {107, 0.1442529},
            {108, 0.1445766},
            {109, 0.1449003},
            {110, 0.144634},
            {111, 0.1449577},
            {112, 0.1452814},
            {113, 0.1456051},
            {114, 0.1459288},
            {115, 0.1462525},
            {116, 0.1465762},
            {117, 0.1468999},
            {118, 0.1472236},
            {119, 0.1475473},
            {120, 0.147281},
            {121, 0.1476047},
            {122, 0.1479284},
            {123, 0.1482521},
            {124, 0.1485758},
            {125, 0.1488995},
            {126, 0.1492232},
            {127, 0.1495469},
            {128, 0.1498706},
            {129, 0.1501943},
            {130, 0.149928},
            {131, 0.1502517},
            {132, 0.1505754},
            {133, 0.1508991},
            {134, 0.1512228},
            {135, 0.1515465},
            {136, 0.1518702},
            {137, 0.1521939},
            {138, 0.1525176},
            {139, 0.1528413},
            {140, 0.152575},
            {141, 0.1528987},
            {142, 0.1532224},
            {143, 0.1535461},
            {144, 0.1538698},
            {145, 0.1541935},
            {146, 0.1545172},
            {147, 0.1548409},
            {148, 0.1551646},
            {149, 0.1554883},
            {150, 0.155222},
            {151, 0.1555457},
            {152, 0.1558694},
            {153, 0.1561931},
            {154, 0.1565168},
            {155, 0.1568405},
            {156, 0.1571642},
            {157, 0.1574879},
            {158, 0.1578116},
            {159, 0.1581353},
            {160, 0.157869},
            {161, 0.1581927},
            {162, 0.1585164},
            {163, 0.1588401},
            {164, 0.1591638},
            {165, 0.1594875},
            {166, 0.1598112},
            {167, 0.1601349},
            {168, 0.1604586},
            {169, 0.1607823},
            {170, 0.160516},
            {171, 0.1608397},
            {172, 0.1611634},
            {173, 0.1614871},
            {174, 0.1618108},
            {175, 0.1621345},
            {176, 0.1624582},
            {177, 0.1627819},
            {178, 0.1631056},
            {179, 0.1634293},
            {180, 0.163163},
            {181, 0.1634867},
            {182, 0.1638104},
            {183, 0.1641341},
            {184, 0.1644578},
            {185, 0.1647815},
            {186, 0.1651052},
            {187, 0.1654289},
            {188, 0.1657526},
            {189, 0.1660763},
            {190, 0.16581},
            {191, 0.1661337},
            {192, 0.1664574},
            {193, 0.1667811},
            {194, 0.1671048},
            {195, 0.1674285},
            {196, 0.1677522},
            {197, 0.1680759},
            {198, 0.1683996},
            {199, 0.1687233},
            {200, 0.168457},
            {201, 0.1687807},
            {202, 0.1691044},
            {203, 0.1694281},
            {204, 0.1697518},
            {205, 0.1700755},
            {206, 0.1703992},
            {207, 0.1707229},
            {208, 0.1710466},
            {209, 0.1713703},
            {210, 0.171104},
            {211, 0.1714277},
            {212, 0.1717514},
            {213, 0.1720751},
            {214, 0.1723988},
            {215, 0.1727225},
            {216, 0.1730462},
            {217, 0.1733699},
            {218, 0.1736936},
            {219, 0.1740173},
            {220, 0.173751},
            {221, 0.1740747},
            {222, 0.1743984},
            {223, 0.1747221},
            {224, 0.1750458},
            {225, 0.1753695},
            {226, 0.1756932},
            {227, 0.1760169},
            {228, 0.1763406},
            {229, 0.1766643},
            {230, 0.176398},
            {231, 0.1767217},
            {232, 0.1770454},
            {233, 0.1773691},
            {234, 0.1776928},
            {235, 0.1780165},
            {236, 0.1783402},
            {237, 0.1786639},
            {238, 0.1789876},
            {239, 0.1793113},
            {240, 0.179045},
            {241, 0.1793687},
            {242, 0.1796924},
            {243, 0.1800161},
            {244, 0.1803398},
            {245, 0.1806635},
            {246, 0.1809872},
            {247, 0.1813109},
            {248, 0.1816346},
            {249, 0.1819583},
            {250, 0.181692},
            {251, 0.1820157},
            {252, 0.1823394},
            {253, 0.1826631},
            {254, 0.1829868},
            {255, 0.1833105},
            {256, 0.1836342},
            {257, 0.1839579},
            {258, 0.1842816},
            {259, 0.1846053},
            {260, 0.184339},
            {261, 0.1846627},
            {262, 0.1849864},
            {263, 0.1853101},
            {264, 0.1856338},
            {265, 0.1859575},
            {266, 0.1862812},
            {267, 0.1866049},
            {268, 0.1869286},
            {269, 0.1872523},
            {270, 0.186986},
            {271, 0.1873097},
            {272, 0.1876334},
            {273, 0.1879571},
            {274, 0.1882808},
            {275, 0.1886045},
            {276, 0.1889282},
            {277, 0.1892519},
            {278, 0.1895756},
            {279, 0.1898993},
            {280, 0.189633},
            {281, 0.1899567},
            {282, 0.1902804},
            {283, 0.1906041},
            {284, 0.1909278},
            {285, 0.1912515},
            {286, 0.1915752},
            {287, 0.1918989},
            {288, 0.1922226},
            {289, 0.1925463},
            {290, 0.19228},
            {291, 0.1926037},
            {292, 0.1929274},
            {293, 0.1932511},
            {294, 0.1935748},
            {295, 0.1938985},
            {296, 0.1942222},
            {297, 0.1945459},
            {298, 0.1948696},
            {299, 0.1951933},
            {300, 0.194927}
        }
        local function gG()
            local gH = game:GetService("Stats")
            local gI
            local dE, bc =
                pcall(
                function()
                    local gJ = gH.Network.ServerStatsItem["Data Ping"]:GetValueString()
                    gI = tonumber((gJ or ""):match("%d+"))
                end
            )
            if not dE or not gI then
                return 0
            end
            local gK, gL
            for bc, d3 in ipairs(gF) do
                local gM = math.abs(gI - d3[1])
                if not gL or gM < gL then
                    gL = gM
                    gK = d3[2]
                end
            end
            return gK or 0
        end
        local function dO(az)
            if not az or not az.Character then
                return nil
            end
            local a3 = az.Character
            local dP = g and g["aimbot_part"]
            if dP and a3:FindFirstChild(dP) then
                return a3[dP]
            end
            for bc, bG in ipairs(gE) do
                local b9 = a3:FindFirstChild(bG)
                if b9 then
                    return b9
                end
            end
            return nil
        end
        local gN = {lastPos = nil, lastTick = nil, lastPart = nil}
        local function gO(bg)
            if not bg then
                return nil
            end
            local bh = bg.Position
            if g["pred_enabled"] then
                local eu
                local gP = g["resolver_enabled"]
                local gQ = g["resolver_mode"]
                if gP and gQ and gQ ~= "Velocity" then
                    if gQ == "Recalculate" or gQ == "CalculateCFrame" then
                        if gN.lastPart ~= bg then
                            gN.lastPos, gN.lastTick, gN.lastPart = bg.Position, tick(), bg
                        end
                        local I = tick()
                        local dU = gN.lastTick and I - gN.lastTick or 0
                        if dU > 0 and gN.lastPos then
                            eu = (bg.Position - gN.lastPos) / dU
                        else
                            eu = bg.AssemblyLinearVelocity or bg.Velocity or Vector3.zero
                        end
                        gN.lastPos, gN.lastTick = bg.Position, I
                    elseif gQ == "MoveDirection" then
                        local fK = bg.Parent and bg.Parent:FindFirstChildOfClass("Humanoid")
                        if fK then
                            eu = fK.MoveDirection * (fK.WalkSpeed or 16)
                        end
                    elseif gQ == "LookVector" then
                        local fK = bg.Parent and bg.Parent:FindFirstChildOfClass("Humanoid")
                        local cV = fK and fK.WalkSpeed or 16
                        eu = bg.CFrame.LookVector * cV * 1.5
                    end
                end
                eu = eu or bg.AssemblyLinearVelocity or bg.Velocity or Vector3.zero
                local gR = g["pred_mode"]
                if gR == "Auto" then
                    local gJ = gG()
                    bh = bh + eu * Vector3.new(gJ, gJ, gJ)
                else
                    local gS = tonumber(g["pred_x"]) or 0
                    local gT = tonumber(g["pred_y"]) or 0
                    local gU = tonumber(g["pred_z"]) or 0
                    bh = bh + eu * Vector3.new(gS, gT, gU)
                end
            end
            return bh
        end
        local gV = getrawmetatable(game)
        local bR = gV.__index
        setreadonly(gV, false)
        gV.__index =
            newcclosure(
            function(self, bS)
                if
                    not checkcaller() and bS and (bS == "Hit" or bS == "Silent" or bS == "Target") and g and
                        g["aimbot_enabled"]
                 then
                    local az = targeting_state.current
                    local bg = dO(az)
                    if bg then
                        local gW = gO(bg) or bg.Position
                        if bS == "Hit" then
                            return CFrame.new(gW)
                        elseif bS == "Silent" or bS == "Target" then
                            return bg
                        end
                    end
                end
                return bR(self, bS)
            end
        )
        setreadonly(gV, true)
    end
    do
        local Drawing = Drawing
        local eK = game:GetService("UserInputService")
        local ea = game:GetService("RunService")
        local e3 = workspace.CurrentCamera
        do
            local gX = getgenv().PredictionTracer
            if gX and gX.cleanup then
                pcall(gX.cleanup)
            end
        end
        local gY = {}
        getgenv().PredictionTracer = gY
        local gZ = Drawing.new("Line")
        gZ.Visible = false
        gZ.Thickness = 6
        gZ.Transparency = 0.7
        gZ.Color = Color3.fromRGB(0, 0, 0)
        gY.tracerOutline = gZ
        local g_ = Drawing.new("Line")
        g_.Visible = false
        g_.Thickness = 1.5
        g_.Transparency = 1
        gY.tracer = g_
        local h0 = 4
        local h1 = Drawing.new("Circle")
        h1.Visible = false
        h1.Filled = false
        h1.Color = Color3.fromRGB(0, 0, 0)
        h1.Transparency = 0.8
        h1.Radius = 4
        gY.startOutline = h1
        local h2 = Drawing.new("Circle")
        h2.Visible = false
        h2.Filled = true
        h2.Color = Color3.fromRGB(255, 255, 255)
        h2.Transparency = 1
        h2.Radius = 2
        gY.startCircle = h2
        local h3 = Drawing.new("Circle")
        h3.Visible = false
        h3.Filled = false
        h3.Color = Color3.fromRGB(0, 0, 0)
        h3.Transparency = 0.8
        h3.Radius = 4
        gY.endOutline = h3
        local h4 = Drawing.new("Circle")
        h4.Visible = false
        h4.Filled = true
        h4.Color = Color3.fromRGB(255, 255, 255)
        h4.Transparency = 1
        h4.Radius = 2
        gY.endCircle = h4
        local gE = {"HumanoidRootPart", "Head", "UpperTorso", "Torso"}
        local gF = {
            {20, 0.08960952},
            {30, 0.11252476},
            {50, 0.13544},
            {65, 0.1264236},
            {70, 0.12533},
            {80, 0.13934},
            {100, 0.141987},
            {110, 0.144634},
            {120, 0.147281},
            {130, 0.149928},
            {140, 0.152575},
            {150, 0.155222},
            {160, 0.157869},
            {170, 0.160516},
            {180, 0.163163},
            {190, 0.16581},
            {200, 0.168457},
            {210, 0.171104},
            {220, 0.173751},
            {230, 0.176398},
            {240, 0.179045},
            {250, 0.181692},
            {260, 0.184339},
            {270, 0.186986},
            {280, 0.189633},
            {290, 0.19228},
            {300, 0.194927}
        }
        local h5 = {t = 0, val = 0}
        local function gG()
            local I = tick and tick() or os.clock()
            if I - (h5.t or 0) < 0.25 then
                return h5.val or 0
            end
            local gH = game:GetService("Stats")
            local gI
            local dE, bc =
                pcall(
                function()
                    local gJ = gH.Network.ServerStatsItem["Data Ping"]:GetValueString()
                    gI = tonumber((gJ or ""):match("%d+"))
                end
            )
            if not dE or not gI then
                return h5.val or 0
            end
            local gK, gL
            for bc, d3 in ipairs(gF) do
                local gM = math.abs(gI - d3[1])
                if not gL or gM < gL then
                    gL = gM
                    gK = d3[2]
                end
            end
            h5.t = I
            h5.val = gK or h5.val or 0
            return h5.val or 0
        end
        local function dO(az)
            if not az or not az.Character then
                return nil
            end
            local a3 = az.Character
            local dP = g and g["aimbot_part"]
            if dP and a3:FindFirstChild(dP) then
                return a3[dP]
            end
            for bc, bG in ipairs(gE) do
                local b9 = a3:FindFirstChild(bG)
                if b9 then
                    return b9
                end
            end
            return nil
        end
        local function gO(bg)
            if not bg then
                return nil
            end
            local bh = bg.Position
            if g["pred_enabled"] then
                local eu = bg.AssemblyLinearVelocity or bg.Velocity or Vector3.zero
                local gR = g["pred_mode"]
                if gR == "Auto" then
                    local gJ = gG()
                    bh = bh + eu * Vector3.new(gJ, gJ, gJ)
                else
                    local gS = tonumber(g["pred_x"]) or 0
                    local gT = tonumber(g["pred_y"]) or 0
                    local gU = tonumber(g["pred_z"]) or 0
                    bh = bh + eu * Vector3.new(gS, gT, gU)
                end
            end
            return bh
        end
        local ec =
            ea.Heartbeat:Connect( -- 60 fps
            function()
                if g["show_prediction"] and targeting_state.current then
                    local bg = dO(targeting_state.current)
                    if bg then
                        local gW = gO(bg)
                        if gW then
                            local e4, e5 = e3:WorldToViewportPoint(gW)
                            if e5 then
                                local h6 = eK:GetMouseLocation()
                                gZ.From = h6
                                gZ.To = Vector2.new(e4.X, e4.Y)
                                gZ.Thickness = math.max(1, (g_.Thickness or 2) + 2)
                                if not gZ.Visible then
                                    gZ.Visible = true
                                end
                                g_.From = h6
                                g_.To = Vector2.new(e4.X, e4.Y)
                                local h7 =
                                    g["prediction_color"] and g["prediction_color"].Color or
                                    Color3.fromRGB(255, 255, 255)
                                if g_.Color ~= h7 then
                                    g_.Color = h7
                                end
                                if not g_.Visible then
                                    g_.Visible = true
                                end
                                local h8 = g_.Color
                                local h9 = Vector2.new(e4.X, e4.Y)
                                h2.Position = h6
                                h2.Radius = math.max(1, h0 * 0.25)
                                if h2.Color ~= h8 then
                                    h2.Color = h8
                                end
                                if not h2.Visible then
                                    h2.Visible = true
                                end
                                h4.Position = h9
                                h4.Radius = math.max(1, h0 * 0.5)
                                if h4.Color ~= h8 then
                                    h4.Color = h8
                                end
                                if not h4.Visible then
                                    h4.Visible = true
                                end
                                local ha = math.max(1, (g_.Thickness or 2) + 2)
                                h1.Position = h6
                                h1.Thickness = ha
                                h1.Radius = h2.Radius + ha / 2
                                if not h1.Visible then
                                    h1.Visible = true
                                end
                                h3.Position = h9
                                h3.Thickness = ha
                                h3.Radius = h4.Radius + ha / 2
                                if not h3.Visible then
                                    h3.Visible = true
                                end
                            else
                                if g_.Visible then
                                    g_.Visible = false
                                end
                                if gZ.Visible then
                                    gZ.Visible = false
                                end
                                if h2.Visible then
                                    h2.Visible = false
                                end
                                if h4.Visible then
                                    h4.Visible = false
                                end
                                if h1.Visible then
                                    h1.Visible = false
                                end
                                if h3.Visible then
                                    h3.Visible = false
                                end
                            end
                        else
                            if g_.Visible then
                                g_.Visible = false
                            end
                            if gZ.Visible then
                                gZ.Visible = false
                            end
                            if h2.Visible then
                                h2.Visible = false
                            end
                            if h4.Visible then
                                h4.Visible = false
                            end
                            if h1.Visible then
                                h1.Visible = false
                            end
                            if h3.Visible then
                                h3.Visible = false
                            end
                        end
                    else
                        if g_.Visible then
                            g_.Visible = false
                        end
                        if gZ.Visible then
                            gZ.Visible = false
                        end
                        if h2.Visible then
                            h2.Visible = false
                        end
                        if h4.Visible then
                            h4.Visible = false
                        end
                        if h1.Visible then
                            h1.Visible = false
                        end
                        if h3.Visible then
                            h3.Visible = false
                        end
                    end
                else
                    if g_.Visible then
                        g_.Visible = false
                    end
                    if gZ.Visible then
                        gZ.Visible = false
                    end
                    if h2.Visible then
                        h2.Visible = false
                    end
                    if h4.Visible then
                        h4.Visible = false
                    end
                    if h1.Visible then
                        h1.Visible = false
                    end
                    if h3.Visible then
                        h3.Visible = false
                    end
                end
            end
        )
        table.insert(a.connections, ec)
        gY.conn = ec
        gY.cleanup = function()
            pcall(
                function()
                    if gY.conn then
                        gY.conn:Disconnect()
                    end
                end
            )
            local function hb(ci)
                if ci and ci.Remove then
                    pcall(
                        function()
                            ci:Remove()
                        end
                    )
                end
            end
            hb(gY.tracer)
            hb(gY.tracerOutline)
            hb(gY.startCircle)
            hb(gY.startOutline)
            hb(gY.endCircle)
            hb(gY.endOutline)
            getgenv().PredictionTracer = nil
        end
    end
    do
        local B = {
            rs = game:GetService("RunService"),
            uis = game:GetService("UserInputService"),
            camera = workspace.CurrentCamera
        }
        local dZ = {
            line = nil,
            line_outline = nil,
            enabled = false,
            part = "HumanoidRootPart",
            origin = "mouse",
            connection = nil
        }
        local hc = {
            "Head",
            "UpperTorso",
            "LowerTorso",
            "HumanoidRootPart",
            "LeftUpperArm",
            "LeftLowerArm",
            "LeftHand",
            "RightUpperArm",
            "RightLowerArm",
            "RightHand",
            "LeftUpperLeg",
            "LeftLowerLeg",
            "LeftFoot",
            "RightUpperLeg",
            "RightLowerLeg",
            "RightFoot"
        }
    end
    getgenv().load_config = function(bG)
        a:load_config(readfile(a.directory .. "/configs/" .. bG .. ".cfg"))
    end
    local hd = x:column()
    local he = hd:section({name = "Options"})
    local hf = a:get_config()
    config_holder = he:list({flag = "config_name_list"})
    he:textbox({flag = "config_name_text_box"})
    he:button_holder({})
    he:button(
        {name = "Create", callback = function()
                writefile(a.directory .. "/configs/" .. g["config_name_text_box"] .. ".cfg", a:get_config())
                a:config_list_update()
            end}
    )
    he:button(
        {name = "Delete", callback = function()
                delfile(a.directory .. "/configs/" .. g["config_name_list"] .. ".cfg")
                a:config_list_update()
            end}
    )
    he:button_holder({})
    he:button(
        {name = "Load", callback = function()
                a:load_config(readfile(a.directory .. "/configs/" .. g["config_name_list"] .. ".cfg"))
                a:notification({text = "Loaded Config: " .. g["config_name_list"], time = 3})
            end}
    )
    he:button(
        {name = "Save", callback = function()
                writefile(a.directory .. "/configs/" .. g["config_name_list"] .. ".cfg", a:get_config())
                a:config_list_update()
                a:notification({text = "Saved Config: " .. g["config_name_list"], time = 3})
            end}
    )
    he:button_holder({})
    he:button(
        {name = "Refresh Configs", callback = function()
                a:config_list_update()
            end}
    )
    he:button_holder({})
    he:button(
        {name = "Unload Config", callback = function()
                a:load_config(hf)
            end}
    )
    he:button(
        {name = "Unload Menu", callback = function()
                a:load_config(hf)
                for bc, hg in a.guis do
                    hg:Destroy()
                end
                for bc, hh in a.connections do
                    hh:Disconnect()
                end
            end}
    )
    local hi, hj, hk = x:column():multi_section({names = {"Theme", "Game", "HUD"}})
    hi:label({name = "Accent"}):colorpicker(
        {name = "Accent", color = c("#ffffff"), flag = "accent", callback = function(cJ, hl)
                a:update_theme("accent", cJ)
            end}
    )
    hi:label({name = "Contrast"}):colorpicker(
        {name = "Low", color = c("#2d2d2d"), flag = "low_contrast", callback = function(cJ)
                if g["high_contrast"] and g["low_contrast"] then
                    a:update_theme("contrast", d({e(0, g["low_contrast"].Color), e(1, g["high_contrast"].Color)}))
                end
            end}
    ):colorpicker(
        {name = "High", color = c("#101010"), flag = "high_contrast", callback = function(cJ)
                a:update_theme("contrast", d({e(0, g["low_contrast"].Color), e(1, g["high_contrast"].Color)}))
            end}
    )
    hi:label({name = "Inline"}):colorpicker(
        {name = "Inline", color = c("#313131"), flag = "theme_inline", callback = function(cJ, hl)
                a:update_theme("inline", cJ)
            end}
    )
    hi:label({name = "Outline"}):colorpicker(
        {name = "Outline", color = c("#000000"), flag = "theme_outline", callback = function(cJ, hl)
                a:update_theme("outline", cJ)
            end}
    )
    hi:label({name = "Text Color"}):colorpicker(
        {name = "Main", color = c("#7b7b7b"), flag = "theme_text", callback = function(cJ, hl)
                a:update_theme("text", cJ)
            end}
    ):colorpicker(
        {name = "Outline", color = c("#282828"), flag = "theme_text_outline", callback = function(cJ, hl)
                a:update_theme("text_outline", cJ)
            end}
    )
    hi:label({name = "Glow"}):colorpicker(
        {name = "Glow", color = c("#ffffff"), flag = "theme_glow", callback = function(cJ, hl)
                a:update_theme("glow", cJ)
            end}
    )
    hk:label({name = "UI Bind"}):keybind({callback = s.set_menu_visibility, key = Enum.KeyCode.Insert})
    hk:toggle(
        {name = "Keybind List", flag = "keybind_list", callback = function(hm)
                a.keybind_list_frame.Visible = hm
            end}
    )
    hk:toggle(
        {name = "CustomUI", flag = "custom_hud_enabled", callback = function(hm)
                A.set_visible(hm)
            end}
    ):colorpicker(
        {name = "Health", flag = "hud_health_color", color = A.colors.health_bar, callback = function(cJ)
                A.colors.health_bar = cJ
                A.update_bar_colors()
            end}
    ):colorpicker(
        {name = "Armor", flag = "hud_armor_color", color = A.colors.armor_bar, callback = function(cJ)
                A.colors.armor_bar = cJ
                A.update_bar_colors()
            end}
    ):colorpicker(
        {name = "Text", flag = "hud_text_color", color = A.colors.text, callback = function(cJ)
                A.colors.text = cJ
                A.update_bar_colors()
            end}
    )
    local hn
    local function ho()
        local hp = g["watermark_type"]
        local hq = {}
        local function hr()
            if hn ~= nil then
                return hn
            end
            local dE, aD =
                pcall(
                function()
                    return game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId)
                end
            )
            local bG = dE and aD and aD.Name or tostring(game.PlaceId)
            hn = bG
            return bG
        end
        if type(hp) == "table" then
            local dP = {}
            for bc, bS in next, hp do
                dP[bS] = true
            end
            if dP["Date"] then
                hq[#hq + 1] = os.date("%y:%m:%d")
            end
            if dP["Time"] then
                hq[#hq + 1] = os.date("%H:%M:%S")
            end
            if dP["Place"] then
                hq[#hq + 1] = hr()
            end
            if dP["User"] then
                hq[#hq + 1] = i and i.Name or "?"
            end
        end
        if #hq == 0 then
            hq[1] = os.date("%H:%M:%S")
        end
        return "Rebuild.gg - " .. table.concat(hq, " - ")
    end
    local hs =
        hk:toggle(
        {name = "Watermark", flag = "watermark", callback = function(hm)
                y.set_visible(hm)
                if hm then
                    y.change_text(ho())
                end
            end}
    )
    local ht = hk:dependency_box()
    ht:setup_dependencies({{hs, true}})
    ht:dropdown(
        {
            name = "Type",
            flag = "watermark_type",
            items = {"Time", "Date", "Place", "User"},
            multi = true,
            default = {"Time"},
            callback = function(dP)
                y.change_text(ho())
            end
        }
    )
    local hu =
        hk:toggle(
        {name = "Radar", flag = "hud_radar", callback = function(hm)
                z.set_visible(hm)
            end}
    )
    local hv = hk:dependency_box()
    hv:setup_dependencies({{hu, true}})
    hv:slider(
        {name = "Zoom", flag = "radar_zoom", min = 0.1, max = 2, default = 1, interval = 0.1, callback = function(cc)
                z.set_zoom(cc)
            end}
    )
    hj:button_holder({})
    hj:button(
        {name = "Copy JobId", callback = function()
                setclipboard(game.JobId)
            end}
    )
    hj:button_holder({})
    hj:button(
        {name = "Copy GameID", callback = function()
                setclipboard(game.GameId)
            end}
    )
    hj:button_holder({})
    hj:button(
        {
            name = "Copy Join Script",
            callback = function()
                setclipboard(
                    'game:GetService("TeleportService"):TeleportToPlaceInstance(' ..
                        game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)'
                )
            end
        }
    )
    hj:button_holder({})
    hj:button(
        {name = "Rejoin", callback = function()
                game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, i)
            end}
    )
    hj:button_holder({})
    hj:button(
        {
            name = "Join New Server",
            callback = function()
                local hw =
                    game:GetService("HttpService"):JSONDecode(
                    game:HttpGetAsync(
                        "https://games.roblox.com/v1/games/" ..
                            game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
                    )
                )
                local hx = hw.data[h(1, #hw.data)]
                if hx.playing <= g["max_players"] then
                    game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, hx.id)
                end
            end
        }
    )
    hj:slider({name = "Max Players", flag = "max_players", min = 0, max = 40, default = 15, interval = 1})
    t.open_tab()
    task.spawn(
        function()
            while task.wait(1) do
                y.change_text(ho())
            end
        end
    )
    do
        local w = game:GetService("Players")
        local ea = game:GetService("RunService")
        local function hy(b9)
            if b9 ~= i then
                z.add_dot(b9)
            end
        end
        for bc, b9 in ipairs(w:GetPlayers()) do
            hy(b9)
        end
        table.insert(a.connections, w.PlayerAdded:Connect(hy))
        table.insert(
            a.connections,
            w.PlayerRemoving:Connect(
                function(b9)
                    z.remove_dot(b9)
                end
            )
        )
        -- radar connection
        local radar_conn = nil
        local function update_radar()
            if z then
                for bc, b9 in ipairs(w:GetPlayers()) do
                    if b9 ~= i then
                        local a3 = b9.Character
                        local bd = a3 and a3:FindFirstChild("HumanoidRootPart")
                        if bd then
                            z.update_dot(b9, bd.Position)
                        end
                    end
                end
            end
        end
        local function update_radar_connection()
            if g["hud_radar"] then
                if not radar_conn then
                    radar_conn = ea.RenderStepped:Connect(update_radar)
                    table.insert(a.connections, radar_conn)
                end
            else
                if radar_conn then
                    radar_conn:Disconnect()
                    radar_conn = nil
                end
            end
        end
        -- initial check
        update_radar_connection()
        -- hook flag changes
        local orig_hud_radar = g["hud_radar"]
        local mt = getmetatable(g) or {}
        local orig_newindex = mt.__newindex
        mt.__newindex = function(t, k, v)
            if k == "hud_radar" then
                orig_hud_radar = v
                update_radar_connection()
            end
            if orig_newindex then
                return orig_newindex(t, k, v)
            else
                rawset(t, k, v)
            end
        end
        setmetatable(g, mt)
    end
    a:config_list_update()
    for hz, cL in next, f.preset do
        pcall(
            function()
                a:update_theme(hz, cL)
            end
        )
    end
    do
        local hA = u:column()
        local hB = hA:section({name = "Desync"})
        local hC = {
            enabled = false,
            value_to_buy = 100,
            loop_conn = nil,
            armor_conn = nil,
            char_conn = nil,
            stopped = false,
            busy = false,
            last_click_t = 0,
            click_interval = 0.02,
            post_wait_frames = 2,
            last_attempt = 0,
            attempt_cooldown = 0.1,
            shop_head = nil,
            shop_clickdet = nil
        }
        local hD = {autostomp_active = false}
        local function hE()
            local a3 = i.Character
            if not a3 then
                return nil
            end
            local fe = a3:FindFirstChild("BodyEffects")
            local hF = fe and fe:FindFirstChild("Armor")
            return hF and hF.Value or nil
        end
        local function hG()
            local hH = i:FindFirstChild("DataFolder")
            local hI = hH and hH:FindFirstChild("Currency")
            return hI and hI.Value or 0
        end
        local function hJ()
            local hK = workspace:FindFirstChild("Ignored")
            hK = hK and hK:FindFirstChild("Shop")
            if not hK then
                return nil
            end
            local dC = hK:GetChildren()
            local hL = dC[16]
            local dc, hM
            if hL then
                dc = hL:FindFirstChild("Head")
                if dc then
                    hM = dc:FindFirstChildOfClass("ClickDetector") or hL:FindFirstChildOfClass("ClickDetector")
                end
            end
            if not (hL and dc and hM) then
                hL, dc, hM = nil, nil, nil
                for bc, hN in ipairs(dC) do
                    local c1 = hN:FindFirstChild("Head")
                    if c1 then
                        local hO =
                            c1:FindFirstChildOfClass("ClickDetector") or hN:FindFirstChildOfClass("ClickDetector")
                        if hO then
                            hL, dc, hM = hN, c1, hO
                            break
                        end
                    end
                end
            end
            return hL, dc, hM
        end
        local function hP()
            if hC.shop_head and hC.shop_clickdet then
                return hC.shop_head, hC.shop_clickdet
            end
            local bc, dc, hQ = hJ()
            hC.shop_head, hC.shop_clickdet = dc, hQ
            return dc, hQ
        end
        local function hR()
            if not hC.enabled or hC.stopped or hC.busy then
                return
            end
            local I = tick()
            if I - hC.last_attempt < hC.attempt_cooldown then
                return
            end
            hC.last_attempt = I
            local hI = hE()
            if not hI then
                return
            end
            if hI >= 200 or hI > hC.value_to_buy then
                return
            end
            if hG() < 1000 then
                return
            end
            local dc, hQ = hP()
            if not (dc and hQ) then
                return
            end
            if _G.DesyncLibrary then
                hC.busy = true
                if g and g["Debug"] then
                    print("[AutoArmor] moving to shop (instant)")
                end
                _G.DesyncLibrary.movedesyncto(dc.CFrame)
                pcall(
                    function()
                        B.run.Heartbeat:Wait()
                        B.run.RenderStepped:Wait()
                    end
                )
                for cY = 1, 30 do
                    if hC.stopped or not hC.enabled then
                        break
                    end
                    local cc = hE()
                    if cc and (cc >= 200 or cc >= hC.value_to_buy) then
                        break
                    end
                    if hG() < 1000 then
                        break
                    end
                    B.run.RenderStepped:Wait()
                    pcall(fireclickdetector, hQ)
                    if hC.click_interval and hC.click_interval > 0 then
                        B.run.Heartbeat:Wait()
                        _G.DesyncLibrary.SynchronizeSyncWithPlayer()
                    end
                end
                if g and g["Debug"] then
                    print("[AutoArmor] resynced after purchase")
                end
                hC.busy = false
            end
        end
        local function hS()
            if hC.armor_conn then
                return
            end
            local a3 = i.Character
            if not a3 then
                return
            end
            local fe = a3:FindFirstChild("BodyEffects")
            local hF = fe and fe:FindFirstChild("Armor")
            if not hF then
                return
            end
            hC.armor_conn =
                hF.Changed:Connect(
                function()
                    hR()
                end
            )
            hR()
        end
        local function hT()
            if hC.char_conn then
                return
            end
            hC.char_conn =
                i.CharacterAdded:Connect(
                function()
                    pcall(
                        function()
                            B.run.Heartbeat:Wait()
                            B.run.RenderStepped:Wait()
                        end
                    )
                    if hC.armor_conn then
                        hC.armor_conn:Disconnect()
                        hC.armor_conn = nil
                    end
                    hC.shop_head, hC.shop_clickdet = nil, nil
                    if hC.enabled then
                        hP()
                        hS()
                        hR()
                    end
                end
            )
        end
        local function hU()
            if hC.loop_conn then
                return
            end
            hP()
            hS()
            hT()
            hC.loop_conn =
                B.task.spawn(
                function()
                    while hC.enabled do
                        B.task.wait(0.05)
                        if not hC.stopped then
                            hR()
                        end
                    end
                end
            )
        end
        local function hV()
            if hC.loop_conn then
                pcall(
                    function()
                        B.task.cancel(hC.loop_conn)
                    end
                )
                hC.loop_conn = nil
            end
            if hC.armor_conn then
                hC.armor_conn:Disconnect()
                hC.armor_conn = nil
            end
            if hC.char_conn then
                hC.char_conn:Disconnect()
                hC.char_conn = nil
            end
            hC.busy = false
            hC.shop_head, hC.shop_clickdet = nil, nil
            if _G.DesyncLibrary then
                pcall(
                    function()
                        _G.DesyncLibrary.SynchronizeSyncWithPlayer()
                    end
                )
            end
        end
        local hW =
            hB:toggle(
            {name = "Auto Armor", flag = "auto_armor_enabled", default = false, callback = function(state)
                    hC.enabled = state
                    if state then
                        hU()
                    else
                        hV()
                    end
                    if autostomp_state and autostomp_state.enabled then
                        autostomp_state.last_sync = 0
                        autostomp_state.last_stomp = 0
                    end
                    hC.busy = state and hC.busy or false
                end}
        )
        local hX = hB:dependency_box()
        hX:setup_dependencies({{hW, true}})
        hX:slider(
            {name = "BuyAt", flag = "armor_percent_to_buy", min = 1, max = 199, default = 100, callback = function(cL)
                    hC.value_to_buy = cL
                end}
        )
        hC.value_to_buy =
            g and typeof(g["armor_percent_to_buy"]) == "number" and g["armor_percent_to_buy"] or hC.value_to_buy
        do
            local autostomp_state = {
                enabled = false,
                loop_conn = nil,
                hb_conn = nil,
                stomp_rate = 10,
                last_stomp = 0,
                was_active = false,
                tu_registered = false,
                noclip_char = nil,
                noclip_parts = {},
                y_offset = 0,
                last_sync = 0,
                sync_interval = 3
            }
            local function hY(az)
                return az and az.Character and az.Character:FindFirstChild("BodyEffects") and
                    az.Character.BodyEffects:FindFirstChild("K.O") and
                    az.Character.BodyEffects["K.O"].Value
            end
            local function hZ(az)
                if not az or not az.Character then
                    return nil
                end
                local a3 = az.Character
                local h_ = a3:FindFirstChild("UpperTorso")
                local i0 = a3:FindFirstChild("LowerTorso")
                local i1 = h_ or i0
                return i1 and i1.CFrame
            end
            local function i2()
                if autostomp_state.noclip_char then
                    for bg, i3 in pairs(autostomp_state.noclip_parts) do
                        if bg and bg.Parent then
                            pcall(
                                function()
                                    bg.CanCollide = i3
                                end
                            )
                        end
                    end
                    autostomp_state.noclip_parts = {}
                    autostomp_state.noclip_char = nil
                end
            end
            local function i4(az)
                local a3 = az and az.Character
                if not a3 then
                    return
                end
                if autostomp_state.noclip_char == a3 then
                    return
                end
                i2()
                autostomp_state.noclip_char = a3
                for bc, br in ipairs(a3:GetDescendants()) do
                    if br:IsA("BasePart") then
                        autostomp_state.noclip_parts[br] = br.CanCollide
                        pcall(
                            function()
                                br.CanCollide = false
                            end
                        )
                    end
                end
            end
            local function i5()
                if autostomp_state.hb_conn then
                    return
                end
                autostomp_state.last_stomp = 0
                autostomp_state.last_sync = 0
                autostomp_state.was_active = false
                if not autostomp_state.tu_registered and C and C.OnTargetUpdate then
                    autostomp_state.tu_registered = true
                    C:OnTargetUpdate(
                        function(aD)
                            if not autostomp_state.enabled then
                                return
                            end
                            if not aD and autostomp_state.was_active then
                                i2()
                                pcall(
                                    function()
                                        if _G.DesyncLibrary and _G.DesyncLibrary.SynchronizeSyncWithPlayer then
                                            _G.DesyncLibrary.SynchronizeSyncWithPlayer()
                                        end
                                    end
                                )
                                autostomp_state.was_active = false
                            end
                            autostomp_state.last_stomp = 0
                        end
                    )
                end
                autostomp_state.hb_conn =
                    B.run.Heartbeat:Connect(
                    function()
                        local bU = targeting_state and targeting_state.current
                        local i6 = hC.busy == true
                        local i7 = autostomp_state.enabled and not i6 and bU and hY(bU)
                        hD.autostomp_active = i7 and true or false
                        if not i6 and autostomp_state.was_active and not i7 then
                            autostomp_state.last_sync = 0
                            autostomp_state.last_stomp = 0
                        end
                        if i7 then
                            i4(bU)
                            autostomp_state.was_active = true
                            local I = os.clock()
                            if I - autostomp_state.last_sync >= autostomp_state.sync_interval then
                                autostomp_state.last_sync = I
                                pcall(
                                    function()
                                        if _G.DesyncLibrary and _G.DesyncLibrary.SynchronizeSyncWithPlayer then
                                            _G.DesyncLibrary.SynchronizeSyncWithPlayer()
                                        end
                                    end
                                )
                            end
                            local i8 = hZ(bU)
                            if i8 then
                                pcall(
                                    function()
                                        if _G.DesyncLibrary and _G.DesyncLibrary.movedesyncto then
                                            _G.DesyncLibrary.movedesyncto(i8.X, i8.Y + autostomp_state.y_offset, i8.Z)
                                        end
                                    end
                                )
                            end
                            local I = os.clock()
                            local i9 = 1 / math.max(1, autostomp_state.stomp_rate)
                            if I - autostomp_state.last_stomp >= i9 then
                                autostomp_state.last_stomp = I
                                pcall(
                                    function()
                                        local ia = game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent")
                                        if ia then
                                            ia:FireServer("Stomp")
                                        end
                                    end
                                )
                            end
                        else
                            if autostomp_state.was_active then
                                i2()
                                pcall(
                                    function()
                                        if _G.DesyncLibrary and _G.DesyncLibrary.SynchronizeSyncWithPlayer then
                                            _G.DesyncLibrary.SynchronizeSyncWithPlayer()
                                        end
                                    end
                                )
                                autostomp_state.was_active = false
                            end
                        end
                    end
                )
            end
            local function ib()
                if autostomp_state.loop_conn then
                    B.task.cancel(autostomp_state.loop_conn)
                    autostomp_state.loop_conn = nil
                end
                if autostomp_state.hb_conn then
                    autostomp_state.hb_conn:Disconnect()
                    autostomp_state.hb_conn = nil
                end
                i2()
                pcall(
                    function()
                        if _G.DesyncLibrary and _G.DesyncLibrary.SynchronizeSyncWithPlayer then
                            _G.DesyncLibrary.SynchronizeSyncWithPlayer()
                        end
                    end
                )
                autostomp_state.was_active = false
                hD.autostomp_active = false
            end
            local ic =
                hB:toggle(
                {name = "AutoStomp", flag = "autostomp_enabled", default = false, callback = function(bX)
                        autostomp_state.enabled = bX
                        if bX then
                            i5()
                        else
                            ib()
                        end
                    end}
            )
            local id = hB:dependency_box()
            id:setup_dependencies({{ic, true}})
            id:slider(
                {
                    name = "YOff",
                    flag = "autostomp_y_offset",
                    min = -1,
                    max = 3,
                    default = 0,
                    interval = 0.01,
                    callback = function(cc)
                        autostomp_state.y_offset = cc
                    end
                }
            )
        end
        do
            local ie = {enabled = false, hb_conn = nil, mode = "VoidStatic"}
            local function ig()
                return B.math.random() * 1e21
            end
            local function ih()
                return (B.math.random() < 0.5 and -1 or 1) * ig()
            end
            local function ii()
                if ie.hb_conn then
                    return
                end
                ie.hb_conn =
                    B.run.Heartbeat:Connect(
                    function()
                        local ij = hC.busy == true or hD.autostomp_active == true
                        local aG = shared and shared.Rebuild_FlingActive or false
                        local aH = C and C._fling_wave_running == true or false
                        if ie.enabled and not ij and not aG and not aH then
                            pcall(
                                function()
                                    if _G.DesyncLibrary and _G.DesyncLibrary.movedesyncto then
                                        local c3 = ie.mode
                                        local a0, bN, bO
                                        if c3 == "VoidStatic" then
                                            a0, bN, bO = -18e18, -18e18, -18e18
                                        elseif c3 == "VoidRandom" then
                                            a0 = ih()
                                            bN = -ig()
                                            bO = ih()
                                        elseif c3 == "SkyStatic" then
                                            a0, bN, bO = 18e20, 18e20, 18e20
                                        elseif c3 == "SkyRandom" then
                                            a0 = ih()
                                            bN = ig()
                                            bO = ih()
                                        elseif c3 == "WorldRandom" then
                                            a0 = ih()
                                            bN = ih()
                                            bO = ih()
                                        elseif c3 == "Infinity" then
                                            a0 = B.math.huge
                                            bN = B.math.huge
                                            bO = -B.math.huge
                                        else
                                            a0, bN, bO = -18e18, -18e18, -18e18
                                        end
                                        _G.DesyncLibrary.movedesyncto(a0, bN, bO)
                                    end
                                end
                            )
                        end
                    end
                )
            end
            local function ik()
                if ie.hb_conn then
                    ie.hb_conn:Disconnect()
                    ie.hb_conn = nil
                end
                local ij = hC.busy == true or hD.autostomp_active == true
                if not ij then
                    pcall(
                        function()
                            local il = _G.DesyncLibrary
                            if il and il.SynchronizeSyncWithPlayer then
                                il.SynchronizeSyncWithPlayer()
                                return
                            end
                            if il and il.movedesyncto then
                                local i = game and game.Players and game.Players.LocalPlayer
                                local a3 = i and i.Character
                                local bd = a3 and a3:FindFirstChild("HumanoidRootPart")
                                if bd then
                                    local b9 = bd.Position
                                    il.movedesyncto(b9.X, b9.Y, b9.Z)
                                end
                            end
                        end
                    )
                end
            end
            C._voiding = ie
            C._void_start = ii
            C._void_stop = ik
            local im =
                hB:toggle(
                {name = "Voiding", flag = "voiding_enabled", default = false, callback = function(state)
                        local aG = shared and shared.Rebuild_FlingActive or false
                        local aH = C and C._fling_wave_running == true or false
                        if state and (aG or aH) then
                            ie.enabled = false
                            if a and a.notification then
                                a:notification({text = "FlingActive", time = 2})
                            end
                            return
                        end
                        ie.enabled = state
                        if state then
                            ii()
                        else
                            ik()
                        end
                    end}
            )
            local io = hB:dependency_box()
            io:setup_dependencies({{im, true}})
            io:dropdown(
                {
                    name = "Mode",
                    flag = "voiding_mode",
                    items = {"VoidStatic", "VoidRandom", "SkyStatic", "SkyRandom", "WorldRandom", "Infinity"},
                    callback = function(cc)
                        ie.mode = cc
                    end
                }
            )
        end
        local ip = hA:section({name = "Classics"})
        do
            local iq = {enabled = false, originals = {}, loop_gen = 0, loop_running = false}
            local ir = B and B.Players or game:GetService("Players")
            local r = i or ir and ir.LocalPlayer
            local is = task and task.wait or wait
            local it = task and task.spawn or spawn
            local iu = 1e-20
            local function iv(V)
                if not (V and V:IsA("Tool") and V:FindFirstChild("GunScript")) then
                    return
                end
                if type(getconnections) ~= "function" then
                    return
                end
                local iw = V.Activated
                local Z, ix = pcall(getconnections, iw)
                if not Z or type(ix) ~= "table" then
                    return
                end
                for I, iy in ipairs(ix) do
                    local iz = iy.Function
                    if iz then
                        local iA = debug.getinfo(iz)
                        if iA and iA.nups then
                            iq.originals[iz] = iq.originals[iz] or {}
                            for av = 1, iA.nups do
                                local iB = select(1, debug.getupvalue(iz, av))
                                if type(iB) == "number" then
                                    if iq.originals[iz][av] == nil and iB ~= iu then
                                        iq.originals[iz][av] = iB
                                    end
                                    if iq.enabled then
                                        pcall(debug.setupvalue, iz, av, iu)
                                    end
                                end
                            end
                        end
                    end
                end
            end
            local function aF()
                if iq.loop_running then
                    return
                end
                iq.loop_gen = iq.loop_gen + 1
                local iC = iq.loop_gen
                iq.loop_running = true
                it(
                    function()
                        while iq.enabled and iq.loop_gen == iC do
                            local aI = r and r.Character
                            local V = aI and aI:FindFirstChildOfClass("Tool")
                            iv(V)
                            is(0.01)
                        end
                        iq.loop_running = false
                    end
                )
            end
            local function iD()
                for iz, iE in pairs(iq.originals) do
                    for av, iF in pairs(iE) do
                        pcall(debug.setupvalue, iz, av, iF)
                    end
                end
                iq.originals = {}
            end
            local function aM()
                iq.loop_gen = iq.loop_gen + 1
                iD()
            end
            ip:toggle(
                {name = "RapidFire", flag = "rapidfire_enabled", callback = function(a3)
                        iq.enabled = a3
                        if a3 then
                            aF()
                        else
                            aM()
                        end
                    end}
            )
        end
        do
            local hZ = {
                enabled = false,
                range = 1000,
                hb_conn = nil,
                bp_added_conn = nil,
                char_child_conn = nil,
                char_added_conn = nil
            }
            local ir = B and B.Players
            local r = i
            local iG = B and B.RunService
            local iH = B and B.workspace
            local function iI(V)
                if not V then
                    return
                end
                local A = V:FindFirstChild("Range")
                if A and A:IsA("ValueBase") then
                    pcall(
                        function()
                            A.Value = hZ.range
                        end
                    )
                end
            end
            local function iJ()
                if not hZ.enabled then
                    return
                end
                local iK
                do
                    local iL = iH and iH:FindFirstChild("Players")
                    if iL and r and r.Name then
                        iK = iL:FindFirstChild(r.Name)
                    end
                end
                for I, iM in ipairs({r and r.Character, r and r.Backpack, iK}) do
                    if iM then
                        for I, V in ipairs(iM:GetChildren()) do
                            iI(V)
                        end
                    end
                end
            end
            local function iN(V)
                if hZ.enabled then
                    iI(V)
                end
            end
            local function iO(c)
                if hZ.char_child_conn then
                    pcall(
                        function()
                            hZ.char_child_conn:Disconnect()
                        end
                    )
                    hZ.char_child_conn = nil
                end
                if c then
                    hZ.char_child_conn = c.ChildAdded:Connect(iN)
                end
            end
            local function aF()
                if hZ.hb_conn then
                    return
                end
                hZ.hb_conn = iG.Heartbeat:Connect(iJ)
                if r then
                    if r.Backpack and not hZ.bp_added_conn then
                        hZ.bp_added_conn = r.Backpack.ChildAdded:Connect(iN)
                    end
                    iO(r.Character)
                    if not hZ.char_added_conn then
                        hZ.char_added_conn = r.CharacterAdded:Connect(iO)
                    end
                end
                iJ()
            end
            local function aM()
                if hZ.hb_conn then
                    pcall(
                        function()
                            if hZ.hb_conn.Connected then
                                hZ.hb_conn:Disconnect()
                            else
                                hZ.hb_conn:Disconnect()
                            end
                        end
                    )
                    hZ.hb_conn = nil
                end
                if hZ.bp_added_conn then
                    pcall(
                        function()
                            hZ.bp_added_conn:Disconnect()
                        end
                    )
                    hZ.bp_added_conn = nil
                end
                if hZ.char_child_conn then
                    pcall(
                        function()
                            hZ.char_child_conn:Disconnect()
                        end
                    )
                    hZ.char_child_conn = nil
                end
                if hZ.char_added_conn then
                    pcall(
                        function()
                            hZ.char_added_conn:Disconnect()
                        end
                    )
                    hZ.char_added_conn = nil
                end
            end
            local iP =
                ip:toggle(
                {name = "Gunrange", flag = "gunrange_enabled", callback = function(a3)
                        hZ.enabled = a3
                        if a3 then
                            aF()
                        else
                            aM()
                        end
                    end}
            )
            local iQ = ip:dependency_box()
            iQ:setup_dependencies({{iP, true}})
            iQ:textbox(
                {name = "Range", flag = "gunrange_range", placeholder = "1000", callback = function(K)
                        local w = tonumber(K)
                        if w then
                            hZ.range = w
                            if hZ.enabled then
                                iJ()
                            end
                        end
                    end}
            )
        end
        do
            local iR = {
                enabled = false,
                mode = "Collide",
                stepped = nil,
                rayCheck = nil,
                modified = {},
                char_touched = {}
            }
            local ir = B and B.Players or game:GetService("Players")
            local r = i or ir and ir.LocalPlayer
            local iG = B and B.RunService or game:GetService("RunService")
            local iH = B and B.workspace or workspace
            local function iS()
                for ai, iT in pairs(iR.modified) do
                    pcall(
                        function()
                            if ai then
                                if iT.cancollide ~= nil then
                                    ai.CanCollide = iT.cancollide
                                end
                            end
                        end
                    )
                    iR.modified[ai] = nil
                end
                for ai, iF in pairs(iR.char_touched) do
                    pcall(
                        function()
                            if ai and ai.Parent then
                                ai.CanCollide = iF
                            end
                        end
                    )
                    iR.char_touched[ai] = nil
                end
            end
            local function iU()
                local iV = {}
                local ar = B and B.workspace and B.workspace.CurrentCamera
                if ar then
                    table.insert(iV, ar)
                end
                if i and i.Character then
                    table.insert(iV, i.Character)
                end
                local iW = B and B.Players
                if iW then
                    for I, iX in ipairs(iW:GetPlayers()) do
                        if iX ~= i and iX.Character then
                            table.insert(iV, iX.Character)
                        end
                    end
                end
                return iV
            end
            local function iY()
                if not iR.rayCheck then
                    local iZ = B and B.RaycastParams and B.RaycastParams.new or RaycastParams and RaycastParams.new
                    iR.rayCheck = iZ and iZ() or nil
                    if iR.rayCheck and iR.rayCheck.FilterType then
                        iR.rayCheck.FilterType = Enum.RaycastFilterType.Blacklist
                    end
                end
                local i_ = iU()
                if iR.rayCheck and iR.rayCheck.FilterDescendantsInstances then
                    iR.rayCheck.FilterDescendantsInstances = i_
                end
            end
            local function aF()
                if iR.stepped then
                    return
                end
                iR.stepped =
                    B and B.RunService and
                    B.RunService.Stepped:Connect(
                        function()
                            local aI = i and i.Character
                            local at = aI and aI:FindFirstChildOfClass("Humanoid")
                            local aJ = aI and aI:FindFirstChild("HumanoidRootPart")
                            local a7 = aI and aI:FindFirstChild("Head")
                            if not (at and aJ and a7) then
                                return
                            end
                            if iR.mode == "LocalCollid" then
                                for I, d in ipairs(aI:GetDescendants()) do
                                    if d:IsA("BasePart") then
                                        if iR.char_touched[d] == nil then
                                            iR.char_touched[d] = d.CanCollide
                                        end
                                        d.CanCollide = false
                                    end
                                end
                            elseif iR.mode == "Collide" then
                                iY()
                                if not iR.rayCheck then
                                    return
                                end
                                local j0 = at.MoveDirection
                                if j0.Magnitude < 1e-3 then
                                    return
                                end
                                local j1 = B and B.workspace and B.workspace:Raycast(a7.Position, j0 * 3, iR.rayCheck)
                                if j1 and j1.Instance and j1.Instance:IsA("BasePart") then
                                    local j2 = j1.Instance
                                    if not iR.modified[j2] then
                                        iR.modified[j2] = {cancollide = j2.CanCollide}
                                        pcall(
                                            function()
                                                j2.CanCollide = false
                                            end
                                        )
                                    end
                                end
                            end
                        end
                    )
            end
            local function aM()
                if iR.stepped then
                    pcall(
                        function()
                            iR.stepped:Disconnect()
                        end
                    )
                    iR.stepped = nil
                end
                iS()
            end
            local j3 =
                ip:toggle(
                {name = "Noclip", flag = "noclip_enabled", callback = function(a3)
                        iR.enabled = a3
                        if a3 then
                            aF()
                        else
                            aM()
                        end
                    end}
            )
            local j4 = ip:dependency_box()
            j4:setup_dependencies({{j3, true}})
            local j5 =
                j4:dropdown(
                {
                    name = "Mode",
                    flag = "noclip_mode",
                    items = {"Collide", "LocalCollid"},
                    default = "Collide",
                    callback = function(ay)
                        iR.mode = ay
                        if iR.enabled then
                            iS()
                        end
                    end
                }
            )
        end
        do
            local bP = {enabled = false, mode = "Smart", hb = nil, touched = {}, detected = {}}
            local function j6()
                for ai, iF in pairs(bP.touched) do
                    pcall(
                        function()
                            if ai and ai.Parent then
                                ai.CanCollide = iF
                            end
                        end
                    )
                    bP.touched[ai] = nil
                end
                for iX, I in pairs(bP.detected) do
                    bP.detected[iX] = nil
                end
            end
            local function j7(dR)
                if not dR then
                    return
                end
                for I, d in ipairs(dR:GetDescendants()) do
                    if d:IsA("BasePart") then
                        if bP.touched[d] == nil then
                            bP.touched[d] = d.CanCollide
                        end
                        d.CanCollide = false
                        local j8 = B and B.Vector3 or Vector3
                        pcall(
                            function()
                                d.AssemblyLinearVelocity = j8.new(0, 0, 0)
                            end
                        )
                        pcall(
                            function()
                                d.AssemblyAngularVelocity = j8.new(0, 0, 0)
                            end
                        )
                        pcall(
                            function()
                                if PhysicalProperties then
                                    d.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
                                end
                            end
                        )
                    end
                end
            end
            local function aF()
                if bP.hb then
                    return
                end
                bP.hb =
                    B and B.RunService and
                    B.RunService.Heartbeat:Connect(
                        function()
                            if not bP.enabled then
                                return
                            end
                            local iW = B and B.Players
                            if iW then
                                for I, iX in ipairs(iW:GetPlayers()) do
                                    if iX ~= i and iX.Character then
                                        local dR = iX.Character
                                        if dR and dR:IsDescendantOf(workspace) then
                                            for I, d in ipairs(dR:GetDescendants()) do
                                                if d:IsA("BasePart") then
                                                    if bP.touched[d] == nil then
                                                        bP.touched[d] = d.CanCollide
                                                    end
                                                    d.CanCollide = false
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            local j9 = i and i.Character
                            local ja = j9 and j9:FindFirstChild("HumanoidRootPart")
                            if ja then
                                local jb = ja.AssemblyLinearVelocity
                                local c4 = ja.AssemblyAngularVelocity
                                local jc = shared and shared.Rebuild_SilentFling or false
                                local jd = shared and shared.Rebuild_FlingActive or false
                                if not jc and not jd and (jb and jb.Magnitude > 250 or c4 and c4.Magnitude > 250) then
                                    local j8 = B and B.Vector3 or Vector3
                                    pcall(
                                        function()
                                            ja.AssemblyLinearVelocity = j8.new(0, 0, 0)
                                        end
                                    )
                                    pcall(
                                        function()
                                            ja.AssemblyAngularVelocity = j8.new(0, 0, 0)
                                        end
                                    )
                                    pcall(
                                        function()
                                            local je = B and B.StarterGui or game:GetService("StarterGui")
                                            je:SetCore(
                                                "ChatMakeSystemMessage",
                                                {
                                                    Text = "You were flung. Neutralizing velocity.",
                                                    Color = Color3.fromRGB(255, 0, 0)
                                                }
                                            )
                                        end
                                    )
                                end
                            end
                        end
                    )
            end
            local function aM()
                if bP.hb then
                    pcall(
                        function()
                            bP.hb:Disconnect()
                        end
                    )
                    bP.hb = nil
                end
                j6()
            end
            local jf =
                ip:toggle(
                {name = "AntiFling", flag = "antifling_enabled", callback = function(a3)
                        bP.enabled = a3
                        if a3 then
                            aF()
                        else
                            aM()
                        end
                    end}
            )
            local jg = ip:dependency_box()
            jg:setup_dependencies({{jf, true}})
            jg:dropdown(
                {name = "Mode", flag = "antifling_mode", items = {"All"}, default = "All", callback = function(ay)
                        bP.mode = ay
                    end}
            )
        end
        do
            -- animation system start
            local rbAnim = {
                CurrentTrack = nil,
                CurrentAnimator = nil,
                StopConnection = nil,
                CharAddedConn = nil,
                Settings = {customAnimEnabled = false, customAnimId = "10714340543", customAnimSpeed = 1}
            }
            -- ensure getgenv defaults
            if not getgenv().AnimBreakerSettings then
                getgenv().AnimBreakerSettings = rbAnim.Settings
            end
            -- stop current animation
            function rbAnim.StopAnimation()
                if rbAnim.StopConnection then
                    pcall(function()
                        rbAnim.StopConnection:Disconnect()
                    end)
                    rbAnim.StopConnection = nil
                end
                if rbAnim.CurrentTrack then
                    pcall(function()
                        rbAnim.CurrentTrack:Stop()
                    end)
                    rbAnim.CurrentTrack = nil
                end
            end
            -- start new animation
            function rbAnim.StartAnimation(animId, speed)
                rbAnim.StopAnimation()
                local ir = B and B.Players or game:GetService("Players")
                local r = i or ir and ir.LocalPlayer
                local char = r and r.Character
                if not char then
                    return
                end
                local hum = char:FindFirstChildOfClass("Humanoid")
                if not hum then
                    return
                end
                rbAnim.CurrentAnimator = hum:FindFirstChildOfClass("Animator")
                if not rbAnim.CurrentAnimator then
                    pcall(function()
                        local a = Instance.new("Animator")
                        a.Parent = hum
                        rbAnim.CurrentAnimator = a
                    end)
                end
                if not rbAnim.CurrentAnimator then
                    return
                end
                local anim = Instance.new("Animation")
                anim.AnimationId = "rbxassetid://" .. tostring(animId)
                pcall(function()
                    rbAnim.CurrentTrack = rbAnim.CurrentAnimator:LoadAnimation(anim)
                end)
                if rbAnim.CurrentTrack then
                    pcall(function()
                        for _, track in ipairs(rbAnim.CurrentAnimator:GetPlayingAnimationTracks()) do
                            if track ~= rbAnim.CurrentTrack then
                                track:Stop(0)
                            end
                        end
                    end)
                    rbAnim.CurrentTrack.Looped = true
                    rbAnim.CurrentTrack.Priority = Enum.AnimationPriority.Action
                    rbAnim.CurrentTrack:Play()
                    local spd = math.clamp(tonumber(speed) or 1, 0.1, 20)
                    pcall(function()
                        rbAnim.CurrentTrack:AdjustSpeed(spd)
                    end)
                    rbAnim.StopConnection = rbAnim.CurrentTrack.Stopped:Connect(function()
                        if rbAnim.Settings.customAnimEnabled then
                            task.delay(0.1, function()
                                if rbAnim.Settings.customAnimEnabled then
                                    rbAnim.StartAnimation(rbAnim.Settings.customAnimId, rbAnim.Settings.customAnimSpeed)
                                end
                            end)
                        end
                    end)
                end
            end
            -- update speed
            function rbAnim.UpdateSpeed(speed)
                if rbAnim.CurrentTrack then
                    local spd = math.clamp(tonumber(speed) or 1, 0.1, 20)
                    pcall(function()
                        rbAnim.CurrentTrack:AdjustSpeed(spd)
                    end)
                end
            end
            -- UI
            local ca = ip:toggle({name = "CustomAnimation", flag = "customanim_enabled", default = false, callback = function(state)
                    rbAnim.Settings.customAnimEnabled = state
                    getgenv().AnimBreakerSettings.customAnimEnabled = state
                    if state then
                        rbAnim.StartAnimation(rbAnim.Settings.customAnimId, rbAnim.Settings.customAnimSpeed)
                    else
                        rbAnim.StopAnimation()
                    end
                end})
            local cb = ip:dependency_box()
            cb:setup_dependencies({{ca, true}})
            cb:dropdown({
                name = "Animation",
                flag = "customanim_select",
                items = {"Floss", "TakeTheL", "CaramelDancen", "ModelBreak", "Ziga", "ReverseFlash", "SpeedMirage", "DogJump"},
                default = "Floss",
                callback = function(val)
                    if val == "Floss" then
                        rbAnim.Settings.customAnimId = "10714340543"
                    elseif val == "TakeTheL" then
                        rbAnim.Settings.customAnimId = "117865821073911"
                    elseif val == "CaramelDancen" then
                        rbAnim.Settings.customAnimId = "83570358825425"
                    elseif val == "ModelBreak" then
                        rbAnim.Settings.customAnimId = "109873544976020"
                    elseif val == "Ziga" then
                        rbAnim.Settings.customAnimId = "100823802222093"
                    elseif val == "ReverseFlash" then
                        rbAnim.Settings.customAnimId = "73295259493176"
                    elseif val == "SpeedMirage" then
                        rbAnim.Settings.customAnimId = "115334992181298"
                    elseif val == "DogJump" then
                        rbAnim.Settings.customAnimId = "82726502516305"
                    end
                    getgenv().AnimBreakerSettings.customAnimId = rbAnim.Settings.customAnimId
                    if rbAnim.Settings.customAnimEnabled then
                        rbAnim.StartAnimation(rbAnim.Settings.customAnimId, rbAnim.Settings.customAnimSpeed)
                    end
                end
            })
            cb:slider({
                name = "Spd",
                flag = "customanim_speed",
                min = 0.1,
                max = 20,
                default = 1,
                interval = 0.1,
                callback = function(v)
                    rbAnim.Settings.customAnimSpeed = tonumber(v) or 1
                    getgenv().AnimBreakerSettings.customAnimSpeed = rbAnim.Settings.customAnimSpeed
                    rbAnim.UpdateSpeed(rbAnim.Settings.customAnimSpeed)
                end
            })
            -- restart on respawn
            do
                local ir = B and B.Players or game:GetService("Players")
                local r = i or ir and ir.LocalPlayer
                if r and not rbAnim.CharAddedConn then
                    rbAnim.CharAddedConn = r.CharacterAdded:Connect(function()
                        if rbAnim.Settings.customAnimEnabled then
                            task.delay(0.5, function()
                                if rbAnim.Settings.customAnimEnabled then
                                    rbAnim.StartAnimation(rbAnim.Settings.customAnimId, rbAnim.Settings.customAnimSpeed)
                                end
                            end)
                        end
                    end)
                end
            end
            -- animation system end
        end
        do
            local jh = {map = {}}
            local function ji(H, jj, gV)
                if not H or type(gV) ~= "function" then
                    return
                end
                local jk = string.lower(H)
                jh.map[jk] = gV
                if jj and type(jj) == "table" then
                    for I, a in ipairs(jj) do
                        if type(a) == "string" then
                            jh.map[string.lower(a)] = gV
                        end
                    end
                end
            end
            local function jl(jm, jn, jo)
                local iX = jo or i
                if type(jm) == "string" then
                    local jp = {}
                    for jq in string.gmatch(jm, "%S+") do
                        table.insert(jp, jq)
                    end
                    local jr = jp[1] and string.lower(jp[1]) or nil
                    local aa = jn or {}
                    if #jp > 1 and not jn then
                        for av = 2, #jp do
                            table.insert(aa, jp[av])
                        end
                    end
                    local gV = jh.map[jr]
                    if gV then
                        return gV(aa, iX)
                    end
                elseif type(jm) == "table" and jm.name then
                    local gV = jh.map[string.lower(jm.name)]
                    if gV then
                        return gV(jm.args or {}, iX)
                    end
                end
            end
            shared = shared or {}
            shared.Rebuild_ExecCmd = jl
            shared.Rebuild_AddCmd = ji
            local function js(jt)
                jt = jt or 10
                local C = table.create(jt)
                for w = 1, jt do
                    C[w] = string.char(math.random(97, 122))
                end
                return table.concat(C)
            end
            local function ju(aI)
                if not aI then
                    return nil
                end
                return aI:FindFirstChild("HumanoidRootPart") or aI.PrimaryPart
            end
            local gT = {flinging = false, conn = nil, bambam = nil}
            local jv = {conn = nil}
            ji(
                "fling",
                {},
                function(aa, jo)
                    if gT.flinging then
                        jl("unfling", nil, jo)
                    end
                    gT.flinging = false
                    local jw = jo and jo.Character
                    if not jw then
                        return
                    end
                    shared = shared or {}
                    shared.Rebuild_FlingActive = true
                    for I, W in ipairs(jw:GetDescendants()) do
                        if W:IsA("BasePart") then
                            pcall(
                                function()
                                    if PhysicalProperties then
                                        W.CustomPhysicalProperties = PhysicalProperties.new(100, 0.3, 0.5)
                                    end
                                end
                            )
                        end
                    end
                    pcall(
                        function()
                            jl("noclip", nil, jo)
                        end
                    )
                    task.wait(0.1)
                    local aJ = ju(jw)
                    if not aJ then
                        shared.Rebuild_FlingActive = false
                        return
                    end
                    local jx = Instance.new("BodyAngularVelocity")
                    jx.Name = js()
                    jx.Parent = aJ
                    jx.AngularVelocity = Vector3.new(0, 99999, 0)
                    jx.MaxTorque = Vector3.new(0, math.huge, 0)
                    jx.P = math.huge
                    gT.bambam = jx
                    for I, a3 in ipairs(jw:GetChildren()) do
                        if a3:IsA("BasePart") then
                            a3.CanCollide = false
                            a3.Massless = true
                            pcall(
                                function()
                                    a3.Velocity = Vector3.new(0, 0, 0)
                                end
                            )
                        end
                    end
                    gT.flinging = true
                    local at = jw:FindFirstChildOfClass("Humanoid")
                    if at then
                        gT.conn =
                            at.Died:Connect(
                            function()
                                jl("unfling", nil, jo)
                            end
                        )
                    end
                    task.spawn(
                        function()
                            while gT.flinging and gT.bambam and gT.bambam.Parent do
                                pcall(
                                    function()
                                        gT.bambam.AngularVelocity = Vector3.new(0, 99999, 0)
                                    end
                                )
                                task.wait(0.2)
                                pcall(
                                    function()
                                        gT.bambam.AngularVelocity = Vector3.new(0, 0, 0)
                                    end
                                )
                                task.wait(0.1)
                            end
                        end
                    )
                end
            )
            ji(
                "unfling",
                {},
                function(aa, jo)
                    shared = shared or {}
                    shared.Rebuild_FlingActive = false
                    gT.flinging = false
                    if gT.conn then
                        pcall(
                            function()
                                gT.conn:Disconnect()
                            end
                        )
                        gT.conn = nil
                    end
                    if gT.bambam then
                        pcall(
                            function()
                                gT.bambam:Destroy()
                            end
                        )
                        gT.bambam = nil
                    end
                end
            )
            ji(
                "antifling",
                {},
                function(aa, jo)
                    if jv.conn then
                        pcall(
                            function()
                                jv.conn:Disconnect()
                            end
                        )
                        jv.conn = nil
                    end
                    local iG = B and B.RunService
                    local ir = B and B.Players
                    if not (iG and ir) then
                        return
                    end
                    jv.conn =
                        iG.Stepped:Connect(
                        function()
                            for I, F in ipairs(ir:GetPlayers()) do
                                if F ~= jo and F.Character then
                                    for I, a3 in ipairs(F.Character:GetDescendants()) do
                                        if a3:IsA("BasePart") then
                                            a3.CanCollide = false
                                        end
                                    end
                                end
                            end
                        end
                    )
                end
            )
            ji(
                "unantifling",
                {},
                function()
                    if jv.conn then
                        pcall(
                            function()
                                jv.conn:Disconnect()
                            end
                        )
                        jv.conn = nil
                    end
                end
            )
        end
        do
            local jy = u:column()
            local jz = jy:section({name = "Movement"})
            local jA = {
                enabled = false,
                active = false,
                method = "Velocity",
                connection = nil,
                options = {
                    Value = {Value = 16},
                    TPTiming = 0,
                    TPFrequency = {Value = 0.1},
                    WallCheck = {Enabled = false},
                    rayCheck = B and B.RaycastParams and B.RaycastParams.new() or RaycastParams.new(),
                    PulseLength = {Value = 0.5},
                    PulseDelay = {Value = 0.2}
                },
                correction = {mode = "None", last_dir = nil}
            }
            local jB = {"Velocity"}
            local jC = {"None", "Lerp"}
            local SpeedMethods = {Velocity = function(jD, jE)
                    local bw = i.Character and i.Character:FindFirstChild("HumanoidRootPart")
                    if not bw then
                        return
                    end
                    bw.AssemblyLinearVelocity = jE * jD.Value.Value + B.Vector3.new(0, bw.AssemblyLinearVelocity.Y, 0)
                end, Impulse = function(jD, jE)
                    local bw = i.Character and i.Character:FindFirstChild("HumanoidRootPart")
                    if not bw then
                        return
                    end
                    local gM = (jE * jD.Value.Value - bw.AssemblyLinearVelocity) * B.Vector3.new(1, 0, 1)
                    if gM.Magnitude > (jE == B.Vector3.new(0, 0, 0) and 10 or 2) then
                        bw:ApplyImpulse(gM * bw.AssemblyMass)
                    end
                end, CFrame = function(jD, jE, dU)
                    local bw = i.Character and i.Character:FindFirstChild("HumanoidRootPart")
                    local fK = i.Character and i.Character:FindFirstChildOfClass("Humanoid")
                    if not bw or not fK then
                        return
                    end
                    local jF = jE * B.math.max(jD.Value.Value - fK.WalkSpeed, 0) * dU
                    if jD.WallCheck.Enabled then
                        jD.rayCheck.FilterDescendantsInstances = {i.Character, B.camera}
                        jD.rayCheck.CollisionGroup = bw.CollisionGroup
                        local jG = B.workspace:Raycast(bw.Position, jF, jD.rayCheck)
                        if jG then
                            jF = jG.Position + jG.Normal - bw.Position
                        end
                    end
                    bw.CFrame = bw.CFrame + jF
                end, TP = function(jD, jE)
                    if jD.TPTiming < B.tick() then
                        jD.TPTiming = B.tick() + jD.TPFrequency.Value
                        SpeedMethods.CFrame(jD, jE, 1)
                    end
                end, Pulse = function(jD, jE)
                    local bw = i.Character and i.Character:FindFirstChild("HumanoidRootPart")
                    local fK = i.Character and i.Character:FindFirstChildOfClass("Humanoid")
                    if not bw or not fK then
                        return
                    end
                    local dU = B.math.max(jD.Value.Value - fK.WalkSpeed, 0)
                    dU =
                        dU *
                        (1 -
                            B.math.min(
                                B.tick() % (jD.PulseLength.Value + jD.PulseDelay.Value) / jD.PulseLength.Value,
                                1
                            ))
                    bw.AssemblyLinearVelocity =
                        jE * (fK.WalkSpeed + dU) + B.Vector3.new(0, bw.AssemblyLinearVelocity.Y, 0)
                end}
            local function jH(cp, dU, bw, fK)
                local gR = jA.correction.mode
                if gR == "None" then
                    return cp
                end
                if cp.Magnitude > 1e-3 then
                    cp = cp.Unit
                else
                    return cp
                end
                if gR == "Lerp" then
                    local di = jA.correction.last_dir or cp
                    local hl = (B and B.math and B.math.clamp or math.clamp)(dU * 60 * 0.18, 0, 1)
                    local jI = di:Lerp(cp, hl)
                    jA.correction.last_dir = jI
                    return jI.Magnitude > 1e-3 and jI.Unit or cp
                end
                return cp
            end
            local jJ = B and B.table and B.table.find or table.find
            local jK = B and B.table and B.table.insert or table.insert
            for bG in pairs(SpeedMethods) do
                if not jJ(jB, bG) then
                    jK(jB, bG)
                end
            end
            local function jL()
                local fK = i.Character and i.Character:FindFirstChildOfClass("Humanoid")
                if not fK then
                    return B.Vector3.new(0, 0, 0)
                end
                return fK.MoveDirection
            end
            local function jM()
                if jA.connection and jA.connection.Connected then
                    return
                end
                if not (B and B.run) then
                    if g and g["Debug"] then
                        warn("[SpeedHack] RunService missing; abort start")
                    end
                    return
                end
                if not i then
                    return
                end
                jA.connection =
                    B.run.Heartbeat:Connect(
                    function(dU)
                        if not (jA.enabled and jA.active) then
                            return
                        end
                        local eF = i.Character
                        local fK = eF and eF:FindFirstChildOfClass("Humanoid")
                        local bw = eF and eF:FindFirstChild("HumanoidRootPart")
                        if not (fK and bw) then
                            return
                        end
                        local jN = SpeedMethods[jA.method]
                        if jN then
                            local jE = fK.MoveDirection or B.Vector3.new(0, 0, 0)
                            jE = jH(jE, dU, bw, fK)
                            jN(jA.options, jE, dU)
                        end
                    end
                )
                if g and g["Debug"] then
                    print("[SpeedHack] started (", jA.method, ")")
                end
            end
            local function jO()
                if jA.connection then
                    pcall(
                        function()
                            if jA.connection.Connected then
                                jA.connection:Disconnect()
                            end
                        end
                    )
                    jA.connection = nil
                    if g and g["Debug"] then
                        print("[SpeedHack] stopped")
                    end
                end
            end
            local jP =
                jz:toggle(
                {name = "Speed", flag = "SpeedHack_Toggle", default = false, callback = function(dx)
                        jA.enabled = dx
                        if dx then
                            jM()
                        else
                            jO()
                        end
                        if g and g["Debug"] then
                            print("[SpeedHack] enabled:", dx)
                        end
                    end}
            )
            if g then
                g["SpeedHack_Active"] = jA.active or false
            end
            local jQ =
                jP:keybind(
                {name = "Speed", flag = "SpeedHack_Keybind", default = "v", callback = function()
                        jA.active = not jA.active
                        if g then
                            g["SpeedHack_Active"] = jA.active
                        end
                        if a and a.update_dependencies then
                            a:update_dependencies()
                        end
                        if g and g["Debug"] then
                            print("[SpeedHack] active:", jA.active)
                        end
                    end}
            )
            local jR = jz:dependency_box()
            jR:setup_dependencies({{jP, true}})
            jR:textbox(
                {name = "Speed", flag = "SpeedHack_Value", default = "16", placeholder = "16", callback = function(dx)
                        local cL = tonumber(dx) or 16
                        jA.options.Value.Value = cL
                    end}
            )
            jR:dropdown(
                {name = "Method", flag = "SpeedHack_Method", items = jB, default = "Velocity", callback = function(dx)
                        jA.method = dx
                        if a and a.update_dependencies then
                            a:update_dependencies()
                        end
                    end}
            )
            jR:dropdown(
                {name = "MoveFix", flag = "SpeedHack_MoveFix", items = jC, default = "None", callback = function(dx)
                        jA.correction.mode = dx
                        jA.correction.last_dir = nil
                    end}
            )
            local jS = jz:dependency_box()
            jS:setup_dependencies({{jP, true}})
            jS:toggle(
                {name = "WallCheck", flag = "SpeedHack_WallCheck", default = false, callback = function(dx)
                        jA.options.WallCheck.Enabled = dx
                    end}
            )
            local jT = jz:dependency_box()
            jT:setup_dependencies({{jP, true}, {"SpeedHack_Method", "TP"}})
            jT:slider(
                {
                    name = "TPFreq",
                    flag = "SpeedHack_TPFreq",
                    min = 0.05,
                    max = 1,
                    default = 0.1,
                    decimals = 2,
                    callback = function(dx)
                        jA.options.TPFrequency.Value = dx
                    end
                }
            )
            local jU = jz:dependency_box()
            jU:setup_dependencies({{jP, true}, {"SpeedHack_Method", "Pulse"}})
            jU:slider(
                {
                    name = "PulseLen",
                    flag = "SpeedHack_PulseLen",
                    min = 0.1,
                    max = 5,
                    default = 0.5,
                    decimals = 1,
                    callback = function(dx)
                        jA.options.PulseLength.Value = dx
                    end
                }
            )
            jU:slider(
                {
                    name = "PulseDly",
                    flag = "SpeedHack_PulseDly",
                    min = 0.1,
                    max = 1,
                    default = 0.2,
                    decimals = 2,
                    callback = function(dx)
                        jA.options.PulseDelay.Value = dx
                    end
                }
            )
            local function jV(a3)
                if B and B.run then
                    B.run.Heartbeat:Wait()
                end
                jA.active = false
                if g then
                    g["SpeedHack_Active"] = false
                end
                if a and a.update_dependencies then
                    a:update_dependencies()
                end
                jO()
                if jA.enabled then
                    jM()
                end
                local aA = a3 and a3:FindFirstChildOfClass("Humanoid")
                if aA then
                    if jA._died_conn then
                        pcall(
                            function()
                                jA._died_conn:Disconnect()
                            end
                        )
                    end
                    jA._died_conn =
                        aA.Died:Connect(
                        function()
                            if g and g["Debug"] then
                                print("[SpeedHack] died -> reset active & stop")
                            end
                            jA.active = false
                            if g then
                                g["SpeedHack_Active"] = false
                            end
                            if a and a.update_dependencies then
                                a:update_dependencies()
                            end
                            jO()
                        end
                    )
                end
            end
            if i then
                if i.Character then
                    jV(i.Character)
                end
                if jA._char_added then
                    pcall(
                        function()
                            jA._char_added:Disconnect()
                        end
                    )
                end
                jA._char_added =
                    i.CharacterAdded:Connect(
                    function(a3)
                        if g and g["Debug"] then
                            print("[SpeedHack] CharacterAdded")
                        end
                        jV(a3)
                    end
                )
                if jA._char_removing then
                    pcall(
                        function()
                            jA._char_removing:Disconnect()
                        end
                    )
                end
                jA._char_removing =
                    i.CharacterRemoving:Connect(
                    function()
                        if g and g["Debug"] then
                            print("[SpeedHack] CharacterRemoving")
                        end
                        jA.active = false
                        if g then
                            g["SpeedHack_Active"] = false
                        end
                        if a and a.update_dependencies then
                            a:update_dependencies()
                        end
                        jO()
                    end
                )
            end
            local jW = {enabled = false, active = false, connection = nil, options = {Speed = {Value = 1.5}}}
            local function jX(a0, bN, bO)
                local jY = B and B.Vector3 and B.Vector3.new or Vector3 and Vector3.new
                return jY and jY(a0, bN, bO) or nil
            end
            local function jZ(eq, state)
                if not eq then
                    return
                end
                for bc, bg in ipairs(eq:GetDescendants()) do
                    if bg:IsA("BasePart") then
                        if state then
                            if bg:GetAttribute("OriginalCollision") == nil then
                                bg:SetAttribute("OriginalCollision", bg.CanCollide)
                                bg:SetAttribute("OriginalTouch", bg.CanTouch)
                                bg:SetAttribute("OriginalQuery", bg.CanQuery)
                            end
                            bg.CanCollide, bg.CanTouch, bg.CanQuery = false, false, false
                        else
                            if bg:GetAttribute("OriginalCollision") ~= nil then
                                bg.CanCollide = bg:GetAttribute("OriginalCollision")
                                bg.CanTouch = bg:GetAttribute("OriginalTouch")
                                bg.CanQuery = bg:GetAttribute("OriginalQuery")
                                bg:SetAttribute("OriginalCollision", nil)
                                bg:SetAttribute("OriginalTouch", nil)
                                bg:SetAttribute("OriginalQuery", nil)
                            end
                        end
                    end
                end
            end
            local function j_()
                if jW.connection and jW.connection.Connected then
                    return
                end
                if not (B and B.run) then
                    return
                end
                jW.connection =
                    B.run.Stepped:Connect(
                    function()
                        if not (jW.enabled and jW.active) then
                            return
                        end
                        local a3 = i and i.Character
                        if not a3 then
                            return
                        end
                        jZ(a3, true)
                        local bd = a3:FindFirstChild("HumanoidRootPart")
                        local aA = a3:FindFirstChildOfClass("Humanoid")
                        if not (bd and aA) then
                            return
                        end
                        local cV = (jW.options.Speed.Value or 1.5) * 50
                        local k0 = jX(0, 0, 0)
                        local e2 = B and B.uis or game:GetService("UserInputService")
                        local k1 = B and B.cam or workspace and workspace.CurrentCamera
                        if not e2 or not k1 then
                            return
                        end
                        if e2:IsKeyDown(Enum.KeyCode.Space) then
                            k0 = k0 + jX(0, cV, 0)
                        end
                        if e2:IsKeyDown(Enum.KeyCode.LeftControl) then
                            k0 = k0 + jX(0, -cV, 0)
                        end
                        if e2:IsKeyDown(Enum.KeyCode.W) then
                            k0 = k0 + k1.CFrame.LookVector * cV
                        end
                        if e2:IsKeyDown(Enum.KeyCode.S) then
                            k0 = k0 + k1.CFrame.LookVector * -cV
                        end
                        if e2:IsKeyDown(Enum.KeyCode.D) then
                            k0 = k0 + k1.CFrame.RightVector * cV
                        end
                        if e2:IsKeyDown(Enum.KeyCode.A) then
                            k0 = k0 + k1.CFrame.RightVector * -cV
                        end
                        bd.Velocity = k0
                        pcall(
                            function()
                                aA:ChangeState(Enum.HumanoidStateType.Freefall)
                            end
                        )
                    end
                )
                if g and g["Debug"] then
                    print("[FlyHack] started")
                end
            end
            local function k2()
                if jW.connection then
                    pcall(
                        function()
                            if jW.connection.Connected then
                                jW.connection:Disconnect()
                            end
                        end
                    )
                    jW.connection = nil
                end
                local a3 = i and i.Character
                jZ(a3, false)
                if a3 then
                    local bd = a3:FindFirstChild("HumanoidRootPart")
                    local aA = a3:FindFirstChildOfClass("Humanoid")
                    if bd then
                        bd.Velocity = jX(0, -2, 0)
                        local k3
                        k3 =
                            (B and B.run and B.run.Stepped or game:GetService("RunService").Stepped):Connect(
                            function()
                                if not bd or not bd.Parent then
                                    if k3 and k3.Connected then
                                        k3:Disconnect()
                                    end
                                    return
                                end
                                bd.Velocity = jX(0, bd.Velocity.Y, 0)
                                if k3 and k3.Connected then
                                    k3:Disconnect()
                                end
                            end
                        )
                    end
                    if aA then
                        pcall(
                            function()
                                aA:ChangeState(Enum.HumanoidStateType.Landing)
                            end
                        )
                    end
                end
                if g and g["Debug"] then
                    print("[FlyHack] stopped")
                end
            end
            local function k4()
                local a3 = i and i.Character
                jZ(a3, false)
                if not a3 then
                    return
                end
                local bd = a3:FindFirstChild("HumanoidRootPart")
                local aA = a3:FindFirstChildOfClass("Humanoid")
                if bd then
                    pcall(
                        function()
                            bd.AssemblyLinearVelocity = jX(0, 0, 0)
                        end
                    )
                    pcall(
                        function()
                            bd.AssemblyAngularVelocity = jX(0, 0, 0)
                        end
                    )
                    bd.Velocity = jX(0, -2, 0)
                    local k3
                    k3 =
                        (B and B.run and B.run.Stepped or game:GetService("RunService").Stepped):Connect(
                        function()
                            if not bd or not bd.Parent then
                                if k3 and k3.Connected then
                                    k3:Disconnect()
                                end
                                return
                            end
                            local gT = bd.Velocity.Y
                            pcall(
                                function()
                                    bd.AssemblyLinearVelocity = jX(0, gT, 0)
                                end
                            )
                            bd.Velocity = jX(0, gT, 0)
                            if k3 and k3.Connected then
                                k3:Disconnect()
                            end
                        end
                    )
                end
                if aA then
                    pcall(
                        function()
                            aA:ChangeState(Enum.HumanoidStateType.Landing)
                        end
                    )
                end
                if g and g["Debug"] then
                    print("[FlyHack] soft-stopped (keybind)")
                end
            end
            local k5 =
                jz:toggle(
                {name = "Flight", flag = "FlyHack_Toggle", default = false, callback = function(dx)
                        jW.enabled = dx
                        if dx then
                            j_()
                        else
                            k2()
                        end
                        if g and g["Debug"] then
                            print("[FlyHack] enabled:", dx)
                        end
                    end}
            )
            if g then
                g["FlyHack_Active"] = jW.active or false
            end
            local k6 =
                k5:keybind(
                {name = "Flight", flag = "FlyHack_Keybind", default = "b", callback = function()
                        jW.active = not jW.active
                        if not jW.active then
                            k4()
                        end
                        if g then
                            g["FlyHack_Active"] = jW.active
                        end
                        if a and a.update_dependencies then
                            a:update_dependencies()
                        end
                        if g and g["Debug"] then
                            print("[FlyHack] active:", jW.active)
                        end
                    end}
            )
            local k7 = jz:dependency_box()
            k7:setup_dependencies({{k5, true}})
            k7:textbox(
                {
                    name = "Spd",
                    flag = "FlyHack_Speed",
                    default = tostring(jW.options.Speed.Value or 1.5),
                    callback = function(cc)
                        local k8 = tonumber(cc)
                        if k8 then
                            jW.options.Speed.Value = k8
                        end
                    end
                }
            )
            local function k9(a3)
                if B and B.run then
                    B.run.Heartbeat:Wait()
                end
                jW.active = false
                if g then
                    g["FlyHack_Active"] = false
                end
                if a and a.update_dependencies then
                    a:update_dependencies()
                end
                k2()
                if jW.enabled then
                    j_()
                end
                local aA = a3 and a3:FindFirstChildOfClass("Humanoid")
                if aA then
                    if jW._died_conn then
                        pcall(
                            function()
                                jW._died_conn:Disconnect()
                            end
                        )
                    end
                    jW._died_conn =
                        aA.Died:Connect(
                        function()
                            if g and g["Debug"] then
                                print("[FlyHack] died -> reset active & stop")
                            end
                            jW.active = false
                            if g then
                                g["FlyHack_Active"] = false
                            end
                            if a and a.update_dependencies then
                                a:update_dependencies()
                            end
                            k2()
                        end
                    )
                end
            end
            if i then
                if i.Character then
                    k9(i.Character)
                end
                if jW._char_added then
                    pcall(
                        function()
                            jW._char_added:Disconnect()
                        end
                    )
                end
                jW._char_added =
                    i.CharacterAdded:Connect(
                    function(a3)
                        if g and g["Debug"] then
                            print("[FlyHack] CharacterAdded")
                        end
                        k9(a3)
                    end
                )
                if jW._char_removing then
                    pcall(
                        function()
                            jW._char_removing:Disconnect()
                        end
                    )
                end
                jW._char_removing =
                    i.CharacterRemoving:Connect(
                    function()
                        if g and g["Debug"] then
                            print("[FlyHack] CharacterRemoving")
                        end
                        jW.active = false
                        if g then
                            g["FlyHack_Active"] = false
                        end
                        if a and a.update_dependencies then
                            a:update_dependencies()
                        end
                        k2()
                    end
                )
            end
            -- Slide distance override start
            do
                local sl = {enabled = false, distance = 100, _conn = nil, _char_added = nil, _char_removing = nil, _hbConn = nil}
                local function isSlideBodyVelocity(bv)
                    -- Heuristic match for Slide script BV: planar MaxForce, zero Y, initial mag ~100
                    local mf = bv.MaxForce
                    local v = bv.Velocity
                    local planarMF = (math.abs(mf.X - 50000) < 1e-3) and (math.abs(mf.Z - 50000) < 1e-3) and (math.abs(mf.Y) < 1e-3)
                    local planarVY = math.abs(v.Y) < 1e-3
                    return planarMF and planarVY
                end
                local function attachChar(char)
                    if not char then return end
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    if not hrp then return end
                    if sl._conn then pcall(function() if sl._conn.Connected then sl._conn:Disconnect() end end) end
                    sl._conn = hrp.ChildAdded:Connect(function(inst)
                        if not sl.enabled then return end
                        if not (inst and inst:IsA("BodyVelocity")) then return end
                        if not isSlideBodyVelocity(inst) then return end
                        local root = hrp
                        local look = root.CFrame.LookVector
                        local mag = tonumber(sl.distance) or 100
                        pcall(function()
                            inst.Velocity = look * mag
                        end)
                    end)
                end
                local function detach()
                    if sl._conn then
                        pcall(function() if sl._conn.Connected then sl._conn:Disconnect() end end)
                        sl._conn = nil
                    end
                end
                if i then
                    if i.Character then attachChar(i.Character) end
                    if sl._char_added then pcall(function() sl._char_added:Disconnect() end) end
                    sl._char_added = i.CharacterAdded:Connect(function(ch)
                        attachChar(ch)
                    end)
                    if sl._char_removing then pcall(function() sl._char_removing:Disconnect() end) end
                    sl._char_removing = i.CharacterRemoving:Connect(function()
                        detach()
                    end)
                end
                local tg = jz:toggle({name = "SlideDist", flag = "SlideDist_Toggle", default = false, callback = function(state)
                        sl.enabled = state
                    end})
                local bx = jz:dependency_box()
                bx:setup_dependencies({{tg, true}})
                bx:slider({
                    name = "Dist",
                    flag = "SlideDist_Value",
                    min = 50,
                    max = 300,
                    default = sl.distance,
                    interval = 5,
                    callback = function(val)
                        sl.distance = tonumber(val) or sl.distance
                    end
                })
            end
            -- Slide distance override end
            do
                local ka = B and B.workspace or workspace
                local kb = B and B.run or game:GetService("RunService")
                local kc = B and B.uis or game:GetService("UserInputService")
                local cn = B and (B.camera or B.cam) or ka and ka.CurrentCamera
                local kd =
                    B and B.RaycastParams and B.RaycastParams.new and B.RaycastParams.new() or RaycastParams.new()
                kd.RespectCanCollide = true
                local ke = {
                    enabled = false,
                    connection = nil,
                    _ib = nil,
                    _ie = nil,
                    _died_conn = nil,
                    _char_added = nil,
                    _char_removing = nil,
                    shift_down = false,
                    active = false,
                    mode = "Velocity",
                    value = 20,
                    state_enabled = true,
                    truss = nil,
                    rp = kd
                }
                local function kf(kg)
                    if not ke.truss then
                        local bP = Instance.new("TrussPart")
                        bP.Size = Vector3.new(2, 2, 2)
                        bP.Transparency = 1
                        bP.Anchored = true
                        ke.truss = bP
                    end
                    ke.truss.Parent = ke.enabled and kg or nil
                end
                local function kh()
                    local bP = ke.truss
                    if bP then
                        pcall(
                            function()
                                bP:Destroy()
                            end
                        )
                    end
                    ke.truss = nil
                end
                local function ki()
                    if ke.connection and ke.connection.Connected then
                        return
                    end
                    local kj = kb and (kb.PreSimulation or kb.Stepped or kb.Heartbeat)
                    ke.connection =
                        kj:Connect(
                        function(dU)
                            if not ke.enabled then
                                return
                            end
                            local a3 = i and i.Character
                            local aA = a3 and a3:FindFirstChildOfClass("Humanoid")
                            local bw = a3 and a3:FindFirstChild("HumanoidRootPart")
                            if not (aA and bw) then
                                return
                            end
                            local kk = {cn, a3, ke.truss}
                            if ke.rp then
                                ke.rp.FilterDescendantsInstances = kk
                                pcall(
                                    function()
                                        ke.rp.CollisionGroup = bw.CollisionGroup
                                    end
                                )
                            end
                            local kl =
                                kc and (kc:IsKeyDown(Enum.KeyCode.LeftShift) or kc:IsKeyDown(Enum.KeyCode.RightShift)) or
                                ke.shift_down
                            if kl then
                                ke.active = false
                                return
                            end
                            if ke.mode ~= "Climbing" then
                                local km = aA.MoveDirection
                                if km.Magnitude < 0.05 then
                                    ke.active = false
                                    return
                                end
                                local co = bw.Position - Vector3.new(0, (aA.HipHeight or 2) - 0.5, 0)
                                local er = km.Unit * 1
                                local jG = ka:Raycast(co, er, ke.rp)
                                if ke.active and not jG then
                                    pcall(
                                        function()
                                            local cc = bw.AssemblyLinearVelocity
                                            bw.AssemblyLinearVelocity = Vector3.new(cc.X, 0, cc.Z)
                                        end
                                    )
                                end
                                ke.active = jG ~= nil
                                if ke.active and jG.Normal.Y == 0 then
                                    if ke.state_enabled then
                                        pcall(
                                            function()
                                                aA:ChangeState(Enum.HumanoidStateType.Climbing)
                                            end
                                        )
                                    end
                                    pcall(
                                        function()
                                            local eu = bw.AssemblyLinearVelocity
                                            bw.AssemblyLinearVelocity = Vector3.new(eu.X, 0, eu.Z)
                                        end
                                    )
                                    if ke.mode == "CFrame" then
                                        bw.CFrame = bw.CFrame * CFrame.new(0, ke.value * dU, 0)
                                    elseif ke.mode == "Impulse" then
                                        bw:ApplyImpulse(Vector3.new(0, ke.value, 0) * bw.AssemblyMass)
                                    else
                                        pcall(
                                            function()
                                                local eu = bw.AssemblyLinearVelocity
                                                bw.AssemblyLinearVelocity = eu + Vector3.new(0, ke.value, 0)
                                            end
                                        )
                                    end
                                end
                            else
                                local co = bw.Position - Vector3.new(0, (aA.HipHeight or 2) - 0.5, 0)
                                local er = bw.CFrame.LookVector * 1
                                local jG = ka:Raycast(co, er, ke.rp)
                                if jG and not kl then
                                    kf(cn)
                                    local bh = jG.Position - jG.Normal * 0.9
                                    ke.truss.Position = bh or Vector3.new(0, 0, 0)
                                else
                                    if ke.truss then
                                        ke.truss.Position = Vector3.new(0, 0, 0)
                                    end
                                end
                            end
                        end
                    )
                    if not (ke._ib and ke._ib.Connected) then
                        ke._ib =
                            kc.InputBegan:Connect(
                            function(eZ, kn)
                                if kn then
                                    return
                                end
                                if eZ.KeyCode == Enum.KeyCode.LeftShift or eZ.KeyCode == Enum.KeyCode.RightShift then
                                    ke.shift_down = true
                                end
                            end
                        )
                    end
                    if not (ke._ie and ke._ie.Connected) then
                        ke._ie =
                            kc.InputEnded:Connect(
                            function(eZ)
                                if eZ.KeyCode == Enum.KeyCode.LeftShift or eZ.KeyCode == Enum.KeyCode.RightShift then
                                    ke.shift_down = false
                                end
                            end
                        )
                    end
                    if ke.mode == "Climbing" then
                        kf(cn)
                    else
                        kh()
                    end
                end
                local function ko()
                    if ke.connection then
                        pcall(
                            function()
                                if ke.connection.Connected then
                                    ke.connection:Disconnect()
                                end
                            end
                        )
                        ke.connection = nil
                    end
                    if ke._ib then
                        pcall(
                            function()
                                ke._ib:Disconnect()
                            end
                        )
                        ke._ib = nil
                    end
                    if ke._ie then
                        pcall(
                            function()
                                ke._ie:Disconnect()
                            end
                        )
                        ke._ie = nil
                    end
                    if ke._died_conn then
                        pcall(
                            function()
                                ke._died_conn:Disconnect()
                            end
                        )
                        ke._died_conn = nil
                    end
                    ke.shift_down = false
                    ke.active = false
                    kh()
                end
                local kp =
                    jz:toggle(
                    {name = "Spider", flag = "Spider_Toggle", default = false, callback = function(cc)
                            ke.enabled = cc
                            if cc then
                                ki()
                            else
                                ko()
                            end
                            if a and a.update_dependencies then
                                a:update_dependencies()
                            end
                        end}
                )
                local kq = jz:dependency_box()
                kq:setup_dependencies({{kp, true}})
                kq:dropdown(
                    {
                        name = "Mode",
                        flag = "Spider_Mode",
                        items = {"Velocity", "Impulse", "CFrame", "Climbing"},
                        default = ke.mode,
                        callback = function(dx)
                            ke.mode = dx
                            local kr = dx ~= "Climbing"
                            if g then
                                g["Spider_ShowControls"] = kr
                            end
                            if ke.enabled then
                                if dx == "Climbing" then
                                    kf(cn)
                                else
                                    kh()
                                end
                            end
                            if a and a.update_dependencies then
                                a:update_dependencies()
                            end
                        end
                    }
                )
                if g and g["Spider_ShowControls"] == nil then
                    g["Spider_ShowControls"] = true
                end
                local ks = jz:dependency_box()
                ks:setup_dependencies({{kp, true}, {"Spider_ShowControls", true}})
                ks:slider(
                    {
                        name = "Val",
                        flag = "Spider_Val",
                        min = 1,
                        max = 100,
                        default = ke.value,
                        decimals = 0,
                        callback = function(dx)
                            ke.value = dx
                        end
                    }
                )
                ks:toggle(
                    {name = "State", flag = "Spider_State", default = ke.state_enabled, callback = function(cc)
                            ke.state_enabled = cc
                        end}
                )
                local function kt(a3)
                    if kb and kb.Heartbeat then
                        kb.Heartbeat:Wait()
                    end
                    ko()
                    if ke.enabled then
                        ki()
                    end
                    local aA = a3 and a3:FindFirstChildOfClass("Humanoid")
                    if aA then
                        if ke._died_conn then
                            pcall(
                                function()
                                    ke._died_conn:Disconnect()
                                end
                            )
                        end
                        ke._died_conn =
                            aA.Died:Connect(
                            function()
                                ko()
                            end
                        )
                    end
                end
                if i then
                    if i.Character then
                        kt(i.Character)
                    end
                    if ke._char_added then
                        pcall(
                            function()
                                ke._char_added:Disconnect()
                            end
                        )
                    end
                    ke._char_added =
                        i.CharacterAdded:Connect(
                        function(a3)
                            kt(a3)
                        end
                    )
                    if ke._char_removing then
                        pcall(
                            function()
                                ke._char_removing:Disconnect()
                            end
                        )
                    end
                    ke._char_removing =
                        i.CharacterRemoving:Connect(
                        function()
                            ko()
                        end
                    )
                end
            end
            do
                local ka = B and B.workspace or workspace
                local kb = B and B.run or game:GetService("RunService")
                local function jX(a0, bN, bO)
                    local jY = B and B.Vector3 and B.Vector3.new or Vector3 and Vector3.new
                    return jY and jY(a0, bN, bO) or nil
                end
                local ku = {
                    enabled = false,
                    mode = "Workspace",
                    value = 196.2,
                    connection = nil,
                    prop_conn = nil,
                    changed = false,
                    original = nil
                }
                local function kv(kw)
                    pcall(
                        function()
                            if kw and kw.Connected then
                                kw:Disconnect()
                            end
                        end
                    )
                end
                local function kx(dx)
                    if not ka then
                        return
                    end
                    ku.changed = true
                    ka.Gravity = dx
                    ku.changed = false
                end
                local function ky()
                    if not (kb and ka) then
                        return
                    end
                    if ku.original == nil then
                        ku.original = ka.Gravity
                    end
                    kv(ku.connection)
                    ku.connection = nil
                    kv(ku.prop_conn)
                    ku.prop_conn = nil
                    if ku.mode == "Workspace" then
                        kx(ku.value)
                        ku.prop_conn =
                            ka:GetPropertyChangedSignal("Gravity"):Connect(
                            function()
                                if ku.changed then
                                    return
                                end
                                kx(ku.value)
                            end
                        )
                    else
                        local kj = kb.PreSimulation or kb.Stepped
                        ku.connection =
                            kj:Connect(
                            function(dU)
                                if not ku.enabled then
                                    return
                                end
                                local a3 = i and i.Character
                                local aA = a3 and a3:FindFirstChildOfClass("Humanoid")
                                local bw = a3 and a3:FindFirstChild("HumanoidRootPart")
                                if not (aA and bw) then
                                    return
                                end
                                if aA.FloorMaterial == Enum.Material.Air then
                                    local gM = ka.Gravity - ku.value
                                    if ku.mode == "Impulse" then
                                        bw:ApplyImpulse(jX(0, dU * gM, 0) * bw.AssemblyMass)
                                    else
                                        local kz = jX(0, dU * gM, 0)
                                        pcall(
                                            function()
                                                bw.AssemblyLinearVelocity = bw.AssemblyLinearVelocity + kz
                                            end
                                        )
                                    end
                                end
                            end
                        )
                    end
                end
                local function kA()
                    kv(ku.connection)
                    ku.connection = nil
                    kv(ku.prop_conn)
                    ku.prop_conn = nil
                    if ku.original ~= nil and ka then
                        pcall(
                            function()
                                ka.Gravity = ku.original
                            end
                        )
                    end
                end
                local kB =
                    jz:toggle(
                    {name = "Gravity", flag = "Gravity_Toggle", default = false, callback = function(dx)
                            ku.enabled = dx
                            if dx then
                                ky()
                            else
                                kA()
                            end
                        end}
                )
                local kC = jz:dependency_box()
                kC:setup_dependencies({{kB, true}})
                kC:dropdown(
                    {
                        name = "Mode",
                        flag = "Gravity_Mode",
                        items = {"Workspace", "Impulse", "LinearVelocity"},
                        default = "Workspace",
                        callback = function(cc)
                            ku.mode = cc
                            if ku.enabled then
                                kA()
                                ky()
                            end
                        end
                    }
                )
                kC:slider(
                    {
                        name = "Grv",
                        flag = "Gravity_Value",
                        min = 0,
                        max = 400,
                        default = 196.2,
                        decimals = 1,
                        callback = function(dx)
                            ku.value = dx
                            if ku.enabled and ku.mode == "Workspace" then
                                kx(ku.value)
                            end
                        end
                    }
                )
            end
            do
                local kD = {enabled = false, connection = nil, min = 16}
                local kE =
                    jz:toggle(
                    {
                        name = "NoSlow",
                        flag = "NoSlow_Toggle",
                        default = false,
                        callback = function(dx)
                            kD.enabled = dx
                            if dx then
                                local kF = B and B.rs or game:GetService("RunService")
                                if not (kD.connection and kD.connection.Connected) then
                                    kD.connection =
                                        kF.Heartbeat:Connect(
                                        function()
                                            local a3 = i and i.Character
                                            if not a3 then
                                                return
                                            end
                                            local aA = a3:FindFirstChildOfClass("Humanoid")
                                            if not aA then
                                                return
                                            end
                                            local bw = aA.RootPart or a3:FindFirstChild("HumanoidRootPart")
                                            if not bw then
                                                return
                                            end
                                            local cp = aA.MoveDirection
                                            if cp.Magnitude > 0 then
                                                local eu = bw.AssemblyLinearVelocity
                                                local kG = Vector3.new(eu.X, 0, eu.Z).Magnitude
                                                if kG + 1e-3 < kD.min then
                                                    local kH = cp.Unit
                                                    bw.AssemblyLinearVelocity =
                                                        Vector3.new(kH.X * kD.min, eu.Y, kH.Z * kD.min)
                                                end
                                            end
                                        end
                                    )
                                end
                            else
                                if kD.connection then
                                    pcall(
                                        function()
                                            kD.connection:Disconnect()
                                        end
                                    )
                                    kD.connection = nil
                                end
                            end
                        end
                    }
                )
            end
            do
                local kc = B and B.uis or game:GetService("UserInputService")
                local kb = B and B.run or game:GetService("RunService")
                local ka = B and B.workspace or workspace
                local kI = {enabled = false, mode = "Velocity", power = 50, connection = nil}
                local function kJ()
                    local a3 = i and i.Character
                    local aA = a3 and a3:FindFirstChildOfClass("Humanoid")
                    if not aA then
                        return
                    end
                    local state = aA:GetState()
                    if state ~= Enum.HumanoidStateType.Running and state ~= Enum.HumanoidStateType.Landed then
                        return
                    end
                    local kK = tonumber(kI.power) or 50
                    pcall(
                        function()
                            if aA.UseJumpPower ~= false then
                                aA.JumpPower = kK
                            else
                                aA.JumpHeight = math.max(1, kK / 7)
                            end
                            aA:ChangeState(Enum.HumanoidStateType.Jumping)
                        end
                    )
                end
                local function kL()
                    if kI.connection and kI.connection.Connected then
                        return
                    end
                    kI.connection =
                        kb.RenderStepped:Connect(
                        function()
                            if not kI.enabled then
                                return
                            end
                            if kc:GetFocusedTextBox() then
                                return
                            end
                            if kc:IsKeyDown(Enum.KeyCode.Space) then
                                kJ()
                            end
                        end
                    )
                end
                local function kM()
                    if kI.connection then
                        pcall(
                            function()
                                if kI.connection.Connected then
                                    kI.connection:Disconnect()
                                end
                            end
                        )
                        kI.connection = nil
                    end
                end
                local kN =
                    jz:toggle(
                    {name = "HighJump", flag = "HighJump_Toggle", default = false, callback = function(cc)
                            kI.enabled = cc
                            if cc then
                                kL()
                            else
                                kM()
                            end
                            if a and a.update_dependencies then
                                a:update_dependencies()
                            end
                        end}
                )
                local kO = jz:dependency_box()
                kO:setup_dependencies({{kN, true}})
                kO:dropdown(
                    {
                        name = "Mode",
                        flag = "HighJump_Mode",
                        items = {"Impulse", "Velocity", "CFrame", "Instant"},
                        default = kI.mode,
                        callback = function(dx)
                            kI.mode = dx
                        end
                    }
                )
                kO:textbox(
                    {name = "Pwr", flag = "HighJump_Power", default = tostring(kI.power), callback = function(fM)
                            local k8 = tonumber(fM)
                            if not k8 then
                                return
                            end
                            if k8 < 1 then
                                k8 = 1
                            end
                            if k8 > 300 then
                                k8 = 300
                            end
                            kI.power = k8
                        end}
                )
            end
            do
                local kP = {enabled = false, hooked = false, old = nil, conn = nil, baselineJP = nil, baselineJH = nil}
                local function kQ()
                    local dE, kR =
                        pcall(
                        function()
                            return game and game.IsLoaded and (game.IsLoaded(game) or game:IsLoaded())
                        end
                    )
                    if not dE or not kR then
                        pcall(
                            function()
                                if game and game.Loaded then
                                    if game.Loaded.Wait then
                                        game.Loaded.Wait(game.Loaded)
                                    else
                                        game.Loaded:Wait()
                                    end
                                end
                            end
                        )
                    end
                end
                local function kS()
                    if kP.hooked then
                        return
                    end
                    if type(hookmetamethod) ~= "function" then
                        return
                    end
                    local kT =
                        game and game.IsA or
                        function(ci, kU)
                            local dE, kV =
                                pcall(
                                function()
                                    return ci and ci.IsA and ci:IsA(kU)
                                end
                            )
                            return dE and kV or false
                        end
                    local kW
                    local function kX(self, kY, kZ)
                        local k_ = false
                        if type(checkcaller) == "function" then
                            k_ = not checkcaller()
                        end
                        if kP.enabled and k_ and kY == "JumpPower" and kT(self, "Humanoid") then
                            return
                        end
                        if not kW then
                            return
                        end
                        return kW(self, kY, kZ)
                    end
                    local l0 = type(newcclosure) == "function" and newcclosure(kX) or kX
                    local dE, l1 =
                        pcall(
                        function()
                            return hookmetamethod(game, "__newindex", l0)
                        end
                    )
                    if dE and l1 then
                        kW = l1
                        kP.old = l1
                        kP.hooked = true
                    end
                end
                local function l2()
                    local kF = B and B.rs or game:GetService("RunService")
                    if kP.conn and kP.conn.Connected then
                        return
                    end
                    kP.conn =
                        kF.Heartbeat:Connect(
                        function()
                            local a3 = i and i.Character
                            if not a3 then
                                return
                            end
                            local aA = a3:FindFirstChildOfClass("Humanoid")
                            if not aA then
                                return
                            end
                            if not kP.baselineJP then
                                kP.baselineJP = tonumber(aA.JumpPower) or 50
                            end
                            if not kP.baselineJH then
                                kP.baselineJH = tonumber(aA.JumpHeight) or 7.2
                            end
                            local l3 =
                                pcall(
                                function()
                                    if aA.UseJumpPower ~= false then
                                        if aA.JumpPower < kP.baselineJP then
                                            aA.JumpPower = kP.baselineJP
                                        end
                                    else
                                        if aA.JumpHeight < kP.baselineJH then
                                            aA.JumpHeight = kP.baselineJH
                                        end
                                    end
                                end
                            )
                            if not l3 then
                                return
                            end
                        end
                    )
                end
                local function l4()
                    if kP.conn then
                        pcall(
                            function()
                                kP.conn:Disconnect()
                            end
                        )
                        kP.conn = nil
                    end
                end
                local l5 =
                    jz:toggle(
                    {name = "NoJumpCooldown", flag = "NoJumpCooldown_Toggle", default = false, callback = function(dx)
                            kP.enabled = dx
                            if dx then
                                kQ()
                                kS()
                                if not kP.hooked then
                                    l2()
                                else
                                    l4()
                                end
                            else
                                l4()
                            end
                        end}
                )
            end
            do
                local kb = B and B.run or game:GetService("RunService")
                local l6 = {enabled = false, connection = nil, mode = "Velocity", value = 10}
                if l6.mode ~= "CFrame" and l6.mode ~= "Velocity" then
                    l6.mode = "Velocity"
                end
                local function l7()
                    if l6.connection and l6.connection.Connected then
                        return
                    end
                    local kj = kb and (kb.PreSimulation or kb.Stepped or kb.Heartbeat)
                    l6.connection =
                        kj:Connect(
                        function(dU)
                            if not l6.enabled then
                                return
                            end
                            local a3 = i and i.Character
                            local aA = a3 and a3:FindFirstChildOfClass("Humanoid")
                            local bw = a3 and a3:FindFirstChild("HumanoidRootPart")
                            if not (aA and bw) then
                                return
                            end
                            if aA.FloorMaterial ~= Enum.Material.Air then
                                return
                            end
                            local km = aA.MoveDirection
                            if km.Magnitude < 0.05 then
                                return
                            end
                            local cp = Vector3.new(km.X, 0, km.Z)
                            if cp.Magnitude <= 0 then
                                return
                            end
                            cp = cp.Unit
                            if l6.mode == "CFrame" then
                                bw.CFrame = bw.CFrame + cp * l6.value * (dU or 0) * 10
                            else
                                pcall(
                                    function()
                                        local cc = bw.AssemblyLinearVelocity
                                        local l8 = Vector3.new(cc.X, 0, cc.Z)
                                        local ap = math.max(l8.Magnitude, (aA and aA.WalkSpeed or 16) + l6.value * 3)
                                        local l9 = cp * ap
                                        bw.AssemblyLinearVelocity = Vector3.new(l9.X, cc.Y, l9.Z)
                                    end
                                )
                            end
                        end
                    )
                end
                local function la()
                    if l6.connection then
                        pcall(
                            function()
                                if l6.connection.Connected then
                                    l6.connection:Disconnect()
                                end
                            end
                        )
                        l6.connection = nil
                    end
                end
                local lb =
                    jz:toggle(
                    {name = "Strafe", flag = "Strafe_Toggle", default = false, callback = function(cc)
                            l6.enabled = cc
                            if cc then
                                l7()
                            else
                                la()
                            end
                            if a and a.update_dependencies then
                                a:update_dependencies()
                            end
                        end}
                )
                local lc = jz:dependency_box()
                lc:setup_dependencies({{lb, true}})
                lc:dropdown(
                    {
                        name = "Mode",
                        flag = "Strafe_Mode",
                        items = {"CFrame", "Velocity"},
                        default = l6.mode,
                        callback = function(dx)
                            l6.mode = dx
                        end
                    }
                )
                lc:slider(
                    {
                        name = "Str",
                        flag = "Strafe_Strength",
                        min = 1,
                        max = 20,
                        default = 10,
                        decimals = 0,
                        callback = function(dx)
                            l6.value = dx
                        end
                    }
                )
            end
        end
        do
            local ld = u:column()
            local le = ld:section({name = "Stuff"})
            local lf = {
                enabled = false,
                delay = 4,
                type = "Toxic",
                loop = nil,
                filter_installed = false,
                prev_filter = nil,
                _msgset = nil
            }
            local lg = {
                Toxic = {
                    "you're trash, a newbie could do better",
                    "imagine dying",
                    "oops i forgot you were there, oh wait you don't even exist",
                    "ez ez you got clapped by a low level",
                    "why are you dying to me bro fr fr",
                    "clapped by Rebuild user",
                    "bro got clapped lol",
                    "imagine being fatherless, go check where yours are",
                    "sorry did my target aim hit you? if so you're trash",
                    "bro got skill issues",
                    "bozo can't even beat me",
                    "are you serious rn",
                    "ez bozo",
                    "your dad never came back from the milk store for a reason",
                    "did your mother drop you when you were born",
                    "you really need a therapist",
                    "you should go back to kindergarten bro",
                    "i'm just better than you"
                },
                Ad = {
                    "Rebuild > u",
                    "Rebuild owns you",
                    "get good get Rebuild",
                    "stop crying and get Rebuild",
                    "get Rebuild right now bro",
                    "get your aim up and get Rebuild",
                    "stop complaining and get Rebuild",
                    "Rebuild > your career",
                    "yes i know Rebuild is the best",
                    "Rebuild has more features than your grandmother",
                    "get better dude",
                    "bro just get Rebuild lol",
                    "yo 12 year old get Rebuild",
                    "Rebuild on top fr fr",
                    "Rebuild better than you smh smh smh"
                },
                Freak = {
                    "wenomechainsama tumajarbisaun",
                    "roll the ops on me then",
                    "wdym touch grass i have one of those on my feet",
                    "fortnite $19 gift card who wants it",
                    "who are you talking to? a kill say bot?",
                    "cheap microwave",
                    "i like bricks",
                    "what's up 'hackle cheatle' here guys, i've been arrested for multiple crimes including cheating",
                    "🤓: stop hacking! it's against the rules!",
                    "🤓: you can't just exploit here, it's illegal"
                }
            }
            local function lh()
                local li = {}
                local lj = lg[lf.type] or {}
                for bc, c3 in ipairs(lj) do
                    li[string.lower(c3)] = true
                end
                lf._msgset = li
            end
            local function lk()
                local dE, ll =
                    pcall(
                    function()
                        return game:GetService("TextChatService")
                    end
                )
                if not dE or not ll then
                    return nil, nil
                end
                local lm = ll:FindFirstChild("TextChannels")
                local ln = lm and lm:FindFirstChild("RBXGeneral")
                if not ln then
                    pcall(
                        function()
                            lm = ll:WaitForChild("TextChannels", 2)
                            ln = lm and lm:WaitForChild("RBXGeneral", 2)
                        end
                    )
                end
                return ll, ln
            end
            local function lo()
                if lf.filter_installed then
                    return
                end
                local ll = select(1, lk())
                if not ll then
                    return
                end
                lf.prev_filter = ll.OnIncomingMessage
                ll.OnIncomingMessage = function(bu)
                    local i = game:GetService("Players").LocalPlayer
                    local lp = false
                    if lf.hide_local and bu and bu.TextSource and i and bu.TextSource.UserId == i.UserId then
                        local lq = string.lower(tostring(bu.Text or ""))
                        if lf._msgset and lf._msgset[lq] then
                            lp = true
                        end
                    end
                    if lp then
                        return Enum.TextChatMessageStatus.Hidden
                    end
                    if lf.prev_filter then
                        local dE, kV = pcall(lf.prev_filter, bu)
                        if dE and kV ~= nil then
                            return kV
                        end
                    end
                    return Enum.TextChatMessageStatus.Displayed
                end
                lf.filter_installed = true
            end
            local function lr()
                local ll = select(1, lk())
                if not ll then
                    return
                end
                if lf.filter_installed then
                    ll.OnIncomingMessage = lf.prev_filter
                    lf.prev_filter = nil
                    lf.filter_installed = false
                end
            end
            local function ls(fM)
                local ll, lt = lk()
                if lt and lt.SendAsync then
                    pcall(
                        function()
                            lt:SendAsync(fM)
                        end
                    )
                    return
                end
                local kF = game:GetService("ReplicatedStorage")
                local lu = kF:FindFirstChild("DefaultChatSystemChatEvents")
                local lv = lu and lu:FindFirstChild("SayMessageRequest")
                if lv then
                    pcall(
                        function()
                            lv:FireServer(fM, "All")
                        end
                    )
                end
            end
            local function lw()
                if lf.loop then
                    return
                end
                lh()
                if lf.hide_local then
                    lo()
                end
                local lx = B and B.task or task
                local ly = B and B.math or math
                lf.loop =
                    lx.spawn(
                    function()
                        while lf.enabled do
                            local lj = lg[lf.type] or {}
                            if #lj > 0 then
                                local lz = ly.random(1, #lj)
                                local bu = lj[lz]
                                if lf.hide_local and lf._msgset then
                                    lf._msgset[string.lower(bu)] = true
                                end
                                ls(bu)
                            end
                            local br = tonumber(lf.delay) or 4
                            lx.wait(ly.max(2, ly.min(br, 10)))
                        end
                    end
                )
            end
            local function lA()
                if lf.loop then
                    pcall(
                        function()
                            (B and B.task or task).cancel(lf.loop)
                        end
                    )
                    lf.loop = nil
                end
                lr()
            end
            local lB =
                le:toggle(
                {name = "Enabled", flag = "ChatSpammer_Toggle", default = false, callback = function(cc)
                        lf.enabled = cc
                        if cc then
                            lw()
                        else
                            lA()
                        end
                        if a and a.update_dependencies then
                            a:update_dependencies()
                        end
                    end}
            )
            local lC = le:dependency_box()
            lC:setup_dependencies({{lB, true}})
            lC:dropdown(
                {
                    name = "Type",
                    flag = "ChatSpammer_Type",
                    items = {"Toxic", "Ad", "Freak"},
                    default = lf.type,
                    callback = function(dx)
                        lf.type = dx
                        lh()
                    end
                }
            )
            lC:slider(
                {
                    name = "Dly",
                    flag = "ChatSpammer_Delay",
                    min = 2,
                    max = 10,
                    default = 4,
                    decimals = 0,
                    callback = function(dx)
                        lf.delay = dx
                    end
                }
            )
            local lD = {enabled = false, saved_height = nil}
            do
                local dE, ka =
                    pcall(
                    function()
                        return game:GetService("Workspace")
                    end
                )
                if dE and ka then
                    lD.saved_height = ka.FallenPartsDestroyHeight
                end
            end
            local function lE(bj)
                local dE, ka =
                    pcall(
                    function()
                        return game:GetService("Workspace")
                    end
                )
                if not (dE and ka) then
                    return
                end
                if bj then
                    if lD.saved_height == nil then
                        lD.saved_height = ka.FallenPartsDestroyHeight
                    end
                    ka.FallenPartsDestroyHeight = -math.huge
                else
                    if lD.saved_height ~= nil then
                        ka.FallenPartsDestroyHeight = lD.saved_height
                    end
                end
            end
            do
                local function lF()
                    local dE, ka =
                        pcall(
                        function()
                            return game:GetService("Workspace")
                        end
                    )
                    if dE and ka and lD and lD.enabled then
                        pcall(
                            function()
                                if lD.saved_height ~= nil then
                                    ka.FallenPartsDestroyHeight = lD.saved_height
                                end
                            end
                        )
                    end
                end
                if a and a.connections and type(a.connections) == "table" then
                    table.insert(a.connections, {Disconnect = lF})
                end
            end
            le:toggle(
                {name = "AntiVoid", flag = "AntiVoid_Toggle", default = false, callback = function(cc)
                        lD.enabled = cc
                        lE(cc)
                        if a and a.update_dependencies then
                            a:update_dependencies()
                        end
                    end}
            )
            local lG = {enabled = false, method = "CframeFling", health = 20, conn = nil}
            do
                if lG.method ~= "CframeFling" and lG.method ~= "VelocityFling" then
                    lG.method = "CframeFling"
                end
            end
            local function lH()
                if lG.conn then
                    pcall(
                        function()
                            lG.conn:Disconnect()
                        end
                    )
                    lG.conn = nil
                end
            end
            do
                if a and a.connections and type(a.connections) == "table" then
                    table.insert(a.connections, {Disconnect = lH})
                end
            end
            local function lI()
                lH()
                local lJ, kF =
                    pcall(
                    function()
                        return game:GetService("RunService")
                    end
                )
                if not lJ or not kF then
                    return
                end
                lG.conn =
                    kF.Stepped:Connect(
                    function()
                        local lK, lL =
                            pcall(
                            function()
                                return game:GetService("Players")
                            end
                        )
                        if not lK or not lL then
                            return
                        end
                        local i = lL.LocalPlayer
                        local a3 = i and i.Character
                        local aA = a3 and a3:FindFirstChildOfClass("Humanoid")
                        if not aA then
                            return
                        end
                        if aA.Health <= lG.health then
                            local jN = lG.method
                            if jN ~= "CframeFling" and jN ~= "VelocityFling" then
                                jN = "CframeFling"
                                lG.method = jN
                            end
                            if jN == "CframeFling" then
                                for bc, cc in ipairs(a3:GetChildren()) do
                                    if cc:IsA("MeshPart") or cc:IsA("Part") then
                                        pcall(
                                            function()
                                                cc.CFrame =
                                                    cc.CFrame *
                                                    CFrame.fromEulerAnglesXYZ(math.rad(35), math.rad(35), math.rad(35)) *
                                                    CFrame.new(0, 50, 0)
                                                cc.CFrame =
                                                    cc.CFrame *
                                                    CFrame.fromEulerAnglesXYZ(
                                                        math.rad(-35),
                                                        math.rad(20),
                                                        math.rad(-15)
                                                    ) *
                                                    CFrame.new(0, 50, 0)
                                            end
                                        )
                                    end
                                end
                            elseif jN == "VelocityFling" then
                                local bd = a3:FindFirstChild("HumanoidRootPart")
                                if bd then
                                    local lM = Vector3.new(1e5, 1e5, 1e5)
                                    pcall(
                                        function()
                                            bd.Velocity, bd.AssemblyLinearVelocity = lM, lM
                                            bd.RotVelocity = Vector3.new(0, 1e4, 0)
                                            bd.AssemblyAngularVelocity = Vector3.new(0, 1e4, 0)
                                        end
                                    )
                                end
                            end
                        end
                    end
                )
            end
            local function lN(cc)
                lG.enabled = cc
                if cc then
                    lI()
                else
                    lH()
                end
            end
            local lO =
                le:toggle(
                {name = "AntiStomp", flag = "AntiStomp_Toggle", default = false, callback = function(cc)
                        lN(cc)
                        if a and a.update_dependencies then
                            a:update_dependencies()
                        end
                    end}
            )
            local lP = le:dependency_box()
            lP:setup_dependencies({{lO, true}})
            lP:dropdown(
                {
                    name = "Mode",
                    flag = "AntiStomp_Mode",
                    items = {"CframeFling", "VelocityFling"},
                    default = lG.method,
                    callback = function(dx)
                        lG.method = dx
                    end
                }
            )
            lP:slider(
                {
                    name = "HP",
                    flag = "AntiStomp_HP",
                    min = 1,
                    max = 100,
                    default = lG.health,
                    decimals = 0,
                    callback = function(dx)
                        lG.health = dx
                    end
                }
            )
            local lQ = {enabled = false, conn = nil, bin = {}}
            local function lR()
                if lQ.conn then
                    pcall(
                        function()
                            lQ.conn:Disconnect()
                        end
                    )
                    lQ.conn = nil
                end
            end
            local function lS(state)
                local lT, lU =
                    pcall(
                    function()
                        return game
                    end
                )
                if not lT or not lU then
                    return
                end
                if state then
                    local lV = lU:GetDescendants()
                    for cY = 1, #lV do
                        local ci = lV[cY]
                        if ci and (ci.ClassName == "Seat" or ci.ClassName == "VehicleSeat") then
                            if ci.Parent ~= nil and lQ.bin[ci] == nil then
                                local lW, lX =
                                    pcall(
                                    function()
                                        return ci.Parent
                                    end
                                )
                                if lW and lX then
                                    lQ.bin[ci] = lX
                                    pcall(
                                        function()
                                            ci.Parent = nil
                                        end
                                    )
                                end
                            end
                        end
                    end
                else
                    for fi, lX in pairs(lQ.bin) do
                        if fi then
                            pcall(
                                function()
                                    fi.Parent = lX
                                end
                            )
                        end
                    end
                    lQ.bin = {}
                end
            end
            local function lY(bj)
                lQ.enabled = bj
                if bj then
                    lS(true)
                    local lT, lU =
                        pcall(
                        function()
                            return game
                        end
                    )
                    if lT and lU then
                        lR()
                        lQ.conn =
                            lU.DescendantAdded:Connect(
                            function(ci)
                                if not lQ.enabled then
                                    return
                                end
                                if ci and (ci.ClassName == "Seat" or ci.ClassName == "VehicleSeat") then
                                    if ci.Parent ~= nil and lQ.bin[ci] == nil then
                                        local lW, lX =
                                            pcall(
                                            function()
                                                return ci.Parent
                                            end
                                        )
                                        if lW and lX then
                                            lQ.bin[ci] = lX
                                            pcall(
                                                function()
                                                    ci.Parent = nil
                                                end
                                            )
                                        end
                                    end
                                end
                            end
                        )
                    end
                else
                    lR()
                    lS(false)
                end
            end
            do
                if a and a.connections and type(a.connections) == "table" then
                    table.insert(
                        a.connections,
                        {Disconnect = function()
                                lR()
                                if lQ and lQ.enabled then
                                    lS(false)
                                end
                            end}
                    )
                end
            end
            local lZ =
                le:toggle(
                {name = "AntiSeats", flag = "AntiSeats_Toggle", default = false, callback = function(cc)
                        lY(cc)
                        if a and a.update_dependencies then
                            a:update_dependencies()
                        end
                    end}
            )
            local l_ = {enabled = false, bin = {}}
            local function m0(state)
                local m1, ka =
                    pcall(
                    function()
                        return game:GetService("Workspace")
                    end
                )
                if not m1 or not ka then
                    return
                end
                local m2, m3 = {}, {}
                local function kz(fi)
                    if fi and typeof(fi) == "Instance" and not m3[fi] then
                        m3[fi] = true
                        m2[#m2 + 1] = fi
                    end
                end
                local m4 = {
                    "Donation Board by @DaaalzYT",
                    " [Spit] - R$150 (READ DESC)",
                    "[Spawn With AimViewer] - R$60",
                    "[Char Command] - R$50 READ DESCRIPTION",
                    "[Emoji \226\152\128 - R$59",
                    "[Emoji \240\159\143\150 - R$59",
                    "[Emoji \240\159\170\129 - R$75",
                    "[Emoji \240\159\165\165 - R$85",
                    "[Emoji \240\159\144\172] - R$35",
                    "[Emoji \240\159\165\189] - R$35",
                    "[Emoji \240\159\141\168 - R$60",
                    "[Emoji \240\159\146\142] - R$100",
                    "[Emoji \240\159\142\175] - R$60",
                    "[10 streaks tags] - R$275",
                    "[streak tag] - R$40",
                    "[10 stomp effects] - R$325",
                    "[stomp effect] - R$45",
                    "[Emoji \240\159\146\184] - R$100",
                    "[Emoji \240\159\141\128] - R$60",
                    "[Emoji - [\240\159\140\184] - R75]",
                    "[Emoji \240\159\146\165] - R$20",
                    "[Emoji \240\159\145\145] - R$400",
                    "[Emoji \226\155\177] - R$55 ",
                    "[Spawn With Mask] - R$70",
                    "[Spawn With Shotgun] - R$85",
                    "[Spawn With TacticalSG] - R$115",
                    "[Spawn With Armor] - R$100",
                    "StandForLimitedKnives",
                    "StandForLimitedFood",
                    "Gun Stand",
                    "Osiris Scythe -- 299R$ (Limited Stock)",
                    "UmbrellaColor2",
                    "UmbrellaColor1",
                    "UmbrellaStick",
                    "Mesh_0",
                    "WashingMachineFUNC",
                    "bush"
                }
                for cY = 1, #m4 do
                    local ci = ka:FindFirstChild(m4[cY])
                    if ci then
                        kz(ci)
                    end
                end
                local bB = ka:GetChildren()
                local lz = {159, 140, 628, 164, 575, 1462, 576, 569, 1612}
                for cY = 1, #lz do
                    local cW = lz[cY]
                    if bB[cW] then
                        kz(bB[cW])
                    end
                end
                local m5 = ka:FindFirstChild("Gun Stand")
                if m5 then
                    local m6 = m5:FindFirstChild("Model")
                    if m6 then
                        local m7 = m6:GetChildren()
                        local m8 = {6, 10}
                        for cY = 1, #m8 do
                            local cW = m8[cY]
                            if m7[cW] then
                                kz(m7[cW])
                            end
                        end
                    end
                end
                local m9 = ka:FindFirstChild("MAP")
                if m9 then
                    local dD = m9:FindFirstChild("Map")
                    if dD then
                        local m7 = dD:GetChildren()
                        local ma = m7[603]
                        if ma then
                            local mb = ma:GetChildren()
                            local mc = {311, 89, 205}
                            for cY = 1, #mc do
                                local cW = mc[cY]
                                if mb[cW] then
                                    kz(mb[cW])
                                end
                            end
                        end
                        local md = {"Meshes/mountain", "Lights", "trash", "Gate", "Car2"}
                        for cY = 1, #md do
                            local ci = dD:FindFirstChild(md[cY])
                            if ci then
                                kz(ci)
                            end
                        end
                    end
                end
                local me = ka:FindFirstChild("Summer Location")
                if me then
                    local mf = me:FindFirstChild("Model")
                    if mf then
                        local mg = mf:GetChildren()
                        local mh = {
                            5,
                            49,
                            58,
                            60,
                            61,
                            59,
                            44,
                            22,
                            19,
                            20,
                            46,
                            48,
                            29,
                            30,
                            10,
                            14,
                            16,
                            106,
                            40,
                            189,
                            47,
                            63,
                            8,
                            68,
                            38,
                            34
                        }
                        for cY = 1, #mh do
                            local cW = mh[cY]
                            if mg[cW] then
                                kz(mg[cW])
                            end
                        end
                        for bc, mi in ipairs({"Sand castle", "Meshes/mountain"}) do
                            local ci = mf:FindFirstChild(mi)
                            if ci then
                                kz(ci)
                            end
                        end
                    end
                    local mj = me:FindFirstChild("Pool House")
                    if mj then
                        local mk = mj:GetChildren()
                        if mk[3] then
                            kz(mk[3])
                        end
                        local ml = mj:FindFirstChild("Light")
                        if ml then
                            kz(ml)
                        end
                    end
                    local mm = me:GetChildren()
                    if mm[4] then
                        kz(mm[4])
                    end
                    local mn = me:FindFirstChild("[Fish]")
                    if mn then
                        kz(mn)
                    end
                end
                local function mo(lX, lz)
                    local dE, mp =
                        pcall(
                        function()
                            return lX:GetChildren()
                        end
                    )
                    if dE and mp and type(lz) == "number" and lz >= 1 and lz <= #mp then
                        return mp[lz]
                    end
                end
                local mq = {function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        local m6 = me:FindFirstChild("Model")
                        if not m6 then
                            return
                        end
                        return mo(m6, 4)
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        return mo(dD, 800)
                    end, function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        local m6 = me:FindFirstChild("Model")
                        if not m6 then
                            return
                        end
                        return mo(m6, 52)
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        local mr = dD:FindFirstChild("Summer Location")
                        if not mr then
                            return
                        end
                        return mr:FindFirstChild("Beach Bar")
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        local mr = dD:FindFirstChild("Summer Location")
                        if not mr then
                            return
                        end
                        return mr:FindFirstChild("Fishing Ship")
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        return dD:FindFirstChild("BillboardSign")
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        return mo(dD, 265)
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        local ms = mo(dD, 655)
                        if not ms then
                            return
                        end
                        return mo(ms, 13)
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        local ms = mo(dD, 655)
                        if not ms then
                            return
                        end
                        return mo(ms, 11)
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        return mo(dD, 713)
                    end, function()
                        local mt = ka:FindFirstChild("Boom Taco's")
                        if not mt then
                            return
                        end
                        local m6 = mt:FindFirstChild("Model")
                        if not m6 then
                            return
                        end
                        return m6:FindFirstChild("amthere8_ballzs")
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        return m9:FindFirstChild("Lights")
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        local mr = dD:FindFirstChild("Summer Location")
                        if not mr then
                            return
                        end
                        return mr:FindFirstChild("mod")
                    end, function()
                        local mu = mo(ka, 10)
                        if not mu then
                            return
                        end
                        local m6 = mu:FindFirstChild("Model")
                        if not m6 then
                            return
                        end
                        local mv = m6:FindFirstChild("Streak leaderboard")
                        if not mv then
                            return
                        end
                        return mv:FindFirstChild("Meshes/rounded_sides_Plane.003")
                    end, function()
                        local mu = mo(ka, 10)
                        if not mu then
                            return
                        end
                        local m6 = mu:FindFirstChild("Model")
                        if not m6 then
                            return
                        end
                        local mv = m6:FindFirstChild("Streak leaderboard")
                        if not mv then
                            return
                        end
                        return mv:FindFirstChild("Meshes/rounded_sides_Plane.002")
                    end, function()
                        local mu = mo(ka, 10)
                        if not mu then
                            return
                        end
                        local m6 = mu:FindFirstChild("Model")
                        if not m6 then
                            return
                        end
                        local mv = m6:FindFirstChild("Streak leaderboard")
                        if not mv then
                            return
                        end
                        return mv:FindFirstChild("Meshes/rounded_sides_Plane.001")
                    end, function()
                        local mu = mo(ka, 10)
                        if not mu then
                            return
                        end
                        local m6 = mu:FindFirstChild("Model")
                        if not m6 then
                            return
                        end
                        local mv = m6:FindFirstChild("Streak leaderboard")
                        if not mv then
                            return
                        end
                        return mv:FindFirstChild("Model")
                    end, function()
                        local mu = mo(ka, 10)
                        if not mu then
                            return
                        end
                        local m6 = mu:FindFirstChild("Model")
                        if not m6 then
                            return
                        end
                        return m6:FindFirstChild("Streak leaderboard")
                    end, function()
                        local mu = mo(ka, 10)
                        if not mu then
                            return
                        end
                        local m6 = mu:FindFirstChild("Model")
                        if not m6 then
                            return
                        end
                        return m6:FindFirstChild("Model")
                    end, function()
                        local mu = mo(ka, 10)
                        if not mu then
                            return
                        end
                        return mu:FindFirstChild("Model")
                    end, function()
                        return mo(ka, 136)
                    end, function()
                        return ka:FindFirstChild("GameBillboards")
                    end, function()
                        local mu = mo(ka, 10)
                        if not mu then
                            return
                        end
                        return mu:FindFirstChild("Top Time Played Leaderboard")
                    end, function()
                        local mw = mo(ka, 116)
                        if not mw then
                            return
                        end
                        local mx = mw:FindFirstChild("Model")
                        if not mx then
                            return
                        end
                        local my = mx:FindFirstChild("Model")
                        if not my then
                            return
                        end
                        local mz = my:FindFirstChild("Model")
                        if not mz then
                            return
                        end
                        return mo(mz, 8)
                    end, function()
                        local mA = ka:FindFirstChild("PVP ARENA")
                        if not mA then
                            return
                        end
                        local mx = mA:FindFirstChild("Model")
                        if not mx then
                            return
                        end
                        return mx:FindFirstChild("Model")
                    end, function()
                        local mA = ka:FindFirstChild("PVP ARENA")
                        if not mA then
                            return
                        end
                        local mx = mA:FindFirstChild("Model")
                        if not mx then
                            return
                        end
                        return mx:FindFirstChild("Sand castle")
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        return mo(dD, 742)
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        return dD:FindFirstChild("Car2")
                    end, function()
                        return ka:FindFirstChild("Construction Site")
                    end, function()
                        return mo(ka, 200)
                    end, function()
                        return mo(ka, 121)
                    end, function()
                        return mo(ka, 198)
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        local ma = mo(dD, 603)
                        if not ma then
                            return
                        end
                        local mB = mo(ma, 265)
                        if not mB then
                            return
                        end
                        return mB:FindFirstChild("Palm Tree")
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        local ma = mo(dD, 603)
                        if not ma then
                            return
                        end
                        local mB = mo(ma, 265)
                        if not mB then
                            return
                        end
                        return mo(mB, 2)
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        local ma = mo(dD, 603)
                        if not ma then
                            return
                        end
                        local mC = mo(ma, 207)
                        if not mC then
                            return
                        end
                        local m6 = mC:FindFirstChild("Model")
                        if not m6 then
                            return
                        end
                        return mo(m6, 2)
                    end, function()
                        local m9 = ka:FindFirstChild("MAP")
                        if not m9 then
                            return
                        end
                        local dD = m9:FindFirstChild("Map")
                        if not dD then
                            return
                        end
                        local ma = mo(dD, 603)
                        if not ma then
                            return
                        end
                        local mC = mo(ma, 207)
                        if not mC then
                            return
                        end
                        local m6 = mC:FindFirstChild("Model")
                        if not m6 then
                            return
                        end
                        return m6:FindFirstChild("Palm Tree")
                    end, function()
                        return mo(ka, 270)
                    end, function()
                        return mo(ka, 267)
                    end, function()
                        return ka:FindFirstChild("Palm Tree")
                    end, function()
                        local mD = mo(ka, 125)
                        if not mD then
                            return
                        end
                        return mD:FindFirstChild("Palm Tree")
                    end, function()
                        local cZ = ka:FindFirstChild("Folder")
                        if not cZ then
                            return
                        end
                        local mE = mo(cZ, 66)
                        if not mE then
                            return
                        end
                        local m6 = mE:FindFirstChild("Model")
                        if not m6 then
                            return
                        end
                        return m6:FindFirstChild("Palm Tree")
                    end, function()
                        local cZ = ka:FindFirstChild("Folder")
                        if not cZ then
                            return
                        end
                        local mE = mo(cZ, 66)
                        if not mE then
                            return
                        end
                        local mF = mo(mE, 4)
                        if not mF then
                            return
                        end
                        return mF:FindFirstChild("Palm Tree")
                    end, function()
                        local cZ = ka:FindFirstChild("Folder")
                        if not cZ then
                            return
                        end
                        local mE = mo(cZ, 66)
                        if not mE then
                            return
                        end
                        return mE:FindFirstChild("Palm Tree")
                    end, function()
                        local cZ = ka:FindFirstChild("Folder")
                        if not cZ then
                            return
                        end
                        local mE = mo(cZ, 66)
                        if not mE then
                            return
                        end
                        local bg = mE:FindFirstChild("Part")
                        if not bg then
                            return
                        end
                        return mo(bg, 2)
                    end, function()
                        local cZ = ka:FindFirstChild("Folder")
                        if not cZ then
                            return
                        end
                        local mE = mo(cZ, 66)
                        if not mE then
                            return
                        end
                        local bg = mE:FindFirstChild("Part")
                        if not bg then
                            return
                        end
                        return bg:FindFirstChild("Palm Tree")
                    end, function()
                        local cZ = ka:FindFirstChild("Folder")
                        if not cZ then
                            return
                        end
                        local mE = mo(cZ, 66)
                        if not mE then
                            return
                        end
                        return mE:FindFirstChild("Part")
                    end, function()
                        local mG = mo(ka, 460)
                        if not mG then
                            return
                        end
                        return mo(mG, 2)
                    end, function()
                        local mG = mo(ka, 460)
                        if not mG then
                            return
                        end
                        local mx = mG:FindFirstChild("Model")
                        if not mx then
                            return
                        end
                        return mx:FindFirstChild("Model")
                    end, function()
                        return mo(ka, 224)
                    end, function()
                        local mH = mo(ka, 126)
                        if not mH then
                            return
                        end
                        return mo(mH, 3)
                    end, function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        return me:FindFirstChild("mod")
                    end, function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        return mo(me, 14)
                    end, function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        return mo(me, 16)
                    end, function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        return mo(me, 18)
                    end, function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        return mo(me, 19)
                    end, function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        return mo(me, 21)
                    end, function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        return me:FindFirstChild("Hammock")
                    end, function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        return mo(me, 20)
                    end, function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        return mo(me, 13)
                    end, function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        local m6 = me:FindFirstChild("Model")
                        if not m6 then
                            return
                        end
                        return m6:FindFirstChild("Meshes/mountain")
                    end, function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        return mo(me, 15)
                    end, function()
                        local me = ka:FindFirstChild("Summer Location")
                        if not me then
                            return
                        end
                        return me:FindFirstChild("Palm Tree")
                    end}
                for cY = 1, #mq do
                    local dE, fi = pcall(mq[cY])
                    if dE and typeof(fi) == "Instance" then
                        kz(fi)
                    end
                end
                local mI = ka:FindFirstChild("Players")
                if mI then
                    local mJ, lL =
                        pcall(
                        function()
                            return game:GetService("Players")
                        end
                    )
                    if mJ and lL then
                        local mK = mI:GetChildren()
                        for cY = 1, #mK do
                            local c3 = mK[cY]
                            local mL = typeof(c3) == "Instance" and c3:IsA("Model")
                            if mL then
                                local mM = c3:FindFirstChildOfClass("Humanoid") ~= nil
                                local mN = lL:FindFirstChild(c3.Name) ~= nil
                                if mM and not mN then
                                    kz(c3)
                                end
                            end
                        end
                    end
                end
                if state then
                    for cY = 1, #m2 do
                        local fi = m2[cY]
                        if fi.Parent ~= nil and l_.bin[fi] == nil then
                            local lW, lX =
                                pcall(
                                function()
                                    return fi.Parent
                                end
                            )
                            if lW and lX then
                                l_.bin[fi] = lX
                                pcall(
                                    function()
                                        fi.Parent = nil
                                    end
                                )
                            end
                        end
                    end
                else
                    for fi, lX in pairs(l_.bin) do
                        pcall(
                            function()
                                fi.Parent = lX
                            end
                        )
                    end
                    l_.bin = {}
                end
            end
            
            -- players/workspace junk cleaner start
            local function safe_destroy(obj)
                if obj then
                    pcall(function()
                        obj:Destroy()
                    end)
                end
            end

            local function hasExactlyOneDecal(inst)
                local decals = 0
                for _, sub in next, inst:GetDescendants() do
                    if sub:IsA("Decal") then
                        decals = decals + 1
                        if decals > 1 then break end
                    end
                end
                return decals == 1
            end

            local function hasAncestorNamed(inst, nameLower)
                local wsOk, ws = pcall(function() return game:GetService("Workspace") end)
                if not wsOk then return false end
                local p = inst and inst.Parent
                nameLower = tostring(nameLower)
                while p and p ~= ws do
                    if string.lower(tostring(p.Name)) == nameLower then
                        return true
                    end
                    p = p.Parent
                end
                return false
            end

            local function mZ_initial()
                local ok, ws = pcall(function()
                        return game:GetService("Workspace")
                    end)
                if not ok or not ws then return end

                -- Players: one-time sweep of Script that contain LocalScript
                local plrs = ws:FindFirstChild("Players")
                if plrs then
                    for _, inst in next, plrs:GetDescendants() do
                        if inst:IsA("Script") then
                            local hasLS = inst:FindFirstChildWhichIsA("LocalScript", true)
                            if hasLS then safe_destroy(inst) end
                        end
                    end
                end

                -- Workspace specific one-time removals
                do
                    local map = ws:FindFirstChild("MAP")
                    map = map and map:FindFirstChild("Map") or nil
                    if map then
                        safe_destroy(map:FindFirstChild("Meshes/mountain"))
                    end
                end

                do
                    local arena = ws:FindFirstChild("PVP ARENA")
                    local mdl = arena and arena:FindFirstChild("Model") or nil
                    if mdl then
                        safe_destroy(mdl:FindFirstChild("tree") or mdl:FindFirstChild("Tree"))
                    end
                end

                -- Remove any descendant named exactly "Palm Tree"
                for _, d in next, ws:GetDescendants() do
                    if d and d.Name == "Palm Tree" then
                        safe_destroy(d)
                    end
                end

                -- Remove any instance named exactly "trash" (case-insensitive)
                for _, d in next, ws:GetDescendants() do
                    if d and string.lower(tostring(d.Name)) == "trash" then
                        safe_destroy(d)
                    end
                end

                -- Remove BasePart named "Part" with exactly one Decal descendant (but NOT under any ancestor named 'parts')
                for _, d in next, ws:GetDescendants() do
                    if d and d:IsA("BasePart") and d.Name == "Part" then
                        if not hasAncestorNamed(d, "parts") and hasExactlyOneDecal(d) then
                            safe_destroy(d)
                        end
                    end
                end
            end

            local function mZ_watch()
                l_.conns = l_.conns or {}
                local ok, ws = pcall(function()
                        return game:GetService("Workspace")
                    end)
                if not ok or not ws then return end

                -- Workspace watcher: destroy by rules (name/structure)
                local workspaceAdded = ws.DescendantAdded:Connect(function(inst)
                    if not l_.enabled or not inst then return end
                    -- Any instance named 'trash'
                    if string.lower(tostring(inst.Name)) == "trash" then
                        safe_destroy(inst)
                        return
                    end
                    -- Any instance named exactly 'Palm Tree'
                    if inst.Name == "Palm Tree" then
                        safe_destroy(inst)
                        return
                    end
                    -- BasePart named 'Part' with exactly one Decal descendant
                    if inst:IsA("BasePart") and inst.Name == "Part" then
                        if not hasAncestorNamed(inst, "parts") and hasExactlyOneDecal(inst) then
                            safe_destroy(inst)
                            return
                        end
                    end
                    -- If a Decal is added under a BasePart named 'Part', re-check its parent chain
                    if inst:IsA("Decal") then
                        local p = inst.Parent
                        while p and p ~= ws do
                            if p:IsA("BasePart") then
                                -- if parent named trash — remove parent
                                if string.lower(tostring(p.Name)) == "trash" then
                                    safe_destroy(p)
                                    break
                                end
                                -- if parent named Part with exactly one Decal
                                if p.Name == "Part" then
                                    if not hasAncestorNamed(p, "parts") and hasExactlyOneDecal(p) then
                                        safe_destroy(p)
                                        break
                                    end
                                end
                            end
                            p = p.Parent
                        end
                    end
                end)
                table.insert(l_.conns, workspaceAdded)

                -- Players watcher: on LocalScript added under any Script -> destroy that Script
                local plrs = ws:FindFirstChild("Players")
                if plrs then
                    local plrsAdded = plrs.DescendantAdded:Connect(function(inst)
                        if not l_.enabled or not inst then return end
                        if inst:IsA("LocalScript") then
                            local p = inst.Parent
                            while p and p ~= plrs do
                                if p:IsA("Script") then
                                    safe_destroy(p)
                                    break
                                end
                                p = p.Parent
                            end
                        end
                    end)
                    table.insert(l_.conns, plrsAdded)
                end
            end

            local function mZ_cleanup()
                if l_.conns then
                    for i = 1, #l_.conns do
                        local c = l_.conns[i]
                        if c and c.Connected then pcall(function() c:Disconnect() end) end
                    end
                end
                l_.conns = {}
            end
            -- players/workspace junk cleaner end

            local function mO(bj)
                l_.enabled = bj
                m0(bj)
                if bj then
                    if not l_.cleaning then
                        l_.cleaning = true
                        mZ_initial()
                        mZ_watch()
                        -- light periodic touch: re-run targeted initial every 20s to catch missed cases
                        local mS = B and B.task or task
                        mS.spawn(function()
                            local waitFn = (B and B.task and B.task.wait) or task.wait
                            local t = 0
                            while l_.enabled do
                                waitFn(2)
                                t = t + 2
                                if t >= 20 then
                                    mZ_initial()
                                    t = 0
                                end
                            end
                            l_.cleaning = false
                        end)
                    end
                else
                    mZ_cleanup()
                end
            end
            do
                if a and a.connections and type(a.connections) == "table" then
                    table.insert(
                        a.connections,
                        {Disconnect = function()
                                if l_ and l_.enabled then
                                    mO(false)
                                end
                            end}
                    )
                end
            end
            local mP = {conn = nil, prev = nil}
            local function mQ()
                if getgenv and getgenv().OPTIMIZED_GRAPHICS then
                    return
                end
                local ka = game:GetService("Workspace")
                local mR = game:GetService("Lighting")
                local kb = B and B.run or game:GetService("RunService")
                local mS = B and B.task or task
                mP.prev = {
                    GlobalShadows = mR.GlobalShadows,
                    FogEnd = mR.FogEnd,
                    QualityLevel = (function()
                        local dE, mT =
                            pcall(
                            function()
                                return settings().Rendering.QualityLevel
                            end
                        )
                        return dE and mT or nil
                    end)()
                }
                local mU = {
                    ka:FindFirstChild("Lights"),
                    ka:FindFirstChild("MAP") and ka.MAP:FindFirstChild("Graffiti") or nil,
                    ka:FindFirstChild("MAP") and ka.MAP:FindFirstChild("Map") and
                        ka.MAP.Map:FindFirstChild("Game-Houses") or
                        nil
                }
                for bc, fA in next, mU do
                    if fA then
                        pcall(
                            function()
                                fA:Destroy()
                            end
                        )
                    end
                end
                for bc, a0 in next, game:GetDescendants() do
                    local cW = a0.Name
                    if cW == "Meshes/mountain" or cW == "print" or cW == "Image Ad Unit 2" then
                        pcall(
                            function()
                                a0:Destroy()
                            end
                        )
                    end
                end
                local mV = ka:FindFirstChild("Ignored")
                if mV then
                    for bc, mW in next, mV:GetChildren() do
                        local cW = mW.Name
                        if cW == "HouseOwn" or cW == "Folder" or cW == "HouseItemSale" or cW == "ItemsDrop" then
                            pcall(
                                function()
                                    mW:Destroy()
                                end
                            )
                        end
                    end
                end
                local m9 = ka:FindFirstChild("MAP")
                if m9 then
                    local dD = m9:FindFirstChild("Map")
                    if dD then
                        for bc, mX in next, dD:GetChildren() do
                            if mX:IsA("Model") then
                                pcall(
                                    function()
                                        mX:Destroy()
                                    end
                                )
                            end
                        end
                    end
                    local mY = m9:FindFirstChild("Indestructible")
                    if mY then
                        for bc, mX in next, mY:GetChildren() do
                            if mX:IsA("Model") then
                                pcall(
                                    function()
                                        mX:Destroy()
                                    end
                                )
                            end
                        end
                    end
                end
                local mZ = {
                    "Accessory",
                    "Decal",
                    "ShirtGraphic",
                    "Shirt",
                    "Pants",
                    "Seat",
                    "VehicleSeat",
                    "SpecialMesh"
                }
                for bc, a0 in next, ka:GetDescendants() do
                    for bc, m_ in next, mZ do
                        if a0:IsA(m_) then
                            pcall(
                                function()
                                    a0:Destroy()
                                end
                            )
                        end
                    end
                end
                local n0 = ka:FindFirstChildOfClass("Terrain")
                if n0 then
                    n0.WaterWaveSize = 0
                    n0.WaterWaveSpeed = 0
                    n0.WaterReflectance = 0
                    n0.WaterTransparency = 0
                end
                mR.GlobalShadows = false
                mR.FogEnd = 9e9
                pcall(
                    function()
                        settings().Rendering.QualityLevel = 1
                    end
                )
                for bc, cc in next, game:GetDescendants() do
                    if
                        cc:IsA("Part") or cc:IsA("UnionOperation") or cc:IsA("MeshPart") or cc:IsA("CornerWedgePart") or
                            cc:IsA("WedgePart") or
                            cc:IsA("TrussPart")
                     then
                        cc.Material = Enum.Material.Plastic
                        cc.Reflectance = 0
                    elseif cc:IsA("Decal") then
                        cc.Transparency = 1
                    elseif cc:IsA("ParticleEmitter") or cc:IsA("Trail") then
                        cc.Lifetime = NumberRange.new(0)
                    end
                end
                for bc, gk in next, mR:GetDescendants() do
                    if
                        gk:IsA("BlurEffect") or gk:IsA("SunRaysEffect") or gk:IsA("ColorCorrectionEffect") or
                            gk:IsA("BloomEffect") or
                            gk:IsA("DepthOfFieldEffect")
                     then
                        gk.Enabled = false
                    end
                end
                mP.conn =
                    ka.DescendantAdded:Connect(
                    function(c4)
                        mS.spawn(
                            function()
                                if c4:IsA("ForceField") or c4:IsA("Sparkles") or c4:IsA("Smoke") or c4:IsA("Fire") then
                                    local n1 = kb and kb.Heartbeat or game:GetService("RunService").Heartbeat
                                    n1:Wait()
                                    pcall(
                                        function()
                                            c4:Destroy()
                                        end
                                    )
                                end
                            end
                        )
                    end
                )
                if getgenv then
                    getgenv().OPTIMIZED_GRAPHICS = true
                end
            end
            local function n2()
                if mP.conn and mP.conn.Connected then
                    pcall(
                        function()
                            mP.conn:Disconnect()
                        end
                    )
                end
                mP.conn = nil
                local mR = game:GetService("Lighting")
                local gX = mP.prev
                if gX then
                    pcall(
                        function()
                            mR.GlobalShadows = gX.GlobalShadows
                            mR.FogEnd = gX.FogEnd
                            if gX.QualityLevel ~= nil then
                                settings().Rendering.QualityLevel = gX.QualityLevel
                            end
                        end
                    )
                end
                if getgenv then
                    getgenv().OPTIMIZED_GRAPHICS = nil
                end
            end
            local a6 =
                le:toggle(
                {name = "ClearTrash", flag = "ClearTrash_Toggle", default = false, callback = function(cc)
                        mO(cc)
                        if a and a.update_dependencies then
                            a:update_dependencies()
                        end
                    end}
            )
            local n3 =
                le:toggle(
                {name = "PotatoMode", flag = "PotatoMode_Toggle", default = false, callback = function(cc)
                        if cc then
                            mQ()
                        else
                            n2()
                        end
                        if a and a.update_dependencies then
                            a:update_dependencies()
                        end
                    end}
            )
            table.insert(
                a.connections,
                {Disconnect = function()
                        if getgenv and getgenv().OPTIMIZED_GRAPHICS then
                            n2()
                        end
                    end}
            )
        end
    end
end
do
    local n4 =
        loadstring(game:HttpGet("https://raw.githubusercontent.com/AreWeDeadas/Rebuild.gg/refs/heads/main/zzzz"))()
    n4.init()
    local n5 = v:section({name = "esp"})
    local n6 =
        n5:toggle(
        {name = "BoxEsp", state = false, callback = function(state)
                if _G.ESP_Config and _G.ESP_Config.Box then
                    _G.ESP_Config.Box.Enable = state
                end
            end}
    )
    do
        _G.ESP_Config = _G.ESP_Config or {}
        _G.ESP_Config.Box = _G.ESP_Config.Box or {}
        local n7 = _G.ESP_Config.Box
        n7.Color = n7.Color or c("#ffffff")
    end
    n6:colorpicker(
        {
            name = "Color",
            flag = "esp_box_color",
            default = _G.ESP_Config and _G.ESP_Config.Box and _G.ESP_Config.Box.Color or c("#ffffff"),
            callback = function(n8)
                if _G.ESP_Config and _G.ESP_Config.Box then
                    _G.ESP_Config.Box.Color = n8
                end
            end
        }
    )
    local n9 = n5:dependency_box()
    n9:setup_dependencies({{n6, true}})
    local na =
        n9:toggle(
        {name = "Filled", flag = "esp_box_filled", default = false, callback = function(state)
                if _G.ESP_Config and _G.ESP_Config.Box and _G.ESP_Config.Box.Filled then
                    _G.ESP_Config.Box.Filled.Enable = state
                end
            end}
    )
    local nb = n9:dependency_box()
    nb:setup_dependencies({{na, true}})
    local nc =
        nb:toggle(
        {name = "Gradient", flag = "esp_box_gradient", default = false, callback = function(state)
                if
                    _G.ESP_Config and _G.ESP_Config.Box and _G.ESP_Config.Box.Filled and
                        _G.ESP_Config.Box.Filled.Gradient
                 then
                    _G.ESP_Config.Box.Filled.Gradient.Enable = state
                end
            end}
    )
    nc:colorpicker(
        {
            name = "Start",
            flag = "esp_box_grad_start",
            default = c("#ffffff"),
            callback = function(n8)
                if
                    _G.ESP_Config and _G.ESP_Config.Box and _G.ESP_Config.Box.Filled and
                        _G.ESP_Config.Box.Filled.Gradient and
                        _G.ESP_Config.Box.Filled.Gradient.Color
                 then
                    _G.ESP_Config.Box.Filled.Gradient.Color.Start = n8
                end
            end
        }
    ):colorpicker(
        {
            name = "End",
            flag = "esp_box_grad_end",
            default = c("#0000ff"),
            callback = function(n8)
                if
                    _G.ESP_Config and _G.ESP_Config.Box and _G.ESP_Config.Box.Filled and
                        _G.ESP_Config.Box.Filled.Gradient and
                        _G.ESP_Config.Box.Filled.Gradient.Color
                 then
                    _G.ESP_Config.Box.Filled.Gradient.Color.End = n8
                end
            end
        }
    )
    nb:slider(
        {
            name = "Trs",
            flag = "esp_box_fill_trs",
            min = 0,
            max = 1,
            default = 0.9,
            interval = 0.01,
            callback = function(nd)
                if _G.ESP_Config and _G.ESP_Config.Box and _G.ESP_Config.Box.Filled then
                    _G.ESP_Config.Box.Filled.Transparency = nd
                end
            end
        }
    )
    local ne = nb:dependency_box()
    ne:setup_dependencies({{nc, true}})
    ne:toggle(
        {
            name = "Rotating",
            flag = "esp_box_grad_rot",
            default = false,
            callback = function(state)
                if
                    _G.ESP_Config and _G.ESP_Config.Box and _G.ESP_Config.Box.Filled and
                        _G.ESP_Config.Box.Filled.Gradient and
                        _G.ESP_Config.Box.Filled.Gradient.Rotating
                 then
                    _G.ESP_Config.Box.Filled.Gradient.Rotating.Enable = state
                end
            end
        }
    )
    local nf =
        n5:toggle(
        {name = "TextName", state = false, callback = function(state)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Name then
                    _G.ESP_Config.Text.Name.Enable = state
                end
            end}
    )
    nf:colorpicker(
        {name = "Color", flag = "esp_txtname_color", default = c("#ffffff"), callback = function(n8)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Name then
                    _G.ESP_Config.Text.Name.Color = n8
                end
            end}
    )
    nf:colorpicker(
        {name = "Stroke", flag = "esp_txtname_stroke", default = c("#000000"), callback = function(n8)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Name then
                    _G.ESP_Config.Text.Name.StrokeColor = n8
                end
            end}
    )
    do
        _G.ESP_Config = _G.ESP_Config or {}
        local T = _G.ESP_Config
        T.Text = T.Text or {}
        T.Text.Name = T.Text.Name or {}
        local N = T.Text.Name
        N.Color = N.Color or c("#ffffff")
        N.StrokeColor = N.StrokeColor or c("#000000")
        if N.StrokeTransparency == nil then
            N.StrokeTransparency = 0.0
        end
        N.Font = N.Font or "ProggyClean"
        N.Size = N.Size or 13
        N.Side = N.Side or "Top"
        N.ShowNameMethod = N.ShowNameMethod or {Enable = false, Mode = "Display"}
        if N.ShowNameMethod.Enable == nil then
            N.ShowNameMethod.Enable = false
        end
        N.ShowNameMethod.Mode = N.ShowNameMethod.Mode or "Display"
    end
    local ng = n5:dependency_box()
    ng:setup_dependencies({{nf, true}})
    local nh =
        ng:toggle(
        {name = "OriginalNameMod", state = false, callback = function(state)
                _G.ESP_Config = _G.ESP_Config or {}
                _G.ESP_Config.Text = _G.ESP_Config.Text or {}
                _G.ESP_Config.Text.Name = _G.ESP_Config.Text.Name or {}
                _G.ESP_Config.Text.Name.ShowNameMethod = _G.ESP_Config.Text.Name.ShowNameMethod or {Mode = "Display"}
                _G.ESP_Config.Text.Name.ShowNameMethod.Enable = state
                if UpdateAllShowNameMethod then
                    UpdateAllShowNameMethod()
                end
            end}
    )
    local ni = n5:dependency_box()
    ni:setup_dependencies({{nh, true}})
    ni:dropdown(
        {
            name = "Type",
            flag = "esp_txtname_showname_mode",
            items = {"Display", "Original", "None"},
            default = "Display",
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Name then
                    _G.ESP_Config.Text.Name.ShowNameMethod = _G.ESP_Config.Text.Name.ShowNameMethod or {}
                    _G.ESP_Config.Text.Name.ShowNameMethod.Mode = nj
                    if UpdateAllShowNameMethod then
                        UpdateAllShowNameMethod()
                    end
                end
            end
        }
    )
    do
        local nk = S and S.PS or game:GetService("Players")
        local nl = S and S.RS or game:GetService("RunService")
        local nm = rawget(_G, "LP") and _G.LP or LP or nk.LocalPlayer
        local function nn()
            local no = (((_G.ESP_Config or {}).Text or {}).Name or {}).ShowNameMethod
            if not no then
                return {Enable = false, Mode = "Display"}
            end
            return no
        end
        local function np(nq)
            if not nq then
                return
            end
            if nq == nm then
                return
            end
            local nr = nq.Character
            if not nr then
                return
            end
            local ns = nr:FindFirstChildOfClass("Humanoid")
            if not ns then
                return
            end
            local no = nn()
            if not no.Enable then
                -- do nothing when disabled
                return
            end
            local nt = tostring(no.Mode or "Display")
            if nt == "None" or nt == "none" or nt == "NONE" then
                ns.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
                return
            end
            ns.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
            ns.NameOcclusion = Enum.NameOcclusion.NoOcclusion
            if nt == "Display" or nt == "display" or nt == "DISPLAY" then
                ns.DisplayName = nq.DisplayName ~= "" and nq.DisplayName or nq.Name
            else
                ns.DisplayName = nq.Name
            end
        end
        local function nu()
            local no = nn()
            if not no.Enable then
                return
            end
            for _, p in ipairs(nk:GetPlayers()) do
                np(p)
            end
        end
        UpdateAllShowNameMethod = nu
        if not _G.__ShowNameMethod_Bound then
            nk.PlayerAdded:Connect(
                function(p)
                    p.CharacterAdded:Connect(
                        function()
                            np(p)
                        end
                    )
                end
            )
            for _, p in ipairs(nk:GetPlayers()) do
                if p.Character then
                    np(p)
                end
                p.CharacterAdded:Connect(
                    function()
                        np(p)
                    end
                )
            end
            nl.Heartbeat:Connect(nu)
            _G.__ShowNameMethod_Bound = true
        end
    end
    local nv = n5:dependency_box()
    nv:setup_dependencies({{nf, true}})
    nv:dropdown(
        {
            name = "Font",
            flag = "esp_txtname_font",
            items = {
                "ProggyClean",
                "ProggyTiny",
                "Minecraftia",
                "SmallestPixel7",
                "Verdana",
                "VerdanaBold",
                "Tahoma",
                "TahomaBold",
                "CSGO",
                "WindowsXPTahoma",
                "Stratum2",
                "Visitor"
            },
            default = "ProggyClean",
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Name then
                    _G.ESP_Config.Text.Name.Font = nj
                end
            end
        }
    )
    nv:slider(
        {
            name = "Size",
            flag = "esp_txtname_size",
            min = 8,
            max = 32,
            default = 13,
            interval = 1,
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Name then
                    _G.ESP_Config.Text.Name.Size = nj
                end
            end
        }
    )
    nv:dropdown(
        {name = "Side", flag = "esp_txtname_side", items = {"Top", "Bot"}, default = "Top", callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Name then
                    _G.ESP_Config.Text.Name.Side = nj
                end
            end}
    )
    nv:slider(
        {
            name = "StrokeTr",
            flag = "esp_txtname_stroke_tr",
            min = 0,
            max = 1,
            default = 0.0,
            interval = 0.05,
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Name then
                    _G.ESP_Config.Text.Name.StrokeTransparency = nj
                end
            end
        }
    )
    local nw =
        n5:toggle(
        {name = "HealthBar", state = false, callback = function(state)
                _G.ESP_Config = _G.ESP_Config or {}
                _G.ESP_Config.Bars = _G.ESP_Config.Bars or {}
                _G.ESP_Config.Bars.Health = _G.ESP_Config.Bars.Health or {}
                _G.ESP_Config.Bars.Health.Enable = state
                _G.ESP_Config.Bars.Health.Lerp = true
            end}
    )
    do
        _G.ESP_Config = _G.ESP_Config or {}
        local C = _G.ESP_Config
        C.Bars = C.Bars or {}
        C.Bars.Health = C.Bars.Health or {}
        local H = C.Bars.Health
        H.Color1 = H.Color1 or c("#00ff00")
        H.Color2 = H.Color2 or c("#00ff00")
        H.Color3 = H.Color3 or c("#00ff00")
        H.Width = H.Width or 3
        H.Pad = 0
        H.Offset = H.Offset or 4
        H.Side = H.Side or "Right"
        H.Lerp = true
    end
    nw:colorpicker(
        {
            name = "Clr1",
            flag = "esp_hb_c1",
            default = _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Health and
                _G.ESP_Config.Bars.Health.Color1 or
                c("#00ff00"),
            callback = function(n8)
                if _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Health then
                    _G.ESP_Config.Bars.Health.Color1 = n8
                end
            end
        }
    )
    nw:colorpicker(
        {
            name = "Clr2",
            flag = "esp_hb_c2",
            default = _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Health and
                _G.ESP_Config.Bars.Health.Color2 or
                c("#00ff00"),
            callback = function(n8)
                if _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Health then
                    _G.ESP_Config.Bars.Health.Color2 = n8
                end
            end
        }
    )
    local nx = n5:dependency_box()
    nx:setup_dependencies({{nw, true}})
    nx:slider(
        {name = "Width", flag = "esp_hb_width", min = 1, max = 12, default = 3, interval = 1, callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Health then
                    _G.ESP_Config.Bars.Health.Width = nj
                end
            end}
    )
    nx:slider(
        {name = "Offset", flag = "esp_hb_offset", min = 0, max = 16, default = 4, interval = 1, callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Health then
                    _G.ESP_Config.Bars.Health.Offset = nj
                end
            end}
    )
    nx:dropdown(
        {
            name = "Side",
            flag = "esp_hb_side",
            items = {"Bot", "Top", "Right", "Left"},
            default = "Right",
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Health then
                    _G.ESP_Config.Bars.Health.Side = nj
                end
            end
        }
    )
    local ny =
        n5:toggle(
        {name = "ArmorBar", state = false, callback = function(state)
                if _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Armor then
                    _G.ESP_Config.Bars.Armor.Enable = state
                end
            end}
    )
    do
        _G.ESP_Config = _G.ESP_Config or {}
        _G.ESP_Config.Bars = _G.ESP_Config.Bars or {}
        _G.ESP_Config.Bars.Armor = _G.ESP_Config.Bars.Armor or {}
        local nz = _G.ESP_Config.Bars.Armor
        nz.Color1 = nz.Color1 or c("#00ff00")
        nz.Color2 = nz.Color2 or c("#00ff00")
        nz.Width = nz.Width == nil and 3 or nz.Width
        nz.Offset = nz.Offset == nil and 4 or nz.Offset
        nz.Side = nz.Side or "Right"
        nz.Lerp = true
        nz.Pad = 0
    end
    ny:colorpicker(
        {
            name = "Clr1",
            flag = "esp_ab_c1",
            default = _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Armor and
                _G.ESP_Config.Bars.Armor.Color1 or
                c("#00ff00"),
            callback = function(n8)
                if _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Armor then
                    _G.ESP_Config.Bars.Armor.Color1 = n8
                end
            end
        }
    )
    ny:colorpicker(
        {
            name = "Clr2",
            flag = "esp_ab_c2",
            default = _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Armor and
                _G.ESP_Config.Bars.Armor.Color2 or
                c("#00ff00"),
            callback = function(n8)
                if _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Armor then
                    _G.ESP_Config.Bars.Armor.Color2 = n8
                end
            end
        }
    )
    local nA = n5:dependency_box()
    nA:setup_dependencies({{ny, true}})
    nA:slider(
        {name = "Width", flag = "esp_ab_width", min = 1, max = 12, default = 3, interval = 1, callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Armor then
                    _G.ESP_Config.Bars.Armor.Width = nj
                end
            end}
    )
    nA:slider(
        {name = "Offset", flag = "esp_ab_offset", min = 0, max = 16, default = 4, interval = 1, callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Armor then
                    _G.ESP_Config.Bars.Armor.Offset = nj
                end
            end}
    )
    nA:dropdown(
        {
            name = "Side",
            flag = "esp_ab_side",
            items = {"Bot", "Top", "Right", "Left"},
            default = "Right",
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Bars and _G.ESP_Config.Bars.Armor then
                    _G.ESP_Config.Bars.Armor.Side = nj
                end
            end
        }
    )
    local nB =
        n5:toggle(
        {name = "TextStuds", state = false, callback = function(state)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Studs then
                    _G.ESP_Config.Text.Studs.Enable = state
                end
            end}
    )
    nB:colorpicker(
        {
            name = "Color",
            flag = "esp_txtstuds_color",
            default = _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Studs and
                _G.ESP_Config.Text.Studs.Color or
                c("#ffffff"),
            callback = function(n8)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Studs then
                    _G.ESP_Config.Text.Studs.Color = n8
                end
            end
        }
    )
    nB:colorpicker(
        {
            name = "Stroke",
            flag = "esp_txtstuds_stroke",
            default = _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Studs and
                _G.ESP_Config.Text.Studs.StrokeColor or
                c("#000000"),
            callback = function(n8)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Studs then
                    _G.ESP_Config.Text.Studs.StrokeColor = n8
                end
            end
        }
    )
    do
        _G.ESP_Config = _G.ESP_Config or {}
        _G.ESP_Config.Text = _G.ESP_Config.Text or {}
        _G.ESP_Config.Text.Studs = _G.ESP_Config.Text.Studs or {}
        local nC = _G.ESP_Config.Text.Studs
        nC.Font = nC.Font or "ProggyClean"
        nC.Size = nC.Size or 13
        nC.Side = nC.Side or "Top"
        nC.StrokeTransparency = nC.StrokeTransparency == nil and 0.0 or nC.StrokeTransparency
        nC.Color = nC.Color or c("#ffffff")
        nC.StrokeColor = nC.StrokeColor or c("#000000")
    end
    local nD = n5:dependency_box()
    nD:setup_dependencies({{nB, true}})
    nD:dropdown(
        {
            name = "Font",
            flag = "esp_txtstuds_font",
            items = {
                "ProggyClean",
                "ProggyTiny",
                "Minecraftia",
                "SmallestPixel7",
                "Verdana",
                "VerdanaBold",
                "Tahoma",
                "TahomaBold",
                "CSGO",
                "WindowsXPTahoma",
                "Stratum2",
                "Visitor"
            },
            default = "ProggyClean",
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Studs then
                    _G.ESP_Config.Text.Studs.Font = nj
                end
            end
        }
    )
    nD:slider(
        {
            name = "Size",
            flag = "esp_txtstuds_size",
            min = 8,
            max = 32,
            default = 13,
            interval = 1,
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Studs then
                    _G.ESP_Config.Text.Studs.Size = nj
                end
            end
        }
    )
    nD:dropdown(
        {name = "Side", flag = "esp_txtstuds_side", items = {"Top", "Bot"}, default = "Top", callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Studs then
                    _G.ESP_Config.Text.Studs.Side = nj
                end
            end}
    )
    nD:slider(
        {
            name = "StrokeTr",
            flag = "esp_txtstuds_stroke_tr",
            min = 0,
            max = 1,
            default = 0.0,
            interval = 0.05,
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Studs then
                    _G.ESP_Config.Text.Studs.StrokeTransparency = nj
                end
            end
        }
    )
    local nE =
        n5:toggle(
        {name = "TextState", state = false, callback = function(state)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.State then
                    _G.ESP_Config.Text.State.Enable = state
                end
            end}
    )
    do
        _G.ESP_Config = _G.ESP_Config or {}
        _G.ESP_Config.Text = _G.ESP_Config.Text or {}
        _G.ESP_Config.Text.State = _G.ESP_Config.Text.State or {}
        local nF = _G.ESP_Config.Text.State
        nF.Font = nF.Font or "ProggyClean"
        nF.Size = nF.Size or 13
        nF.Side = nF.Side or "Top"
        nF.StrokeTransparency = nF.StrokeTransparency == nil and 0.0 or nF.StrokeTransparency
        nF.Color = nF.Color or c("#ffffff")
        nF.StrokeColor = nF.StrokeColor or c("#000000")
    end
    local nG = n5:dependency_box()
    nG:setup_dependencies({{nE, true}})
    nG:dropdown(
        {
            name = "Font",
            flag = "esp_txtstate_font",
            items = {
                "ProggyClean",
                "ProggyTiny",
                "Minecraftia",
                "SmallestPixel7",
                "Verdana",
                "VerdanaBold",
                "Tahoma",
                "TahomaBold",
                "CSGO",
                "WindowsXPTahoma",
                "Stratum2",
                "Visitor"
            },
            default = "ProggyClean",
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.State then
                    _G.ESP_Config.Text.State.Font = nj
                end
            end
        }
    )
    nG:slider(
        {
            name = "Size",
            flag = "esp_txtstate_size",
            min = 8,
            max = 32,
            default = 13,
            interval = 1,
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.State then
                    _G.ESP_Config.Text.State.Size = nj
                end
            end
        }
    )
    nG:dropdown(
        {name = "Side", flag = "esp_txtstate_side", items = {"Top", "Bot"}, default = "Top", callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.State then
                    _G.ESP_Config.Text.State.Side = nj
                end
            end}
    )
    nG:slider(
        {
            name = "StrokeTr",
            flag = "esp_txtstate_stroke_tr",
            min = 0,
            max = 1,
            default = 0.0,
            interval = 0.05,
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.State then
                    _G.ESP_Config.Text.State.StrokeTransparency = nj
                end
            end
        }
    )
    nE:colorpicker(
        {
            name = "Color",
            flag = "esp_txtstate_color",
            default = _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.State and
                _G.ESP_Config.Text.State.Color or
                c("#ffffff"),
            callback = function(n8)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.State then
                    _G.ESP_Config.Text.State.Color = n8
                end
            end
        }
    )
    nE:colorpicker(
        {
            name = "Stroke",
            flag = "esp_txtstate_stroke",
            default = _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.State and
                _G.ESP_Config.Text.State.StrokeColor or
                c("#000000"),
            callback = function(n8)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.State then
                    _G.ESP_Config.Text.State.StrokeColor = n8
                end
            end
        }
    )
    local nH =
        n5:toggle(
        {name = "TextTool", state = false, callback = function(state)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Tool then
                    _G.ESP_Config.Text.Tool.Enable = state
                end
            end}
    )
    do
        _G.ESP_Config = _G.ESP_Config or {}
        _G.ESP_Config.Text = _G.ESP_Config.Text or {}
        _G.ESP_Config.Text.Tool = _G.ESP_Config.Text.Tool or {}
        local nI = _G.ESP_Config.Text.Tool
        nI.Font = nI.Font or "ProggyClean"
        nI.Size = nI.Size or 13
        nI.Side = nI.Side or "Top"
        nI.StrokeTransparency = nI.StrokeTransparency == nil and 0.0 or nI.StrokeTransparency
        nI.Color = nI.Color or c("#ffffff")
        nI.StrokeColor = nI.StrokeColor or c("#000000")
    end
    local nJ = n5:dependency_box()
    nJ:setup_dependencies({{nH, true}})
    nJ:dropdown(
        {
            name = "Font",
            flag = "esp_txttool_font",
            items = {
                "ProggyClean",
                "ProggyTiny",
                "Minecraftia",
                "SmallestPixel7",
                "Verdana",
                "VerdanaBold",
                "Tahoma",
                "TahomaBold",
                "CSGO",
                "WindowsXPTahoma",
                "Stratum2",
                "Visitor"
            },
            default = "ProggyClean",
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Tool then
                    _G.ESP_Config.Text.Tool.Font = nj
                end
            end
        }
    )
    nJ:slider(
        {
            name = "Size",
            flag = "esp_txttool_size",
            min = 8,
            max = 32,
            default = 13,
            interval = 1,
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Tool then
                    _G.ESP_Config.Text.Tool.Size = nj
                end
            end
        }
    )
    nJ:dropdown(
        {name = "Side", flag = "esp_txttool_side", items = {"Top", "Bot"}, default = "Top", callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Tool then
                    _G.ESP_Config.Text.Tool.Side = nj
                end
            end}
    )
    nJ:slider(
        {
            name = "StrokeTr",
            flag = "esp_txttool_stroke_tr",
            min = 0,
            max = 1,
            default = 0.0,
            interval = 0.05,
            callback = function(nj)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Tool then
                    _G.ESP_Config.Text.Tool.StrokeTransparency = nj
                end
            end
        }
    )
    nH:colorpicker(
        {
            name = "Color",
            flag = "esp_txttool_color",
            default = _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Tool and _G.ESP_Config.Text.Tool.Color or
                c("#ffffff"),
            callback = function(n8)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Tool then
                    _G.ESP_Config.Text.Tool.Color = n8
                end
            end
        }
    )
    nH:colorpicker(
        {
            name = "Stroke",
            flag = "esp_txttool_stroke",
            default = _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Tool and
                _G.ESP_Config.Text.Tool.StrokeColor or
                c("#000000"),
            callback = function(n8)
                if _G.ESP_Config and _G.ESP_Config.Text and _G.ESP_Config.Text.Tool then
                    _G.ESP_Config.Text.Tool.StrokeColor = n8
                end
            end
        }
    )
end

-- Local Highlights Section
do
    local local_column = v:column()
    local local_section = local_column:section({name = "Local"})
    
    -- Self Highlight functionality
    do
        local self_highlight_state = {
            los_highlight = nil,
            connection = nil
        }
        
        local function apply_self_highlight(character)
            -- Cleanup existing highlight
            if self_highlight_state.los_highlight then 
                self_highlight_state.los_highlight:Destroy() 
            end
            
            -- Create single AlwaysOnTop highlight
            local los_highlight = Instance.new("Highlight")
            los_highlight.Parent = character
            los_highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            local gflags = f or {}
            local init_fill = gflags["selfhighlight_fill_color"]
            local init_outline = gflags["selfhighlight_outline_color"]
            local init_fill_c3 = (typeof(init_fill) == "table" and (init_fill.Color or init_fill.Color3)) or init_fill or Color3.fromRGB(255, 255, 255)
            local init_outline_c3 = (typeof(init_outline) == "table" and (init_outline.Color or init_outline.Color3)) or init_outline or Color3.fromRGB(255, 255, 255)
            los_highlight.FillColor = init_fill_c3
            los_highlight.OutlineColor = init_outline_c3
            -- normalize flags to Color3 so future reads are consistent
            if f then
                f["selfhighlight_fill_color"] = init_fill_c3
                f["selfhighlight_outline_color"] = init_outline_c3
            end
            -- SelfHighlight transparency is controlled ONLY by its own flag
            los_highlight.FillTransparency = gflags["selfhighlight_fill_transparency"] or 1
            los_highlight.OutlineTransparency = gflags["selfhighlight_outline_transparency"] or 0
            los_highlight.Enabled = true
            
            self_highlight_state.los_highlight = los_highlight
        end
        
        local function enable_self_highlight()
            local lp = (vars and vars.lp) or (game and game:GetService("Players").LocalPlayer)
            if not lp then
                task.defer(function()
                    local tries = 0
                    while not lp and tries < 100 do
                        task.wait(0.1)
                        lp = (vars and vars.lp) or (game and game:GetService("Players").LocalPlayer)
                        tries = tries + 1
                    end
                    if lp then enable_self_highlight() end
                end)
                return
            end

            if not self_highlight_state.connection then
                self_highlight_state.connection = lp.CharacterAdded:Connect(function(char)
                    task.wait(0.5)
                    if char then
                        apply_self_highlight(char)
                    end
                end)
            end

            local char = lp.Character
            if char then
                apply_self_highlight(char)
            end
        end
        
        local function disable_self_highlight()
            if self_highlight_state.los_highlight then
                self_highlight_state.los_highlight:Destroy()
                self_highlight_state.los_highlight = nil
            end
            if self_highlight_state.connection then
                self_highlight_state.connection:Disconnect()
                self_highlight_state.connection = nil
            end
        end
        
        local function update_self_highlight_visual()
            local gflags = f or {}
            
            -- Update line-of-sight highlight
            if self_highlight_state.los_highlight then
                local fill = gflags["selfhighlight_fill_color"]
                local outline = gflags["selfhighlight_outline_color"]
                local fill_c3 = (typeof(fill) == "table" and (fill.Color or fill.Color3)) or fill or Color3.fromRGB(255, 255, 255)
                local outline_c3 = (typeof(outline) == "table" and (outline.Color or outline.Color3)) or outline or Color3.fromRGB(255, 255, 255)
                self_highlight_state.los_highlight.FillColor = fill_c3
                self_highlight_state.los_highlight.OutlineColor = outline_c3
                -- write normalized colors back into flags to avoid white default
                if f then
                    f["selfhighlight_fill_color"] = fill_c3
                    f["selfhighlight_outline_color"] = outline_c3
                end
                -- SelfHighlight transparency is controlled ONLY by its own flag
                self_highlight_state.los_highlight.FillTransparency = gflags["selfhighlight_fill_transparency"] or 1
                self_highlight_state.los_highlight.OutlineTransparency = gflags["selfhighlight_outline_transparency"] or 0
            end
            
            -- (occluded highlight removed)
        end
        
        -- UI Elements
        local self_highlight_toggle = local_section:toggle({
            name = "SelfHighlight",
            flag = "selfhighlight_enabled",
            default = false,
            callback = function(state)
                if state then
                    enable_self_highlight()
                else
                    disable_self_highlight()
                end
            end
        })
        
        self_highlight_toggle:colorpicker({
            name = "Fill",
            flag = "selfhighlight_fill_color",
            color = Color3.fromRGB(255, 255, 255),
            callback = function(color)
                local c = color
                if typeof(color) == "table" then
                    c = color.Color or color.Color3 or color.color
                end
                if self_highlight_state.los_highlight then
                    self_highlight_state.los_highlight.FillColor = c 
                end
                if f then f["selfhighlight_fill_color"] = c end
            end
        })
        
        self_highlight_toggle:colorpicker({
            name = "Outline",
            flag = "selfhighlight_outline_color",
            color = Color3.fromRGB(255, 255, 255),
            callback = function(color)
                local c = color
                if typeof(color) == "table" then
                    c = color.Color or color.Color3 or color.color
                end
                if self_highlight_state.los_highlight then
                    self_highlight_state.los_highlight.OutlineColor = c
                end
                if f then f["selfhighlight_outline_color"] = c end
            end
        })
        
        -- Occ controls removed
        
        local dependency_box = local_section:dependency_box()
        dependency_box:setup_dependencies({{self_highlight_toggle, true}})
        
        -- colorpickers moved to toggle (per docs); keep sliders in dependency box
        
        dependency_box:slider({
            name = "FillTr", 
            flag = "selfhighlight_fill_transparency",
            min = 0,
            max = 1,
            default = 1,
            interval = 0.05,
            callback = function(value)
                -- всегда сохраняем флаг, но применяем с учётом SelfMaterial
                if f then f["selfhighlight_fill_transparency"] = value end
                if self_highlight_state.los_highlight then
                    -- no coupling with SelfMaterial
                    self_highlight_state.los_highlight.FillTransparency = value
                end
            end
        })
        
        dependency_box:slider({
            name = "OutlineTr", 
            flag = "selfhighlight_outline_transparency",
            min = 0,
            max = 1,
            default = 0,
            interval = 0.05,
            callback = function(value)
                if f then f["selfhighlight_outline_transparency"] = value end
                if self_highlight_state.los_highlight then
                    self_highlight_state.los_highlight.OutlineTransparency = value
                end
            end
        })
        
        -- Occluded Highlight Controls removed
    end
    
    -- Self Material functionality
    do
        local self_material_state = {
            connection = nil,
            child_conn = nil,
            appearance_conn = nil,
            original_materials = {},
            active = false,
            override_color = nil     -- Color3
        }
        
        local function apply_self_material(character)
            if not character then return end
            
            -- Store original materials and colors if not stored yet
            if not next(self_material_state.original_materials) then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        self_material_state.original_materials[part] = {
                            Material = part.Material,
                            Color = part.Color
                        }
                    end
                end
            end
            
            -- Apply new material
            local f = flags or {}
            local material_enum = Enum.Material.ForceField
            -- colorpicker флаг хранит таблицу { Color = Color3, Transparency = number } — учитываем это
            local color_flag = f["selfmaterial_color"]
            local override_c = self_material_state.override_color
            if typeof(override_c) == "table" then
                override_c = override_c.Color or override_c.color
            end
            local material_color = override_c
                or (typeof(color_flag) == "table" and (color_flag.Color or color_flag.color))
                or (typeof(color_flag) == "Color3" and color_flag)
                or Color3.fromRGB(255, 255, 255)
            
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    if material_enum then
                        part.Material = material_enum
                    end
                    if material_color then
                        part.Color = material_color
                    end
                end
            end
        end
        
        local function restore_original_materials(character)
            if not character then return end
            
            for part, original_material in pairs(self_material_state.original_materials) do
                if part and part.Parent then
                    part.Material = original_material.Material
                    part.Color = original_material.Color
                end
            end
            
            self_material_state.original_materials = {}
        end
        
        -- adjust_self_highlight_for_material: decoupled (no-op)
        local function adjust_self_highlight_for_material(lp)
            -- intentionally empty: SelfMaterial no longer affects SelfHighlight
        end
        
        -- Helpers: hide and restore clothes so ForceField remains visible
        local HIDDEN_FOLDER_NAME = "SimpleBotHiddenClothes"
        local function hide_clothes(character)
            if not character then return end
            local folder = character:FindFirstChild(HIDDEN_FOLDER_NAME)
            if not folder then
                folder = Instance.new("Folder")
                folder.Name = HIDDEN_FOLDER_NAME
                folder.Parent = character
            end
            for _, obj in ipairs(character:GetChildren()) do
                if obj:IsA("Shirt") or obj:IsA("Pants") or obj:IsA("ShirtGraphic") then
                    obj.Parent = folder
                end
            end
        end
        local function restore_clothes(character)
            if not character then return end
            local folder = character:FindFirstChild(HIDDEN_FOLDER_NAME)
            if folder then
                for _, obj in ipairs(folder:GetChildren()) do
                    obj.Parent = character
                end
                folder:Destroy()
            end
        end
        
        local function enable_self_material()
            local lp = (vars and vars.lp) or (game and game:GetService("Players").LocalPlayer)
            if not lp then return end
            
            self_material_state.active = true
            
            if not self_material_state.connection then
                self_material_state.connection = lp.CharacterAdded:Connect(function(char)
                    -- reset originals for new character to capture correct baseline
                    self_material_state.original_materials = {}
                    -- apply after short delay (exactly like self highlight) + a couple retries for late parts
                    local function delayed_apply()
                        if self_material_state.active and char and lp and lp.Character == char then
                            apply_self_material(char)
                            hide_clothes(char)
                        end
                    end
                    task.delay(0.5, delayed_apply)
                    task.delay(1.0, delayed_apply)
                    task.delay(1.5, delayed_apply)
                    -- also re-apply when Roblox finishes loading appearance
                    if self_material_state.appearance_conn then
                        self_material_state.appearance_conn:Disconnect()
                        self_material_state.appearance_conn = nil
                    end
                    self_material_state.appearance_conn = lp.CharacterAppearanceLoaded:Connect(function(loadedChar)
                        if loadedChar ~= char then return end
                        task.delay(0.2, delayed_apply)
                    end)
                end)
            end
            
            local char = lp.Character
            if char then
                -- ensure we store fresh originals for current character
                self_material_state.original_materials = {}
                apply_self_material(char)
                hide_clothes(char)
                -- decoupled: do not touch SelfHighlight here
            end
        end
        
        local function disable_self_material()
            self_material_state.active = false
            
            local lp = (vars and vars.lp) or (game and game:GetService("Players").LocalPlayer)
            if lp and lp.Character then
                restore_clothes(lp.Character)
                restore_original_materials(lp.Character)
                -- decoupled: do not touch SelfHighlight here
            end
            
            if self_material_state.connection then
                self_material_state.connection:Disconnect()
                self_material_state.connection = nil
            end
            if self_material_state.child_conn then
                self_material_state.child_conn:Disconnect()
                self_material_state.child_conn = nil
            end
            if self_material_state.appearance_conn then
                self_material_state.appearance_conn:Disconnect()
                self_material_state.appearance_conn = nil
            end
            -- clear overrides to avoid stale state
            self_material_state.override_material = nil
            self_material_state.override_color = nil
        end
        
        local function update_material()
            if not self_material_state.active then return end
            
            local lp = (vars and vars.lp) or (game and game:GetService("Players").LocalPlayer)
            if lp and lp.Character then
                apply_self_material(lp.Character)
                -- decoupled: do not touch SelfHighlight here
            end
        end
        
        -- UI Elements
        local self_material_toggle = local_section:toggle({
            name = "SelfMaterial",
            flag = "selfmaterial_enabled",
            default = false,
            callback = function(state)
                if state then
                    enable_self_material()
                else
                    disable_self_material()
                end
            end
        })
        
        self_material_toggle:colorpicker({
            name = "Color",
            flag = "selfmaterial_color",
            color = Color3.fromRGB(255, 255, 255),
            callback = function(color)
                -- normalize: callback may pass Color3 or {Color=Color3}
                if typeof(color) == "table" then
                    self_material_state.override_color = color.Color or color.color
                else
                    self_material_state.override_color = color
                end
                update_material()
            end
        })
        
        
    end
    
    -- gaming chair system start
    do
        -- cache services
        local Players = (game and game.GetService and game:GetService("Players"))
        local RunService = (game and game.GetService and game:GetService("RunService"))

        local gc_state = {
            active = false,
            conn = nil,
            run_conn = nil,
            chair = nil,
            chairarms = nil,
            chairlegs = nil,
            chairfan = nil,
            weld = nil,
            highlight = nil,
            trails = {},
            anim = nil,
            color = Color3.fromRGB(255, 255, 255)
        }

        local wheelpositions = {
            Vector3.new(-0.8, -0.6, -0.18),
            Vector3.new(0.1, -0.6, -0.88),
            Vector3.new(0, -0.6, 0.7)
        }

        local function get_lp()
            return (vars and vars.lp) or (Players and Players.LocalPlayer)
        end

        local function destroy_chair()
            if gc_state.trails then
                for _, t in ipairs(gc_state.trails) do
                    if t and t.Parent then t.Enabled = false t:Destroy() end
                end
            end
            gc_state.trails = {}
            if gc_state.highlight then pcall(function() gc_state.highlight:Destroy() end) gc_state.highlight = nil end
            if gc_state.weld then pcall(function() gc_state.weld:Destroy() end) gc_state.weld = nil end
            if gc_state.chairarms then pcall(function() gc_state.chairarms:Destroy() end) gc_state.chairarms = nil end
            if gc_state.chairlegs then pcall(function() gc_state.chairlegs:Destroy() end) gc_state.chairlegs = nil end
            if gc_state.chairfan then pcall(function() gc_state.chairfan:Destroy() end) gc_state.chairfan = nil end
            if gc_state.chair then pcall(function() gc_state.chair:Destroy() end) gc_state.chair = nil end
        end

        local function create_chair(char)
            destroy_chair()
            if not char then return end
            local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso")
            if not root then return end

            -- base chair
            local chair = Instance.new("MeshPart")
            chair.Name = "GamingChair_Base"
            chair.Color = Color3.fromRGB(21, 21, 21)
            chair.Size = Vector3.new(2.16, 3.6, 2.3) / Vector3.new(12.37, 20.636, 13.071)
            chair.CanCollide = false
            chair.Massless = true
            chair.MeshId = "rbxassetid://12972961089"
            chair.Material = Enum.Material.SmoothPlastic
            chair.CFrame = root.CFrame * CFrame.Angles(0, math.rad(-90), 0)
            chair.Parent = workspace

            local chairweld = Instance.new("WeldConstraint")
            chairweld.Part0 = chair
            chairweld.Part1 = root
            chairweld.Parent = chair

            -- outline highlight
            local hl = Instance.new("Highlight")
            hl.FillTransparency = 1
            hl.OutlineColor = gc_state.color
            hl.DepthMode = Enum.HighlightDepthMode.Occluded
            hl.OutlineTransparency = 0.2
            hl.Parent = chair

            -- arms
            local chairarms = Instance.new("MeshPart")
            chairarms.Name = "GamingChair_Arms"
            chairarms.Color = chair.Color
            chairarms.Size = Vector3.new(1.39, 1.345, 2.75) / Vector3.new(97.13, 136.216, 234.031)
            chairarms.CFrame = chair.CFrame * CFrame.new(-0.169, -1.129, -0.013)
            chairarms.MeshId = "rbxassetid://12972673898"
            chairarms.CanCollide = false
            chairarms.Massless = true
            chairarms.Parent = chair
            local chairarmsweld = Instance.new("WeldConstraint")
            chairarmsweld.Part0 = chairarms
            chairarmsweld.Part1 = chair
            chairarmsweld.Parent = chair

            -- legs (no weld; will be positioned manually each frame)
            local chairlegs = Instance.new("MeshPart")
            chairlegs.Color = chair.Color
            chairlegs.Name = "Legs"
            chairlegs.Size = Vector3.new(1.8, 1.2, 1.8) / Vector3.new(10.432, 8.105, 9.488)
            chairlegs.CFrame = chair.CFrame * CFrame.new(0.047, -2.324, 0)
            chairlegs.MeshId = "rbxassetid://13003181606"
            chairlegs.CanCollide = false
            chairlegs.Massless = true
            chairlegs.Parent = chair

            -- fan (no weld; will be positioned manually each frame)
            local chairfan = Instance.new("MeshPart")
            chairfan.Color = chair.Color
            chairfan.Name = "Fan"
            chairfan.Size = Vector3.zero
            chairfan.CFrame = chair.CFrame * CFrame.new(0, -1.873, 0)
            chairfan.MeshId = "rbxassetid://13004977292"
            chairfan.CanCollide = false
            chairfan.Massless = true
            chairfan.Parent = chair

            -- wheel trails
            local trails = {}
            for _, pos in ipairs(wheelpositions) do
                local a0 = Instance.new("Attachment")
                a0.Position = pos
                a0.Parent = chairlegs
                local a1 = Instance.new("Attachment")
                a1.Position = pos + Vector3.new(0, 0, 0.18)
                a1.Parent = chairlegs
                local tr = Instance.new("Trail")
                tr.Texture = "http://www.roblox.com/asset/?id=13005168530"
                tr.TextureMode = Enum.TextureMode.Static
                tr.Transparency = NumberSequence.new(0.5)
                tr.Color = ColorSequence.new(Color3.new(0.5, 0.5, 0.5))
                tr.Attachment0 = a0
                tr.Attachment1 = a1
                tr.Lifetime = 0.8
                tr.MaxLength = 60
                tr.MinLength = 0.1
                tr.Parent = chairlegs
                table.insert(trails, tr)
            end

            gc_state.chair = chair
            gc_state.chairarms = chairarms
            gc_state.chairlegs = chairlegs
            gc_state.chairfan = chairfan
            gc_state.weld = chairweld
            gc_state.highlight = hl
            gc_state.trails = trails
        end

        local function bind_character(char)
            if not gc_state.active then return end
            create_chair(char)
            if gc_state.run_conn then gc_state.run_conn:Disconnect() gc_state.run_conn = nil end
            if not RunService then return end
            gc_state.run_conn = RunService.RenderStepped:Connect(function()
                if not gc_state.chair then return end
                local lp = get_lp()
                local character = lp and lp.Character
                local hum = character and character:FindFirstChildOfClass("Humanoid")
                local root = character and (character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso"))
                if not (hum and root and hum.Health > 0) then
                    if gc_state.anim then pcall(function() gc_state.anim:Stop() end) gc_state.anim = nil end
                    return
                end

                -- ensure sitting animation is playing
                if not (gc_state.anim and gc_state.anim.IsPlaying) then
                    local anim = Instance.new("Animation")
                    anim.AnimationId = (hum.RigType == Enum.HumanoidRigType.R15)
                        and "http://www.roblox.com/asset/?id=2506281703"
                        or "http://www.roblox.com/asset/?id=178130996"
                    local animator = hum:FindFirstChildOfClass("Animator")
                    if not animator then
                        animator = Instance.new("Animator")
                        animator.Parent = hum
                    end
                    local track = animator:LoadAnimation(anim)
                    track.Priority = Enum.AnimationPriority.Action
                    track.Looped = true
                    track:Play(0.1, 1, 1)
                    gc_state.anim = track
                end
                -- align base chair and weld each frame (as in reference)
                gc_state.chair.CFrame = root.CFrame * CFrame.Angles(0, math.rad(-90), 0)
                if gc_state.weld and gc_state.weld.Part1 ~= root then
                    gc_state.weld.Part1 = root
                end
                -- align children and animate
                if gc_state.chairlegs then
                    gc_state.chairlegs.Velocity = Vector3.zero
                    gc_state.chairlegs.CFrame = gc_state.chair.CFrame * CFrame.new(0.047, -2.324, 0)
                end
                if gc_state.chairfan then
                    gc_state.chairfan.Velocity = Vector3.zero
                    gc_state.chairfan.CFrame = gc_state.chair.CFrame * CFrame.new(0.047, -1.873, 0) * CFrame.Angles(0, math.rad((os.clock() * 180) % 360), math.rad(180))
                end
            end)
        end

        local function enable_gc()
            local lp = get_lp()
            if not lp then return end
            gc_state.active = true
            if gc_state.conn then gc_state.conn:Disconnect() gc_state.conn = nil end
            gc_state.conn = lp.CharacterAdded:Connect(function(char)
                task.wait(0.3)
                bind_character(char)
            end)
            if lp.Character then
                bind_character(lp.Character)
            end
        end

        local function disable_gc()
            gc_state.active = false
            if gc_state.run_conn then gc_state.run_conn:Disconnect() gc_state.run_conn = nil end
            if gc_state.conn then gc_state.conn:Disconnect() gc_state.conn = nil end
            if gc_state.anim then pcall(function() gc_state.anim:Stop() end) gc_state.anim = nil end
            destroy_chair()
        end

        -- UI (directly in Local section)
        local gc_toggle = local_section:toggle({
            name = "GamingChair",
            flag = "gamingchair_enabled",
            default = false,
            callback = function(state)
                if state then
                    enable_gc()
                else
                    disable_gc()
                end
            end
        })

        gc_toggle:colorpicker({
            name = "Color",
            flag = "gamingchair_color",
            color = gc_state.color,
            callback = function(color)
                local c = color
                if typeof(color) == "table" then
                    c = color.Color or color.Color3 or color.color
                end
                gc_state.color = c
                if gc_state.highlight then
                    gc_state.highlight.OutlineColor = c
                end
            end
        })
    end
    -- gaming chair system end

    -- trail system start
    do
        -- Services
        local Players = (game and game.GetService and game:GetService("Players"))
        local RunService = (game and game.GetService and game:GetService("RunService"))

        -- Defaults for config
        Config = Config or {}
        Config.Trails = Config.Trails or {
            Enabled = false,
            Color = Color3.fromRGB(255, 255, 255),
            Transparency = 0.5,
            Length = 0.6,
            Width = 1,
            MinLength = 0.1,
            Type = "Basic",
            Origin = "Body",
        }

        local tr_state = {
            active = false,
            run_conn = nil,
            char_conn = nil,
            a0 = nil,
            a1 = nil,
            trail = nil,
            leg_attach = nil,
        }

        -- Style helpers (avoid textures to keep dependencies minimal; focus on visual patterning)
        local function build_transparency_ns(style, base)
            local t = style or "Basic"
            local b = typeof(base) == "number" and base or 0.5
            b = math.clamp(b, 0, 1)
            if t == "Bright" then
                -- Starts more opaque, fades to configured value
                return NumberSequence.new({
                    NumberSequenceKeypoint.new(0, math.clamp(b * 0.2, 0, 1)),
                    NumberSequenceKeypoint.new(0.5, math.clamp(b * 0.5, 0, 1)),
                    NumberSequenceKeypoint.new(1, b)
                })
            elseif t == "Dash" then
                -- Create gaps by being fully transparent at ends
                return NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 1),
                    NumberSequenceKeypoint.new(0.5, b),
                    NumberSequenceKeypoint.new(1, 1)
                })
            elseif t == "Shadow" then
                -- Overall more subtle/transparent
                return NumberSequence.new({
                    NumberSequenceKeypoint.new(0, math.clamp(b * 0.8, 0, 1)),
                    NumberSequenceKeypoint.new(1, 1)
                })
            end
            -- Basic
            return NumberSequence.new(b)
        end

        local function get_lifetime_for_style(style, base)
            local t = style or "Basic"
            local l = typeof(base) == "number" and base or 0.6
            if t == "Bright" then
                return 1
            elseif t == "Dash" then
                return 0.25
            elseif t == "Shadow" then
                return 1
            end
            return l
        end

        local function get_lp()
            return Players and Players.LocalPlayer
        end

        local function ensure_trail(hrp)
            if not hrp then return end
            -- attachments
            if not tr_state.a0 or tr_state.a0.Parent ~= hrp then
                tr_state.a0 = Instance.new("Attachment")
                tr_state.a0.Name = "SimpleBotTrailA0"
                tr_state.a0.Position = Vector3.new(0.5, 0, 0)
                tr_state.a0.Parent = hrp
            end
            if not tr_state.a1 or tr_state.a1.Parent ~= hrp then
                tr_state.a1 = Instance.new("Attachment")
                tr_state.a1.Name = "SimpleBotTrailA1"
                tr_state.a1.Position = Vector3.new(-0.5, 0, 0)
                tr_state.a1.Parent = hrp
            end
            -- trail
            if not tr_state.trail or tr_state.trail.Parent ~= hrp then
                tr_state.trail = Instance.new("Trail")
                tr_state.trail.Name = "SimpleBotTrail"
                tr_state.trail.Parent = hrp
            end

            -- apply props
            tr_state.trail.Attachment0 = tr_state.a0
            tr_state.trail.Attachment1 = tr_state.a1
            -- origin handling: Body (default) or Legs via helper attachment
            if (Config.Trails.Origin == "Legs") then
                -- ensure helper attachment exists on HRP
                tr_state.leg_attach = hrp:FindFirstChild("CustomLegAttach")
                if not tr_state.leg_attach then
                    local leg = Instance.new("Attachment")
                    leg.Name = "CustomLegAttach"
                    leg.CFrame = CFrame.new(0, -2.7, 0)
                    leg.Parent = hrp
                    tr_state.leg_attach = leg
                end
                -- offsets relative to legs attachment (forward/back along Z)
                if tr_state.a0 then tr_state.a0.CFrame = tr_state.leg_attach.CFrame * CFrame.new(0, 0, -0.677116394) end
                if tr_state.a1 then tr_state.a1.CFrame = tr_state.leg_attach.CFrame * CFrame.new(0, 0, 0.687942505) end
            else
                -- Body origin: match example (forward/back along Z) from HRP origin
                if tr_state.a0 then tr_state.a0.CFrame = CFrame.new(0, 0, -0.677116394) end
                if tr_state.a1 then tr_state.a1.CFrame = CFrame.new(0, 0, 0.687942505) end
            end
            tr_state.trail.Color = ColorSequence.new(Config.Trails.Color)
            tr_state.trail.Transparency = build_transparency_ns(Config.Trails.Type, Config.Trails.Transparency)
            tr_state.trail.Lifetime = get_lifetime_for_style(Config.Trails.Type, Config.Trails.Length)
            -- Width profile per style: Bright/Dash/Shadow = fade to 0; Basic = constant thin line
            do
                local w = (Config.Trails.Width or 1) / 3.2
                local tstyle = Config.Trails.Type
                if tstyle == "Bright" or tstyle == "Dash" or tstyle == "Shadow" then
                    tr_state.trail.WidthScale = NumberSequence.new({
                        NumberSequenceKeypoint.new(0, w),
                        NumberSequenceKeypoint.new(1, 0)
                    })
                else
                    tr_state.trail.WidthScale = NumberSequence.new(w)
                end
            end
            -- MinLength per style (Basic uses 0 by default, others respect config)
            if Config.Trails.Type == "Basic" then
                tr_state.trail.MinLength = 0
            else
                tr_state.trail.MinLength = Config.Trails.MinLength
            end
            tr_state.trail.FaceCamera = true
            tr_state.trail.Enabled = true

            -- apply texture per style
            local t = (Config.Trails and Config.Trails.Type) or "Basic"
            if t == "Bright" then
                tr_state.trail.Texture = "rbxassetid://9234319472"
                tr_state.trail.Brightness = 20
                tr_state.trail.LightEmission = 0
            elseif t == "Dash" then
                tr_state.trail.Texture = "http://www.roblox.com/asset/?id=13703813488"
                tr_state.trail.LightEmission = 1
                tr_state.trail.Brightness = 20
            elseif t == "Shadow" then
                tr_state.trail.Texture = "rbxassetid://9234319472"
                tr_state.trail.LightEmission = 0
                tr_state.trail.Brightness = 0
            elseif t == "Basic" then
                -- keep default texture; force static mode and longer max length similar to example
                tr_state.trail.Texture = ""
                tr_state.trail.TextureMode = Enum.TextureMode.Static
                tr_state.trail.MaxLength = 400
                tr_state.trail.LightEmission = 1
                -- Basic keeps current Brightness unless customized
            end
        end

        local function disable_trail_only()
            if tr_state.trail then
                tr_state.trail.Enabled = false
            end
        end

        local function apply_trail()
            local lp = get_lp()
            local char = lp and lp.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")

            if not Config.Trails.Enabled or not hrp then
                disable_trail_only()
                return
            end

            ensure_trail(hrp)
        end

        local function bind_character(char)
            if not tr_state.active then return end
            apply_trail()
        end

        local function enable_trails()
            if tr_state.active then return end
            tr_state.active = true
            Config.Trails.Enabled = true
            local lp = get_lp()
            if tr_state.char_conn then tr_state.char_conn:Disconnect() tr_state.char_conn = nil end
            if lp then
                tr_state.char_conn = lp.CharacterAdded:Connect(function(char)
                    task.wait(0.1)
                    bind_character(char)
                end)
                if lp.Character then bind_character(lp.Character) end
            end
            if tr_state.run_conn then tr_state.run_conn:Disconnect() tr_state.run_conn = nil end
            if RunService then
                tr_state.run_conn = RunService.RenderStepped:Connect(apply_trail)
            end
        end

        local function disable_trails()
            tr_state.active = false
            Config.Trails.Enabled = false
            if tr_state.run_conn then tr_state.run_conn:Disconnect() tr_state.run_conn = nil end
            if tr_state.char_conn then tr_state.char_conn:Disconnect() tr_state.char_conn = nil end
            disable_trail_only()
        end

        -- UI
        local trail_toggle = local_section:toggle({
            name = "Trail",
            flag = "trail_enabled",
            default = false,
            callback = function(state)
                if state then enable_trails() else disable_trails() end
            end
        })

        trail_toggle:colorpicker({
            name = "Color",
            flag = "trail_color",
            color = Config.Trails.Color,
            callback = function(color)
                local c = color
                if typeof(color) == "table" then
                    c = color.Color or color.Color3 or color.color
                end
                Config.Trails.Color = c
                apply_trail()
            end
        })

        -- dependency box with controls
        local tr_dep = local_section:dependency_box()
        tr_dep:setup_dependencies({ { trail_toggle, true } })

        -- Type selector
        tr_dep:dropdown({
            name = "Type",
            flag = "trail_type",
            items = {"Basic", "Bright", "Dash", "Shadow"},
            default = Config.Trails.Type or "Basic",
            callback = function(val)
                Config.Trails.Type = val or "Basic"
                apply_trail()
            end
        })

        -- Origin selector
        tr_dep:dropdown({
            name = "Origin",
            flag = "trail_origin",
            items = {"Body", "Legs"},
            default = Config.Trails.Origin or "Body",
            callback = function(val)
                Config.Trails.Origin = val or "Body"
                apply_trail()
            end
        })

        -- Length slider
        tr_dep:slider({
            name = "Len",
            flag = "trail_len",
            min = 0.05, max = 3, default = Config.Trails.Length or 0.6, interval = 0.05,
            callback = function(v)
                Config.Trails.Length = v
                apply_trail()
            end
        })

        -- Width slider
        tr_dep:slider({
            name = "Wdt",
            flag = "trail_wdt",
            min = 0.05, max = 10, default = Config.Trails.Width or 1, interval = 0.05,
            callback = function(v)
                Config.Trails.Width = v
                apply_trail()
            end
        })

        -- Transparency slider
        tr_dep:slider({
            name = "Trs",
            flag = "trail_trs",
            min = 0, max = 1, default = Config.Trails.Transparency or 0.5, interval = 0.05,
            callback = function(v)
                Config.Trails.Transparency = v
                apply_trail()
            end
        })

        -- MinLength slider
        tr_dep:slider({
            name = "Min",
            flag = "trail_min",
            min = 0, max = 1, default = Config.Trails.MinLength or 0.1, interval = 0.01,
            callback = function(v)
                Config.Trails.MinLength = v
                apply_trail()
            end
        })
    end
    -- trail system end
    
    -- JumpCircles (Local Visuals)
    do
        -- jump circles system start
        Config = Config or {}
        Config.JumpCircles = Config.JumpCircles or {
            Enabled = false,
            Size = 6,
            Color1 = Color3.new(1, 1, 1),
            LifeAfterMax = 0,
            Type = "v1",
            Transparency = 0,
        }

        local jc_state = {
            active = false,
            hum_conn = nil,
            char_conn = nil,
            color = Config.JumpCircles.Color1,
        }

        local function get_jc_asset()
            local t = (Config.JumpCircles and Config.JumpCircles.Type) or "v1"
            if t == "v2" then return "rbxassetid://7185003058" end
            if t == "v3" then return "rbxassetid://12363804869" end
            if t == "v4" then return "rbxassetid://12363857726" end
            return "rbxassetid://7216856276" -- v1 default
        end

        local function spawn_jump_circle(pos, col)
            local part = Instance.new("Part")
            part.Name = "SB_JumpCircle"
            part.Anchored = true
            part.CanCollide = false
            part.Material = Enum.Material.SmoothPlastic
            part.Transparency = 1
            part.Size = Vector3.new(1, 0.05, 1)
            part.CFrame = CFrame.new(pos)
            part.Parent = workspace

            local gui = Instance.new("SurfaceGui")
            gui.Name = "SB_JumpCircleGui"
            gui.Face = Enum.NormalId.Top
            gui.AlwaysOnTop = true
            gui.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
            gui.PixelsPerStud = 64
            gui.Parent = part

            local img = Instance.new("ImageLabel")
            img.Name = "Image"
            img.BackgroundTransparency = 1
            img.Image = get_jc_asset()
            img.ImageColor3 = col or jc_state.color or (Config.JumpCircles and Config.JumpCircles.Color1) or Color3.new(1,1,1)
            img.ImageTransparency = (Config.JumpCircles and Config.JumpCircles.Transparency) or 0
            img.Size = UDim2.fromScale(1, 1)
            img.Parent = gui

            task.spawn(function(p)
                local run = game:GetService("RunService")
                local g = p and p:FindFirstChild("SB_JumpCircleGui")
                local il = g and g:FindFirstChild("Image")
                local t, dur = 0, 0.6
                while t < dur do
                    t = t + run.Heartbeat:Wait()
                    local k = math.clamp(t / dur, 0, 1)
                    local s = (Config.JumpCircles and Config.JumpCircles.Size or 6) * k
                    if p then
                        p.Size = Vector3.new(math.max(0.1, s), 0.05, math.max(0.1, s))
                    end
                    if il then
                        il.ImageTransparency = (Config.JumpCircles and Config.JumpCircles.Transparency) or 0
                    end
                end
                local hold = (Config.JumpCircles and Config.JumpCircles.LifeAfterMax) or 0
                if hold > 0 then
                    local ht = 0
                    while ht < hold do
                        ht = ht + run.Heartbeat:Wait()
                        if il then
                            il.ImageTransparency = (Config.JumpCircles and Config.JumpCircles.Transparency) or 0
                        end
                    end
                end
                if p then p:Destroy() end
            end, part)
        end

        local function bind_character(char)
            if not char then return end
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not hum then return end
            if jc_state.hum_conn then jc_state.hum_conn:Disconnect() jc_state.hum_conn = nil end
            jc_state.hum_conn = hum.StateChanged:Connect(function(_, new)
                if not jc_state.active then return end
                if new ~= Enum.HumanoidStateType.Jumping then return end
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                local origin = hrp.Position
                local params = RaycastParams.new()
                params.FilterType = Enum.RaycastFilterType.Blacklist
                params.FilterDescendantsInstances = {char}
                local hit = workspace:Raycast(origin, Vector3.new(0, -25, 0), params)
                local pos = hit and (hit.Position + Vector3.new(0, -0.1, 0)) or (origin + Vector3.new(0, -2.8, 0))
                spawn_jump_circle(pos, jc_state.color)
            end)
        end

        local function enable_jump_circles()
            jc_state.active = true
            Config.JumpCircles.Enabled = true
            jc_state.color = Config.JumpCircles.Color1
            local lp = (vars and vars.lp) or game:GetService("Players").LocalPlayer
            if jc_state.char_conn then jc_state.char_conn:Disconnect() jc_state.char_conn = nil end
            jc_state.char_conn = lp.CharacterAdded:Connect(function(ch)
                task.defer(function()
                    bind_character(ch)
                end)
            end)
            if lp.Character then bind_character(lp.Character) end
        end

        local function disable_jump_circles()
            jc_state.active = false
            Config.JumpCircles.Enabled = false
            if jc_state.hum_conn then jc_state.hum_conn:Disconnect() jc_state.hum_conn = nil end
            if jc_state.char_conn then jc_state.char_conn:Disconnect() jc_state.char_conn = nil end
        end

        local jc_toggle = local_section:toggle({
            name = "JumpCircles",
            flag = "jumpcircles_enabled",
            default = Config.JumpCircles.Enabled,
            callback = function(state)
                if state then enable_jump_circles() else disable_jump_circles() end
            end
        })

        jc_toggle:colorpicker({
            name = "Color",
            flag = "jumpcircles_color",
            color = Config.JumpCircles.Color1,
            callback = function(color)
                local c = color
                if typeof(color) == "table" then
                    c = color.Color or color.Color3 or color.color
                end
                Config.JumpCircles.Color1 = c
                jc_state.color = c
            end
        })
        
        -- dependency controls
        local jc_dep = local_section:dependency_box()
        jc_dep:setup_dependencies({ { jc_toggle, true } })

        jc_dep:dropdown({
            name = "Type",
            flag = "jumpcircles_type",
            items = {"v1", "v2", "v3", "v4"},
            default = (Config.JumpCircles and Config.JumpCircles.Type) or "v1",
            callback = function(val)
                Config.JumpCircles.Type = val or "v1"
            end
        })

        jc_dep:slider({
            name = "Sz",
            flag = "jumpcircles_size",
            min = 0.1, max = 12, default = (Config.JumpCircles and Config.JumpCircles.Size) or 6, interval = 0.1,
            callback = function(v)
                Config.JumpCircles.Size = v
            end
        })

        jc_dep:slider({
            name = "Life",
            flag = "jumpcircles_life",
            min = 0, max = 3, default = (Config.JumpCircles and Config.JumpCircles.LifeAfterMax) or 0, interval = 0.05,
            callback = function(v)
                Config.JumpCircles.LifeAfterMax = v
            end
        })
        
        jc_dep:slider({
            name = "Trs",
            flag = "jumpcircles_transparency",
            min = 0, max = 1, default = (Config.JumpCircles and Config.JumpCircles.Transparency) or 0, interval = 0.05,
            callback = function(v)
                Config.JumpCircles.Transparency = v
            end
        })
        -- jump circles system end
    end
    -- color correction system start
    do
        Config = Config or {}
        Config.ColorCorrection = Config.ColorCorrection or {
            Enabled = false,
            Brightness = 0,
            Contrast = 0,
            Saturation = 0,
            TintColor = Color3.fromRGB(255, 255, 255),
        }
        Config.Ambient = Config.Ambient or {
            Enabled = false,
            Color = Color3.fromRGB(255, 255, 255),
        }
        Config.Atmosphere = Config.Atmosphere or {
            Enabled = false,
            Color = Color3.fromRGB(255, 255, 255),
            Decay = Color3.fromRGB(0, 0, 0),
            Density = 0,
            Offset = 0,
            Glare = 0,
            Haze = 0,
        }
        Config.Bloom = Config.Bloom or {
            Enabled = false,
            Intensity = 1,
            Size = 24,
            Threshold = 0.7,
        }
        Config.Textures = Config.Textures or {
            Enabled = false,
            Selected = "Plastic",
        }
        Config.Skybox = Config.Skybox or {
            Enabled = false,
            Selected = "Night Sky",
        }
        Config.Time = Config.Time or {
            Enabled = false,
            Hours = 12,
            Minutes = 0,
        }

        Config.FOV = Config.FOV or {
            Enabled = false,
            Value = 70,
        }

        Config.AspectRatio = Config.AspectRatio or {
            Enabled = false,
            Horizontal = 100,
            Vertical = 100,
        }

        Config.ThirdPerson = Config.ThirdPerson or {
            Enabled = false,
            X = 0,
            Y = 0,
            Z = 0,
        }

        Config.Crosshair = Config.Crosshair or {
            Enabled = false,
            Sides = 4,
            Length = 10,
            GapSize = 5,
            Thickness = 2,
            CrosshairColor = Color3.fromRGB(255, 255, 255),
            OutlineColor = Color3.fromRGB(0, 0, 0),
            AttachToTarget = false,
            AlwaysRotating = false,
            Speed = 1,
            Pulse = false,
            Position = "mouse",
            UseInset = true,
        }

        local function apply_color_correction()
            local Lighting = (game and game.GetService and game:GetService("Lighting"))
            if not Lighting then return end

            -- cleanup old typo-named effects to avoid stacking
            for _, obj in ipairs(Lighting:GetChildren()) do
                if obj.ClassName == "ColorCorrectionEffect" and (obj.Name == "RebuilColorCorrection") then
                    obj:Destroy()
                end
            end

            local EFF_NAME = "RebuildColorCorrection"
            local cc = Config.ColorCorrection or {}

            -- when disabled: remove our effect to fully revert to game's default CC
            if not (cc.Enabled and true or false) then
                local old = Lighting:FindFirstChild(EFF_NAME)
                if old then old:Destroy() end
                return
            end

            -- ensure our effect exists only when enabled
            local eff = Lighting:FindFirstChild(EFF_NAME)
            if not eff then
                eff = Instance.new("ColorCorrectionEffect")
                eff.Name = EFF_NAME
                eff.Parent = Lighting
            end

            -- clamp to soft bounds so changes aren't too strong
            local b = typeof(cc.Brightness) == "number" and math.clamp(cc.Brightness, -0.5, 0.5) or 0
            local ct = typeof(cc.Contrast) == "number" and math.clamp(cc.Contrast, 0, 1) or 0
            local s = typeof(cc.Saturation) == "number" and math.clamp(cc.Saturation, -0.5, 0.5) or 0
            eff.Brightness = b
            eff.Contrast = ct
            eff.Saturation = s
            if cc.TintColor then
                local c = cc.TintColor
                if typeof(c) == "table" then
                    c = c.Color or c.Color3 or c.color
                end
                eff.TintColor = c
            end
            eff.Enabled = true
        end

        -- textures apply helpers
        local textures_state = {
            originals = {},
            connections = {},
            materials = nil,
        }

        local Players = (B and B.ps) or (game and game.GetService and game:GetService("Players"))
        local Workspace = (game and game.GetService and game:GetService("Workspace")) or workspace

        local function is_character_descendant(inst)
            local part = inst
            while part and part.Parent do
                if part:IsA("Model") then
                    local hum = part:FindFirstChildOfClass("Humanoid")
                    if hum then
                        local plr = Players and Players:GetPlayerFromCharacter(part)
                        return plr ~= nil
                    end
                end
                part = part.Parent
            end
            return false
        end

        local function ensure_material_list()
            if textures_state.materials then return textures_state.materials end
            local list = {}
            for _, m in ipairs(Enum.Material:GetEnumItems()) do
                table.insert(list, m.Name)
            end
            textures_state.materials = list
            return list
        end

        local function apply_material_to_part(part)
            if not part or not part:IsA("BasePart") then return end
            if is_character_descendant(part) then return end
            if textures_state.originals[part] == nil then
                textures_state.originals[part] = part.Material
            end
            local sel = (Config.Textures and Config.Textures.Selected) or "Plastic"
            local mat = Enum.Material[sel] or Enum.Material.Plastic
            part.Material = mat
        end

        local function enable_textures()
            if not Workspace then return end
            -- initial pass
            for _, d in ipairs(Workspace:GetDescendants()) do
                if d:IsA("BasePart") then
                    apply_material_to_part(d)
                end
            end
            -- hook new parts
            if textures_state.connections.DescAdded then
                if typeof(textures_state.connections.DescAdded) == "RBXScriptConnection" then
                    textures_state.connections.DescAdded:Disconnect()
                end
                textures_state.connections.DescAdded = nil
            end
            textures_state.connections.DescAdded = Workspace.DescendantAdded:Connect(function(d)
                if d and d:IsA("BasePart") then
                    apply_material_to_part(d)
                end
            end)
        end

        local function disable_textures()
            -- disconnect
            for k, conn in pairs(textures_state.connections) do
                if typeof(conn) == "RBXScriptConnection" then conn:Disconnect() end
                textures_state.connections[k] = nil
            end
            -- restore
            for inst, mat in pairs(textures_state.originals) do
                if inst and inst.Parent then
                    pcall(function()
                        inst.Material = mat
                    end)
                end
            end
            textures_state.originals = {}
        end

        -- skybox helpers
        local skyboxes_map = {
            ["Purple Nebula"] = {SkyboxBk = "rbxassetid://159454299", SkyboxDn = "rbxassetid://159454296", SkyboxFt = "rbxassetid://159454293", SkyboxLf = "rbxassetid://159454286", SkyboxRt = "rbxassetid://159454300", SkyboxUp = "rbxassetid://159454288"},
            ["Night Sky"] = {SkyboxBk = "rbxassetid://12064107", SkyboxDn = "rbxassetid://12064152", SkyboxFt = "rbxassetid://12064121", SkyboxLf = "rbxassetid://12063984", SkyboxRt = "rbxassetid://12064115", SkyboxUp = "rbxassetid://12064131"},
            ["Pink Daylight"] = {SkyboxBk = "rbxassetid://271042516", SkyboxDn = "rbxassetid://271077243", SkyboxFt = "rbxassetid://271042556", SkyboxLf = "rbxassetid://271042310", SkyboxRt = "rbxassetid://271042467", SkyboxUp = "rbxassetid://271077958"},
            ["Morning Glow"] = {SkyboxBk = "rbxassetid://1417494030", SkyboxDn = "rbxassetid://1417494146", SkyboxFt = "rbxassetid://1417494253", SkyboxLf = "rbxassetid://1417494402", SkyboxRt = "rbxassetid://1417494499", SkyboxUp = "rbxassetid://1417494643"},
            ["Setting Sun"] = {SkyboxBk = "rbxassetid://626460377", SkyboxDn = "rbxassetid://626460216", SkyboxFt = "rbxassetid://626460513", SkyboxLf = "rbxassetid://626473032", SkyboxRt = "rbxassetid://626458639", SkyboxUp = "rbxassetid://626460625"},
            ["Cache"] = {SkyboxBk = "rbxassetid://220513302", SkyboxDn = "rbxassetid://213221473", SkyboxFt = "rbxassetid://220513328", SkyboxLf = "rbxassetid://220513318", SkyboxRt = "rbxassetid://220513279", SkyboxUp = "rbxassetid://220513345"},
            ["Fade Blue"] = {SkyboxBk = "rbxassetid://153695414", SkyboxDn = "rbxassetid://153695352", SkyboxFt = "rbxassetid://153695452", SkyboxLf = "rbxassetid://153695320", SkyboxRt = "rbxassetid://153695383", SkyboxUp = "rbxassetid://153695471"},
            ["Elegant Morning"] = {SkyboxBk = "rbxassetid://153767241", SkyboxDn = "rbxassetid://153767216", SkyboxFt = "rbxassetid://153767266", SkyboxLf = "rbxassetid://153767200", SkyboxRt = "rbxassetid://153767231", SkyboxUp = "rbxassetid://153767288"},
            ["Neptune"] = {SkyboxBk = "rbxassetid://218955819", SkyboxDn = "rbxassetid://218953419", SkyboxFt = "rbxassetid://218954524", SkyboxLf = "rbxassetid://218958493", SkyboxRt = "rbxassetid://218957134", SkyboxUp = "rbxassetid://218950090"},
            ["Redshift"] = {SkyboxBk = "rbxassetid://401664839", SkyboxDn = "rbxassetid://401664862", SkyboxFt = "rbxassetid://401664960", SkyboxLf = "rbxassetid://401664881", SkyboxRt = "rbxassetid://401664901", SkyboxUp = "rbxassetid://401664936"},
            ["Aesthetic Night"] = {SkyboxBk = "rbxassetid://1045964490", SkyboxDn = "rbxassetid://1045964368", SkyboxFt = "rbxassetid://1045964655", SkyboxLf = "rbxassetid://1045964655", SkyboxRt = "rbxassetid://1045964655", SkyboxUp = "rbxassetid://1045962969"},
            ["Minecraft"] = {SkyboxBk = "rbxassetid://1876545003", SkyboxDn = "rbxassetid://1876544331", SkyboxFt = "rbxassetid://1876542941", SkyboxLf = "rbxassetid://1876543392", SkyboxRt = "rbxassetid://1876543764", SkyboxUp = "rbxassetid://1876544642"},
        }

        local function ensure_skybox_list()
            if textures_state and textures_state.s_items then return textures_state.s_items end
            local t = {}
            for name, _ in pairs(skyboxes_map) do table.insert(t, name) end
            table.sort(t)
            if textures_state then textures_state.s_items = t end
            return t
        end

        local function apply_skybox()
            local Lighting = (game and game.GetService and game:GetService("Lighting"))
            if not Lighting then return end
            local sc = Config.Skybox or {}
            local EFF_NAME = "RebuildSky"
            if not (sc.Enabled and true or false) then
                local old = Lighting:FindFirstChild(EFF_NAME)
                if old then old:Destroy() end
                return
            end
            local eff = Lighting:FindFirstChild(EFF_NAME)
            if not eff then
                eff = Instance.new("Sky")
                eff.Name = EFF_NAME
                eff.Parent = Lighting
            end
            local sel = sc.Selected or "Night Sky"
            local data = skyboxes_map[sel]
            if not data then return end
            eff.SkyboxBk = data.SkyboxBk
            eff.SkyboxDn = data.SkyboxDn
            eff.SkyboxFt = data.SkyboxFt
            eff.SkyboxLf = data.SkyboxLf
            eff.SkyboxRt = data.SkyboxRt
            eff.SkyboxUp = data.SkyboxUp
        end

        -- time changer helper
        local originalClockTime
        local function apply_time()
            local Lighting = (game and game.GetService and game:GetService("Lighting"))
            if not Lighting then return end
            local tc = Config.Time or {}
            local enabled = tc.Enabled and true or false
            if enabled then
                if originalClockTime == nil then
                    originalClockTime = Lighting.ClockTime
                end
                local h = typeof(tc.Hours) == "number" and math.clamp(tc.Hours, 0, 23) or 12
                local m = typeof(tc.Minutes) == "number" and math.clamp(tc.Minutes, 0, 59) or 0
                Lighting.ClockTime = h + (m / 60)
            else
                if originalClockTime ~= nil then
                    Lighting.ClockTime = originalClockTime
                    originalClockTime = nil -- reset to capture fresh baseline on next enable
                end
            end
        end

        -- field of view helper (Random section)
        local originalFOV
        local fov_conn
        local function apply_fov()
            local ws = Workspace or (game and game.GetService and game:GetService("Workspace")) or workspace
            local cam = ws and ws.CurrentCamera
            if not cam then return end
            local fc = Config.FOV or {}
            if fc.Enabled then
                if originalFOV == nil then
                    originalFOV = cam.FieldOfView
                end
                local v = typeof(fc.Value) == "number" and math.clamp(fc.Value, 1, 180) or 70
                cam.FieldOfView = v
                -- keep value against external resets
                if fov_conn then
                    if typeof(fov_conn) == "RBXScriptConnection" then fov_conn:Disconnect() end
                    fov_conn = nil
                end
                local RS = (B and B.run)
                if RS and RS.RenderStepped then
                    fov_conn = RS.RenderStepped:Connect(function()
                        cam.FieldOfView = v
                    end)
                end
            else
                if fov_conn then
                    if typeof(fov_conn) == "RBXScriptConnection" then fov_conn:Disconnect() end
                    fov_conn = nil
                end
                if originalFOV ~= nil then
                    pcall(function()
                        cam.FieldOfView = originalFOV
                    end)
                    originalFOV = nil
                end
            end
        end

        -- ambient apply helper
        -- aspect ratio helper (Random section)
        local aspect_conn
        local function apply_aspect_ratio()
            local ws = Workspace or (game and game.GetService and game:GetService("Workspace")) or workspace
            local cam = ws and ws.CurrentCamera
            if not cam then return end
            local acfg = Config.AspectRatio or {}
            local enabled = acfg.Enabled and true or false
            -- cleanup prev conn
            if aspect_conn then
                if typeof(aspect_conn) == "RBXScriptConnection" then pcall(function() aspect_conn:Disconnect() end) end
                aspect_conn = nil
            end
            if not enabled then
                return
            end
            local RS = (B and B.run)
            if RS and RS.RenderStepped then
                aspect_conn = RS.RenderStepped:Connect(function()
                    local hPerc = typeof(acfg.Horizontal) == "number" and acfg.Horizontal or 100
                    local vPerc = typeof(acfg.Vertical) == "number" and acfg.Vertical or 100
                    -- allow stretch (>100) and shrink (<100): 50%..120%
                    local h = math.clamp(hPerc, 50, 120) / 100
                    local v = math.clamp(vPerc, 50, 120) / 100
                    local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cam.CFrame:GetComponents()
                    cam.CFrame = CFrame.new(
                        X, Y, Z,
                        R00 * h,
                        R01 * v,
                        R02,
                        R10,
                        R11 * v,
                        R12,
                        R20 * h,
                        R21 * v,
                        R22
                    )
                end)
            end
        end
        
        -- third person helper (Random section)
        local third_conn
        local function apply_third_person()
            local ws = Workspace or (game and game.GetService and game:GetService("Workspace")) or workspace
            local cam = ws and ws.CurrentCamera
            if not cam then return end
            local tcfg = Config.ThirdPerson or {}
            -- cleanup prev conn
            if third_conn then
                if typeof(third_conn) == "RBXScriptConnection" then pcall(function() third_conn:Disconnect() end) end
                third_conn = nil
            end
            if not (tcfg.Enabled and true or false) then
                return
            end
            local RS = (B and B.run)
            if RS and RS.RenderStepped then
                third_conn = RS.RenderStepped:Connect(function()
                    local x = typeof(tcfg.X) == "number" and tcfg.X or 0
                    local y = typeof(tcfg.Y) == "number" and tcfg.Y or 0
                    local z = typeof(tcfg.Z) == "number" and tcfg.Z or 0
                    cam.CFrame = cam.CFrame * CFrame.new(x, y, z)
                end)
            end
        end
        
        -- crosshair helper (Random section)
        local crosshair_state = {
            lines = {},
            outlines = {},
            connection = nil,
            line_offsets = {},
            spin_angle = 0,
            cursor_size = 0,
        }
        
        local function generate_crosshair_angles(num_lines)
            crosshair_state.line_offsets = {}
            local angle_inc = 2 * math.pi / num_lines
            for i = 1, num_lines do
                crosshair_state.line_offsets[i] = (i - 1) * angle_inc
            end
        end
        
        local function create_crosshair()
            -- cleanup old lines
            for i = 1, #crosshair_state.lines do
                if crosshair_state.lines[i] then
                    crosshair_state.lines[i]:Remove()
                end
                if crosshair_state.outlines[i] then
                    crosshair_state.outlines[i]:Remove()
                end
            end
            crosshair_state.lines = {}
            crosshair_state.outlines = {}
            
            -- create crosshair lines
            local DrawingLib = (B and B.drawing) or Drawing
            if not DrawingLib then return end
            
            for i = 1, Config.Crosshair.Sides do
                crosshair_state.lines[i] = DrawingLib.new("Line")
                crosshair_state.lines[i].Visible = false
                crosshair_state.lines[i].Color = Config.Crosshair.CrosshairColor
                crosshair_state.lines[i].Thickness = Config.Crosshair.Thickness
                crosshair_state.lines[i].ZIndex = 2
                crosshair_state.lines[i].Transparency = 1
                
                crosshair_state.outlines[i] = DrawingLib.new("Line")
                crosshair_state.outlines[i].Visible = false
                crosshair_state.outlines[i].Color = Config.Crosshair.OutlineColor
                crosshair_state.outlines[i].Thickness = Config.Crosshair.Thickness + 2
                crosshair_state.outlines[i].ZIndex = 1
                crosshair_state.outlines[i].Transparency = 1
            end
            
            generate_crosshair_angles(Config.Crosshair.Sides)
            
        end
        
        local function update_crosshair()
            if not Config.Crosshair.Enabled then
                -- hide crosshair
                for i = 1, #crosshair_state.lines do
                    if crosshair_state.lines[i] then
                        crosshair_state.lines[i].Visible = false
                    end
                    if crosshair_state.outlines[i] then
                        crosshair_state.outlines[i].Visible = false
                    end
                end
                return
            end
            
            -- get position (mouse or screen center), always using raw mouse to avoid inset offsets
            local UIS = (B and B.uis) or (game and game.GetService and game:GetService("UserInputService"))
            if not UIS then return end
            local camera = (B and B.camera) or (workspace and workspace.CurrentCamera)
            local mouse_raw = UIS:GetMouseLocation()
            local mouse_pos = mouse_raw
            local mode = (Config.Crosshair and Config.Crosshair.Position) or "mouse"
            if type(mode) == "string" then
                mode = string.lower(mode)
            end
            if mode == "center" and camera and camera.ViewportSize then
                mouse_pos = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)
            end
            
            -- if AttachToTarget is enabled, override position with target's 2D screen point when on-screen
            -- works for both "center" and "mouse" modes; falls back to original mouse_pos/center if off-screen
            if (Config.Crosshair and Config.Crosshair.AttachToTarget) and camera then
                local ts = (_G and _G.targeting_state) or nil
                local tgt = ts and ts.current
                if tgt and tgt.Character then
                    local char = tgt.Character
                    local partName = g and g["aimbot_part"]
                    local part = (partName and char:FindFirstChild(partName)) or (C and C.GetPreferredPart and C:GetPreferredPart(char))
                    if part then
                        local v3, onScreen = camera:WorldToViewportPoint(part.Position)
                        if onScreen then
                            mouse_pos = Vector2.new(v3.X, v3.Y)
                        end
                    end
                end
            end
            
            -- update rotation angle
            if Config.Crosshair.AlwaysRotating then
                crosshair_state.spin_angle = crosshair_state.spin_angle + math.rad((Config.Crosshair.Speed * 10) * (1/60))
            else
                crosshair_state.spin_angle = 0
            end
            
            -- calculate crosshair properties
            local temp_radius = Config.Crosshair.Length * 5
            local gap = Config.Crosshair.GapSize
            
            -- update cursor size for pulse effect
            crosshair_state.cursor_size = crosshair_state.cursor_size + 0.025
            
            local local_radius = temp_radius
            if Config.Crosshair.Pulse then
                local dynamic = math.cos(crosshair_state.cursor_size)
                local_radius = temp_radius - (temp_radius / 4) * math.abs(dynamic)
            end
            
            -- update crosshair lines
            for i = 1, #crosshair_state.lines do
                if crosshair_state.lines[i] and crosshair_state.line_offsets[i] then
                    local angle = crosshair_state.spin_angle + crosshair_state.line_offsets[i]
                    local direction = Vector2.new(
                        math.cos(angle),
                        math.sin(angle)
                    ).Unit
                    
                    -- set line positions
                    crosshair_state.lines[i].From = mouse_pos + direction * gap
                    crosshair_state.lines[i].To = crosshair_state.lines[i].From + direction * local_radius
                    crosshair_state.lines[i].Visible = true
                    crosshair_state.lines[i].Color = Config.Crosshair.CrosshairColor
                    crosshair_state.lines[i].Thickness = Config.Crosshair.Thickness
                    
                    -- set outline positions
                    if crosshair_state.outlines[i] then
                        crosshair_state.outlines[i].From = mouse_pos + direction * (gap - 1)
                        crosshair_state.outlines[i].To = crosshair_state.lines[i].From + direction * (local_radius + 1)
                        crosshair_state.outlines[i].Visible = true
                        crosshair_state.outlines[i].Color = Config.Crosshair.OutlineColor
                        crosshair_state.outlines[i].Thickness = Config.Crosshair.Thickness + 2
                    end
                end
            end
        end
        
        local function apply_crosshair()
            -- cleanup prev connection
            if crosshair_state.connection then
                if typeof(crosshair_state.connection) == "RBXScriptConnection" then 
                    pcall(function() crosshair_state.connection:Disconnect() end) 
                end
                crosshair_state.connection = nil
            end
            
            if Config.Crosshair.Enabled then
                create_crosshair()
                local RS = (B and B.run) or (game and game.GetService and game:GetService("RunService"))
                if RS and RS.RenderStepped then
                    crosshair_state.connection = RS.RenderStepped:Connect(update_crosshair)
                end
            else
                update_crosshair() -- call to hide
            end
            -- apply cursor visibility per setting
            if apply_mouse_icon then apply_mouse_icon() end
        end
        
        -- mouse cursor visibility helper for crosshair
        local defaultMouseIcon
        local function apply_mouse_icon()
            local UIS = (B and B.uis) or (game and game.GetService and game:GetService("UserInputService"))
            if not UIS then return end
            local hc = (Config.Crosshair and Config.Crosshair.HideCursor) and true or false
            if hc then
                if defaultMouseIcon == nil then defaultMouseIcon = UIS.MouseIconEnabled end
                UIS.MouseIconEnabled = false
            else
                if defaultMouseIcon ~= nil then
                    UIS.MouseIconEnabled = defaultMouseIcon
                    defaultMouseIcon = nil
                else
                    UIS.MouseIconEnabled = true
                end
            end
        end
        
        -- indicators system start
        do
            Config.Indicators = Config.Indicators or {Enabled = false, Selected = {}}
            Config.Indicators.ClientName = (Config.Indicators.ClientName ~= nil) and Config.Indicators.ClientName or "Rebuild.gg"
            Config.Indicators.InfoSize = (Config.Indicators.InfoSize ~= nil) and Config.Indicators.InfoSize or 14
            Config.Indicators.ClientSize = (Config.Indicators.ClientSize ~= nil) and Config.Indicators.ClientSize or 16
            local indicators_state = {
                drawings = {},
                connection = nil,
                last_clock = nil,
                fps_smooth = nil,
            }

            local function get_selected()
                local sel = (Config.Indicators and Config.Indicators.Selected) or {}
                if type(sel) ~= "table" then return {} end
                return sel
            end

            local function ensure_text(name)
                local DrawingLib = (B and B.drawing) or Drawing
                if not indicators_state.drawings[name] and DrawingLib and DrawingLib.new then
                    local t = DrawingLib.new("Text")
                    -- base style
                    t.Visible = false
                    t.Color = Color3.new(1, 1, 1)
                    t.Center = false
                    t.Outline = true
                    t.OutlineColor = Color3.new(0, 0, 0)
                    t.Transparency = 1
                    t.Size = 13
                    t.Font = 2
                    -- Note: Drawing Text cannot use FontFace; using executor font for runtime rendering
                    indicators_state.drawings[name] = t
                end
                return indicators_state.drawings[name]
            end

            local function hide_all()
                for _, obj in pairs(indicators_state.drawings) do
                    if obj then obj.Visible = false end
                end
            end

            local function update_indicators()
                if not (Config.Indicators and Config.Indicators.Enabled) then
                    hide_all()
                    return
                end

                local UIS = (B and B.uis) or (game and game.GetService and game:GetService("UserInputService"))
                local camera = (B and B.camera) or (workspace and workspace.CurrentCamera)
                if not UIS or not camera then
                    hide_all()
                    return
                end

                local mouse = UIS:GetMouseLocation()
                local base_pos = Vector2.new(mouse.X + 12, mouse.Y + 12)

                local selected = get_selected()
                -- quick set for hiding non-selected
                local active = {}
                local y = 0

                -- helpers
                local Players = (B and B.ps) or (game and game.GetService and game:GetService("Players"))
                local lp = Players and Players.LocalPlayer
                local lchar = lp and lp.Character
                local lhum = lchar and lchar:FindFirstChildOfClass("Humanoid")
                local lroot = lchar and (lchar:FindFirstChild("HumanoidRootPart") or lchar:FindFirstChild("Head"))

                local ts = (_G and _G.targeting_state) or nil
                local tgt = ts and ts.current
                local thum = (tgt and tgt.Character) and tgt.Character:FindFirstChildOfClass("Humanoid")
                local troot = (tgt and tgt.Character) and (tgt.Character:FindFirstChild("HumanoidRootPart") or tgt.Character:FindFirstChild("Head"))

                -- timing for FPS
                local now = os.clock()
                if indicators_state.last_clock then
                    local dt = math.max(now - indicators_state.last_clock, 1e-6)
                    local inst_fps = 1 / dt
                    indicators_state.fps_smooth = indicators_state.fps_smooth and (indicators_state.fps_smooth * 0.9 + inst_fps * 0.1) or inst_fps
                end
                indicators_state.last_clock = now

                -- header: ClientName on top if selected
                local has_client = false
                for _, k in ipairs(selected) do
                    if tostring(k) == "ClientName" then has_client = true break end
                end
                if has_client then
                    local id = "ClientName"
                    active[id] = true
                    local obj = ensure_text(id)
                    if obj then
                        local text_value = (Config.Indicators and Config.Indicators.ClientName) or "Rebuild.gg"
                        obj.Size = ((Config.Indicators and Config.Indicators.ClientSize) or 16)
                        obj.Text = text_value
                        obj.Position = Vector2.new(base_pos.X, base_pos.Y + y)
                        obj.Visible = true
                        y = y + (obj.Size + 2)
                    end
                end

                for _, key in ipairs(selected) do
                    local id = tostring(key)
                    if id ~= "ClientName" then
                        active[id] = true
                        local obj = ensure_text(id)
                        if obj then
                            local text_value = nil
                            if id == "localplayerHP" then
                            local hp = (lhum and lhum.Health) or 0
                            text_value = ("HP %d"):format(math.floor(hp + 0.5))
                            elseif id == "TargetHP" then
                            local thp = (thum and thum.Health) or nil
                            if thp then
                                text_value = ("THP %d"):format(math.floor(thp + 0.5))
                            end
                            elseif id == "LocalPlayerSpeed" then
                            local spd = (lroot and lroot.Velocity and lroot.Velocity.Magnitude) or 0
                            text_value = ("Spd %d"):format(math.floor(spd + 0.5))
                            elseif id == "TargetDistance" then
                            local dist = (lroot and troot) and (lroot.Position - troot.Position).Magnitude or nil
                            if dist then text_value = ("Dist %d"):format(math.floor(dist + 0.5)) end
                            elseif id == "FPS" then
                            local fpsv = indicators_state.fps_smooth and math.floor(indicators_state.fps_smooth + 0.5) or nil
                            if fpsv then text_value = ("FPS %d"):format(fpsv) end
                            elseif id == "Ping" then
                            local ping_val
                            local Stats = (B and B.stats) or (game and game.GetService and game:GetService("Stats"))
                            if Stats and Stats.Network and Stats.Network.ServerStatsItem then
                                local ok, res = pcall(function()
                                    return Stats.Network.ServerStatsItem["Data Ping"]:GetValueString()
                                end)
                                if ok and type(res) == "string" then
                                    local n = res:match("(%d+)")
                                    ping_val = tonumber(n)
                                end
                            end
                            if ping_val then text_value = ("Ping %d"):format(ping_val) end
                            elseif id == "ClockTime" then
                            local Lighting = (game and game.GetService and game:GetService("Lighting"))
                            if Lighting then
                                local ct = Lighting.ClockTime or 0
                                local h = math.floor(ct) % 24
                                local m = math.floor(((ct - h) * 60) + 0.5) % 60
                                text_value = ("Time %02d:%02d"):format(h, m)
                            end
                            end

                            if text_value then
                                obj.Size = ((Config.Indicators and Config.Indicators.InfoSize) or 14)
                                obj.Text = text_value
                                obj.Position = Vector2.new(base_pos.X, base_pos.Y + y)
                                obj.Visible = true
                                y = y + (obj.Size + 2)
                            else
                                obj.Visible = false
                            end
                        end
                    end
                end

                -- hide any leftover unselected drawings
                for name, obj in pairs(indicators_state.drawings) do
                    if obj and not active[name] then
                        obj.Visible = false
                    end
                end
            end

            function apply_indicators()
                -- disconnect previous
                if indicators_state.connection and typeof(indicators_state.connection) == "RBXScriptConnection" then
                    pcall(function() indicators_state.connection:Disconnect() end)
                end
                indicators_state.connection = nil

                if Config.Indicators and Config.Indicators.Enabled then
                    local RS = (B and B.run) or (game and game.GetService and game:GetService("RunService"))
                    if RS and RS.RenderStepped then
                        indicators_state.connection = RS.RenderStepped:Connect(update_indicators)
                    end
                else
                    update_indicators()
                end
            end
        end
        -- indicators system end
        
        local defaultAmbient
        local function apply_ambient()
            local Lighting = (game and game.GetService and game:GetService("Lighting"))
            if not Lighting then return end
            if not defaultAmbient then
                defaultAmbient = Lighting.Ambient
            end
            local ac = Config.Ambient or {}
            if ac.Enabled then
                local col = ac.Color or Color3.fromRGB(255, 255, 255)
                if typeof(col) == "table" then
                    col = col.Color or col.Color3 or col.color
                end
                Lighting.Ambient = col
            else
                if defaultAmbient ~= nil then
                    Lighting.Ambient = defaultAmbient
                end
            end
        end

        -- atmosphere apply helper
        local defaultAtmProps
        local createdAtm = false
        local function ensure_atmosphere()
            local Lighting = (game and game.GetService and game:GetService("Lighting"))
            if not Lighting then return nil end
            local atm = Lighting:FindFirstChild("CurrentAtmosphere")
                or Lighting:FindFirstChild("currentatmosphere")
                or Lighting:FindFirstChildOfClass("Atmosphere")
            if not atm then
                atm = Instance.new("Atmosphere")
                atm.Name = "CurrentAtmosphere"
                atm.Parent = Lighting
                createdAtm = true
            end
            return atm
        end

        local function apply_atmosphere()
            local Lighting = (game and game.GetService and game:GetService("Lighting"))
            if not Lighting then return end
            local ac = Config.Atmosphere or {}
            local atm = ensure_atmosphere()
            if not atm then return end

            if ac.Enabled then
                if not defaultAtmProps then
                    defaultAtmProps = {
                        Color = atm.Color,
                        Decay = atm.Decay,
                        Density = atm.Density,
                        Offset = atm.Offset,
                        Glare = atm.Glare,
                        Haze = atm.Haze,
                    }
                end

                -- colors
                if ac.Color then
                    local col = ac.Color
                    if typeof(col) == "table" then
                        col = col.Color or col.Color3 or col.color
                    end
                    atm.Color = col
                end
                if ac.Decay then
                    local dec = ac.Decay
                    if typeof(dec) == "table" then
                        dec = dec.Color or dec.Color3 or dec.color
                    end
                    atm.Decay = dec
                end

                -- numbers (use reasonable bounds)
                if typeof(ac.Density) == "number" then
                    atm.Density = math.clamp(ac.Density, 0, 1)
                end
                if typeof(ac.Offset) == "number" then
                    atm.Offset = math.clamp(ac.Offset, -1, 1)
                end
                if typeof(ac.Glare) == "number" then
                    atm.Glare = math.clamp(ac.Glare, 0, 10)
                end
                if typeof(ac.Haze) == "number" then
                    atm.Haze = math.clamp(ac.Haze, 0, 10)
                end
            else
                if createdAtm then
                    -- if we created it, remove it entirely on disable
                    atm:Destroy()
                    createdAtm = false
                    defaultAtmProps = nil
                elseif defaultAtmProps then
                    -- restore previous values
                    atm.Color = defaultAtmProps.Color
                    atm.Decay = defaultAtmProps.Decay
                    atm.Density = defaultAtmProps.Density
                    atm.Offset = defaultAtmProps.Offset
                    atm.Glare = defaultAtmProps.Glare
                    atm.Haze = defaultAtmProps.Haze
                end
            end
        end

        -- bloom apply helper
        local function apply_bloom()
            local Lighting = (game and game.GetService and game:GetService("Lighting"))
            if not Lighting then return end
            local bc = Config.Bloom or {}

            local EFF_NAME = "RebuildBloom"
            if not (bc.Enabled and true or false) then
                local old = Lighting:FindFirstChild(EFF_NAME)
                if old then old:Destroy() end
                return
            end

            local eff = Lighting:FindFirstChild(EFF_NAME)
            if not eff then
                eff = Instance.new("BloomEffect")
                eff.Name = EFF_NAME
                eff.Parent = Lighting
            end

            local intensity = typeof(bc.Intensity) == "number" and math.clamp(bc.Intensity, 0, 10) or 1
            local size = typeof(bc.Size) == "number" and math.clamp(bc.Size, 0, 100) or 24
            local threshold = typeof(bc.Threshold) == "number" and math.clamp(bc.Threshold, 0, 1) or 0.7
            eff.Intensity = intensity
            eff.Size = size
            eff.Threshold = threshold
            eff.Enabled = true
        end

        -- UI (move to a dedicated World column)
        local world_column = v:column()
        local cc_section = world_column:section({name = "World"})
        local cc_toggle = cc_section:toggle({
            name = "ColorCorrection",
            flag = "colorcorr_enabled",
            default = (Config.ColorCorrection and Config.ColorCorrection.Enabled) or false,
            callback = function(state)
                Config.ColorCorrection.Enabled = state and true or false
                apply_color_correction()
            end
        })

        -- dependent controls
        local cc_dep = cc_section:dependency_box()
        cc_dep:setup_dependencies({ { cc_toggle, true } })

        cc_dep:slider({
            name = "Brightness",
            flag = "colorcorr_brt",
            min = -0.5, max = 0.5, default = (Config.ColorCorrection and Config.ColorCorrection.Brightness) or 0, interval = 0.01,
            callback = function(v)
                Config.ColorCorrection.Brightness = v
                apply_color_correction()
            end
        })

        cc_dep:slider({
            name = "Contrast",
            flag = "colorcorr_ctr",
            min = 0, max = 1, default = (Config.ColorCorrection and Config.ColorCorrection.Contrast) or 0, interval = 0.01,
            callback = function(v)
                Config.ColorCorrection.Contrast = v
                apply_color_correction()
            end
        })

        cc_dep:slider({
            name = "Saturation",
            flag = "colorcorr_sat",
            min = -0.5, max = 0.5, default = (Config.ColorCorrection and Config.ColorCorrection.Saturation) or 0, interval = 0.01,
            callback = function(v)
                Config.ColorCorrection.Saturation = v
                apply_color_correction()
            end
        })

        cc_toggle:colorpicker({
            name = "TintColor",
            flag = "colorcorr_tint",
            color = (Config.ColorCorrection and Config.ColorCorrection.TintColor) or Color3.fromRGB(255,255,255),
            callback = function(color)
                local c = color
                if typeof(color) == "table" then
                    c = color.Color or color.Color3 or color.color
                end
                Config.ColorCorrection.TintColor = c
                apply_color_correction()
            end
        })

        -- Ambient toggle + colorpicker
        local ambient_toggle = cc_section:toggle({
            name = "Ambient",
            flag = "ambient_enabled",
            default = (Config.Ambient and Config.Ambient.Enabled) or false,
            callback = function(state)
                Config.Ambient.Enabled = state and true or false
                apply_ambient()
            end
        })
        ambient_toggle:colorpicker({
            name = "AmbientColor",
            flag = "ambient_color",
            color = (Config.Ambient and Config.Ambient.Color) or Color3.fromRGB(255,255,255),
            callback = function(color)
                local c = color
                if typeof(color) == "table" then
                    c = color.Color or color.Color3 or color.color
                end
                Config.Ambient.Color = c
                apply_ambient()
            end
        })

        -- Atmosphere toggle + controls
        local atm_toggle = cc_section:toggle({
            name = "Atmosphere",
            flag = "atmosphere_enabled",
            default = (Config.Atmosphere and Config.Atmosphere.Enabled) or false,
            callback = function(state)
                Config.Atmosphere.Enabled = state and true or false
                apply_atmosphere()
            end
        })

        -- colorpickers
        atm_toggle:colorpicker({
            name = "Color",
            flag = "atmosphere_color",
            color = (Config.Atmosphere and Config.Atmosphere.Color) or Color3.fromRGB(255,255,255),
            callback = function(color)
                local c = color
                if typeof(color) == "table" then
                    c = color.Color or color.Color3 or color.color
                end
                Config.Atmosphere.Color = c
                apply_atmosphere()
            end
        })
        atm_toggle:colorpicker({
            name = "Decay",
            flag = "atmosphere_decay",
            color = (Config.Atmosphere and Config.Atmosphere.Decay) or Color3.fromRGB(0,0,0),
            callback = function(color)
                local c = color
                if typeof(color) == "table" then
                    c = color.Color or color.Color3 or color.color
                end
                Config.Atmosphere.Decay = c
                apply_atmosphere()
            end
        })

        -- dependent sliders
        local atm_dep = cc_section:dependency_box()
        atm_dep:setup_dependencies({ { atm_toggle, true } })

        atm_dep:slider({
            name = "Density",
            flag = "atmosphere_density",
            min = 0, max = 1, default = (Config.Atmosphere and Config.Atmosphere.Density) or 0, interval = 0.01,
            callback = function(v)
                Config.Atmosphere.Density = v
                apply_atmosphere()
            end
        })

        atm_dep:slider({
            name = "Offset",
            flag = "atmosphere_offset",
            min = -1, max = 1, default = (Config.Atmosphere and Config.Atmosphere.Offset) or 0, interval = 0.01,
            callback = function(v)
                Config.Atmosphere.Offset = v
                apply_atmosphere()
            end
        })

        atm_dep:slider({
            name = "Glare",
            flag = "atmosphere_glare",
            min = 0, max = 10, default = (Config.Atmosphere and Config.Atmosphere.Glare) or 0, interval = 0.05,
            callback = function(v)
                Config.Atmosphere.Glare = v
                apply_atmosphere()
            end
        })

        atm_dep:slider({
            name = "Haze",
            flag = "atmosphere_haze",
            min = 0, max = 10, default = (Config.Atmosphere and Config.Atmosphere.Haze) or 0, interval = 0.05,
            callback = function(v)
                Config.Atmosphere.Haze = v
                apply_atmosphere()
            end
        })

        -- Bloom toggle + controls (in World)
        local bloom_toggle = cc_section:toggle({
            name = "Bloom",
            flag = "bloom_enabled",
            default = (Config.Bloom and Config.Bloom.Enabled) or false,
            callback = function(state)
                Config.Bloom.Enabled = state and true or false
                apply_bloom()
            end
        })

        local bloom_dep = cc_section:dependency_box()
        bloom_dep:setup_dependencies({ { bloom_toggle, true } })

        bloom_dep:slider({
            name = "Int",
            flag = "bloom_intensity",
            min = 0, max = 10, default = (Config.Bloom and Config.Bloom.Intensity) or 1, interval = 0.05,
            callback = function(v)
                Config.Bloom.Intensity = v
                apply_bloom()
            end
        })

        bloom_dep:slider({
            name = "Size",
            flag = "bloom_size",
            min = 0, max = 100, default = (Config.Bloom and Config.Bloom.Size) or 24, interval = 1,
            callback = function(v)
                Config.Bloom.Size = v
                apply_bloom()
            end
        })

        bloom_dep:slider({
            name = "Thr",
            flag = "bloom_threshold",
            min = 0, max = 1, default = (Config.Bloom and Config.Bloom.Threshold) or 0.7, interval = 0.01,
            callback = function(v)
                Config.Bloom.Threshold = v
                apply_bloom()
            end
        })

        -- Textures toggle + dropdown (in World)
        local textures_toggle = cc_section:toggle({
            name = "Textures",
            flag = "textures_enabled",
            default = (Config.Textures and Config.Textures.Enabled) or false,
            callback = function(state)
                Config.Textures.Enabled = state and true or false
                if state then
                    enable_textures()
                else
                    disable_textures()
                end
            end
        })

        local textures_dep = cc_section:dependency_box()
        textures_dep:setup_dependencies({ { textures_toggle, true } })
        local materials_list = ensure_material_list()
        textures_dep:dropdown({
            name = "Mat",
            flag = "textures_material",
            items = materials_list,
            default = (Config.Textures and Config.Textures.Selected) or "Plastic",
            callback = function(v)
                Config.Textures.Selected = v
                if Config.Textures and Config.Textures.Enabled then
                    enable_textures()
                end
            end
        })

        -- Skybox toggle + preset dropdown
        local skybox_toggle = cc_section:toggle({
            name = "Skybox",
            flag = "skybox_enabled",
            default = (Config.Skybox and Config.Skybox.Enabled) or false,
            callback = function(state)
                Config.Skybox.Enabled = state and true or false
                apply_skybox()
            end
        })
        local skybox_dep = cc_section:dependency_box()
        skybox_dep:setup_dependencies({ { skybox_toggle, true } })
        local sky_items = ensure_skybox_list()
        skybox_dep:dropdown({
            name = "Set",
            flag = "skybox_set",
            items = sky_items,
            default = (Config.Skybox and Config.Skybox.Selected) or "Night Sky",
            callback = function(v)
                Config.Skybox.Selected = v
                if Config.Skybox and Config.Skybox.Enabled then
                    apply_skybox()
                end
            end
        })

        -- Time changer
        local time_toggle = cc_section:toggle({
            name = "Time",
            flag = "time_enabled",
            default = (Config.Time and Config.Time.Enabled) or false,
            callback = function(state)
                Config.Time.Enabled = state and true or false
                apply_time()
            end
        })
        local time_dep = cc_section:dependency_box()
        time_dep:setup_dependencies({ { time_toggle, true } })
        time_dep:slider({
            name = "Hrs",
            flag = "time_hours",
            min = 0, max = 23, default = (Config.Time and Config.Time.Hours) or 12, interval = 1,
            callback = function(v)
                Config.Time.Hours = v
                apply_time()
            end
        })
        time_dep:slider({
            name = "Min",
            flag = "time_minutes",
            min = 0, max = 59, default = (Config.Time and Config.Time.Minutes) or 0, interval = 1,
            callback = function(v)
                Config.Time.Minutes = v
                apply_time()
            end
        })

        -- apply on load if enabled
        task.defer(apply_color_correction)
        task.defer(apply_ambient)
        task.defer(apply_atmosphere)
        task.defer(apply_bloom)
        task.defer(apply_skybox)
        task.defer(apply_time)
        task.defer(apply_fov)
        task.defer(apply_aspect_ratio)
        task.defer(apply_third_person)
        task.defer(apply_crosshair)
        task.defer(apply_indicators)
        task.defer(function()
            if Config.Textures and Config.Textures.Enabled then
                enable_textures()
            end
        end)
        
        -- Random section in the same World column
        local random_section = world_column:section({name = "Random"})

        -- FieldOfView control
        local fov_toggle = random_section:toggle({
            name = "FieldOfView",
            flag = "fov_enabled",
            default = (Config.FOV and Config.FOV.Enabled) or false,
            callback = function(state)
                Config.FOV.Enabled = state and true or false
                apply_fov()
            end
        })

        local fov_dep = random_section:dependency_box()
        fov_dep:setup_dependencies({ { fov_toggle, true } })
        fov_dep:slider({
            name = "FOV",
            flag = "fov_value",
            min = 60, max = 180, default = (Config.FOV and Config.FOV.Value) or 70, interval = 1,
            callback = function(v)
                Config.FOV.Value = v
                apply_fov()
            end
        })

        -- AspectRatio control
        local ar_toggle = random_section:toggle({
            name = "AspectRatio",
            flag = "aspect_enabled",
            default = (Config.AspectRatio and Config.AspectRatio.Enabled) or false,
            callback = function(state)
                Config.AspectRatio.Enabled = state and true or false
                apply_aspect_ratio()
            end
        })

        local ar_dep = random_section:dependency_box()
        ar_dep:setup_dependencies({ { ar_toggle, true } })
        ar_dep:slider({
            name = "Hor",
            flag = "aspect_horizontal",
            min = 50, max = 120, default = math.clamp((Config.AspectRatio and Config.AspectRatio.Horizontal) or 100, 50, 120), interval = 1,
            callback = function(v)
                Config.AspectRatio.Horizontal = v
                apply_aspect_ratio()
            end
        })
        ar_dep:slider({
            name = "Ver",
            flag = "aspect_vertical",
            min = 50, max = 120, default = math.clamp((Config.AspectRatio and Config.AspectRatio.Vertical) or 100, 50, 120), interval = 1,
            callback = function(v)
                Config.AspectRatio.Vertical = v
                apply_aspect_ratio()
            end
        })

        -- ThirdPerson control
        local tp_toggle = random_section:toggle({
            name = "ThirdPerson",
            flag = "tp_enabled",
            default = (Config.ThirdPerson and Config.ThirdPerson.Enabled) or false,
            callback = function(state)
                Config.ThirdPerson.Enabled = state and true or false
                apply_third_person()
            end
        })

        local tp_dep = random_section:dependency_box()
        tp_dep:setup_dependencies({ { tp_toggle, true } })
        tp_dep:slider({
            name = "X",
            flag = "tp_x",
            min = -20, max = 20, default = (Config.ThirdPerson and Config.ThirdPerson.X) or 0, interval = 0.1,
            callback = function(v)
                Config.ThirdPerson.X = v
                apply_third_person()
            end
        })
        tp_dep:slider({
            name = "Y",
            flag = "tp_y",
            min = -20, max = 20, default = (Config.ThirdPerson and Config.ThirdPerson.Y) or 0, interval = 0.1,
            callback = function(v)
                Config.ThirdPerson.Y = v
                apply_third_person()
            end
        })
        tp_dep:slider({
            name = "Z",
            flag = "tp_z",
            min = -20, max = 20, default = (Config.ThirdPerson and Config.ThirdPerson.Z) or 0, interval = 0.1,
            callback = function(v)
                Config.ThirdPerson.Z = v
                apply_third_person()
            end
        })

        -- Crosshair control
        local ch_toggle = random_section:toggle({
            name = "Crosshair",
            flag = "ch_enabled",
            default = (Config.Crosshair and Config.Crosshair.Enabled) or false,
            callback = function(state)
                Config.Crosshair.Enabled = state and true or false
                apply_crosshair()
            end
        })

        -- attach colorpickers to toggle (per request)
        ch_toggle:colorpicker({
            name = "Fill",
            flag = "ch_color",
            color = (Config.Crosshair and Config.Crosshair.CrosshairColor) or Color3.fromRGB(255, 255, 255),
            callback = function(color)
                Config.Crosshair.CrosshairColor = color
                apply_crosshair()
            end
        })
        ch_toggle:colorpicker({
            name = "Outline",
            flag = "ch_outline",
            color = (Config.Crosshair and Config.Crosshair.OutlineColor) or Color3.fromRGB(0, 0, 0),
            callback = function(color)
                Config.Crosshair.OutlineColor = color
                apply_crosshair()
            end
        })

        local ch_dep = random_section:dependency_box()
        ch_dep:setup_dependencies({ { ch_toggle, true } })
        -- removed Sides slider
        ch_dep:slider({
            name = "Length",
            flag = "ch_length",
            min = 5, max = 300, default = (Config.Crosshair and Config.Crosshair.Length) or 10, interval = 1,
            callback = function(v)
                Config.Crosshair.Length = v
                apply_crosshair()
            end
        })
        ch_dep:slider({
            name = "Gap",
            flag = "ch_gap",
            min = 0, max = 20, default = (Config.Crosshair and Config.Crosshair.GapSize) or 5, interval = 1,
            callback = function(v)
                Config.Crosshair.GapSize = v
                apply_crosshair()
            end
        })
        ch_dep:slider({
            name = "Thickness",
            flag = "ch_thickness",
            min = 1, max = 5, default = (Config.Crosshair and Config.Crosshair.Thickness) or 2, interval = 1,
            callback = function(v)
                Config.Crosshair.Thickness = v
                apply_crosshair()
            end
        })
        ch_dep:toggle({
            name = "Rotating",
            flag = "ch_rotating",
            default = (Config.Crosshair and Config.Crosshair.AlwaysRotating) or false,
            callback = function(state)
                Config.Crosshair.AlwaysRotating = state and true or false
                apply_crosshair()
            end
        })
        ch_dep:slider({
            name = "Speed",
            flag = "ch_speed",
            min = 1, max = 10, default = (Config.Crosshair and Config.Crosshair.Speed) or 1, interval = 1,
            callback = function(v)
                Config.Crosshair.Speed = v
                apply_crosshair()
            end
        })
        ch_dep:toggle({
            name = "Pulse",
            flag = "ch_pulse",
            default = (Config.Crosshair and Config.Crosshair.Pulse) or false,
            callback = function(state)
                Config.Crosshair.Pulse = state and true or false
                apply_crosshair()
            end
        })
        -- AttachToTarget toggle
        ch_dep:toggle({
            name = "AttachToTarget",
            flag = "ch_attach",
            default = (Config.Crosshair and Config.Crosshair.AttachToTarget) or false,
            callback = function(state)
                Config.Crosshair.AttachToTarget = state and true or false
                apply_crosshair()
            end
        })
        -- HideCursor toggle
        ch_dep:toggle({
            name = "HideCursor",
            flag = "ch_hidecursor",
            default = (Config.Crosshair and Config.Crosshair.HideCursor) or false,
            callback = function(state)
                Config.Crosshair.HideCursor = state and true or false
                if apply_mouse_icon then apply_mouse_icon() end
            end
        })
        -- Position dropdown (Mouse/Center)
        ch_dep:dropdown({
            name = "Position",
            flag = "ch_position",
            items = {"Mouse", "Center"},
            default = ((Config.Crosshair and Config.Crosshair.Position) == "center") and "Center" or "Mouse",
            callback = function(v)
                local val = tostring(v)
                if val == "Center" or val == "center" then
                    Config.Crosshair.Position = "center"
                else
                    Config.Crosshair.Position = "mouse"
                end
                apply_crosshair()
            end
        })
        
        -- Indicators UI
        local ind_toggle = random_section:toggle({
            name = "Indicators",
            flag = "ind_enabled",
            default = (Config.Indicators and Config.Indicators.Enabled) or false,
            callback = function(state)
                Config.Indicators = Config.Indicators or {}
                Config.Indicators.Enabled = state and true or false
                -- fix text sizes to 13 for all indicators
                Config.Indicators.ClientSize = 13
                Config.Indicators.InfoSize = 13
                apply_indicators()
            end
        })

        local ind_dep = random_section:dependency_box()
        ind_dep:setup_dependencies({ { ind_toggle, true } })
        ind_dep:dropdown({
            name = "Indicators",
            flag = "ind_list",
            items = {"ClientName", "localplayerHP", "TargetHP", "LocalPlayerSpeed", "TargetDistance", "FPS", "Ping"},
            multi = true,
            default = (Config.Indicators and Config.Indicators.Selected) or {"localplayerHP"},
            callback = function(list)
                Config.Indicators = Config.Indicators or {}
                Config.Indicators.Selected = (type(list) == "table" and list) or {}
                apply_indicators()
            end
        })
    end
    -- color correction system end
    
    -- Slashes (Local) functionality
    do
        -- esp system start (slashes local)
        local slashes_state = {
            active = false,
            conn = nil,
            appearance_conn = nil,
            desc_conn = nil,
            type = "Slashesv1",
            emitters = {},
            color = Color3.fromRGB(255, 255, 255)
        }
        
        local function destroy_emitter()
            if slashes_state.emitters then
                for _, em in ipairs(slashes_state.emitters) do
                    if em and em.Parent then
                        em.Enabled = false
                        em:Destroy()
                    end
                end
            end
            slashes_state.emitters = {}
        end
        
        local function create_emitter(parent)
            destroy_emitter()
            if not parent then return end
            local emitters_created = {}
            if slashes_state.type == "Slashesv2" then
                -- Glow
                local glow = Instance.new("ParticleEmitter")
                glow.Name = "Glow"
                glow.Texture = "rbxassetid://2956681067"
                glow.Rate = 50
                glow.ZOffset = 2
                glow.Rotation = NumberRange.new(-360, 360)
                glow.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0.992, 0),
                    NumberSequenceKeypoint.new(1, 0.992, 0)
                })
                glow.Lifetime = NumberRange.new(0.25)
                glow.Speed = NumberRange.new(0.012202076613903046)
                glow.LightEmission = -5
                glow.LockedToPart = true
                glow.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
                glow.SpreadAngle = Vector2.new(180, 180)
                glow.VelocitySpread = 180
                glow.Size = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 3.8040645122528076, 3.8040645122528076),
                    NumberSequenceKeypoint.new(1, 7.608129024505615, 0)
                })
                glow.Color = ColorSequence.new(slashes_state.color or Color3.fromRGB(255,255,255))
                glow.Parent = parent
                glow.Enabled = true
                table.insert(emitters_created, glow)

                -- Slashesv2
                local em2 = Instance.new("ParticleEmitter")
                em2.Name = "Slashesv2"
                em2.Texture = "rbxassetid://6246398215"
                em2.Rate = 15
                em2.ZOffset = 2
                em2.Rotation = NumberRange.new(-360, 360)
                em2.RotSpeed = NumberRange.new(1000)
                em2.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0, 0),
                    NumberSequenceKeypoint.new(0.5, 0, 0),
                    NumberSequenceKeypoint.new(1, 1, 0)
                })
                em2.Lifetime = NumberRange.new(0.25, 0.5)
                em2.Speed = NumberRange.new(0.012202076613903046)
                em2.LightEmission = -10
                em2.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
                em2.SpreadAngle = Vector2.new(180, 180)
                em2.VelocitySpread = 180
                em2.LockedToPart = true
                em2.Size = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 3.8040645122528076, 3.8040645122528076),
                    NumberSequenceKeypoint.new(1, 7.608129024505615, 0)
                })
                em2.Color = ColorSequence.new(slashes_state.color or Color3.fromRGB(255,255,255))
                em2.Parent = parent
                em2.Enabled = true
                table.insert(emitters_created, em2)
            elseif slashes_state.type == "Slashesv3" then
                -- needles removed (Needlev1/Needlev2)

                -- slash1
                local s1 = Instance.new("ParticleEmitter")
                s1.Name = "slash1"
                s1.Texture = "rbxassetid://6732711844"
                s1.Rate = 10
                s1.ZOffset = 2
                s1.RotSpeed = NumberRange.new(1000)
                s1.VelocitySpread = 180
                s1.LockedToPart = true
                s1.LightEmission = -1
                s1.LightInfluence = 1
                s1.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0,1,0),
                    NumberSequenceKeypoint.new(0.02631578966975212,0.59375,0),
                    NumberSequenceKeypoint.new(0.06024930626153946,0,0),
                    NumberSequenceKeypoint.new(0.765625,0.956250011920929,0),
                    NumberSequenceKeypoint.new(1,1,0)
                })
                s1.Lifetime = NumberRange.new(1)
                s1.Speed = NumberRange.new(-0.060865648090839386,0.060865648090839386)
                s1.Rotation = NumberRange.new(-180,180)
                s1.SpreadAngle = Vector2.new(180,-180)
                s1.Size = NumberSequence.new({
                    NumberSequenceKeypoint.new(0,4.526882648468018,0),
                    NumberSequenceKeypoint.new(0.7523961663246155,2.891117811203003,0),
                    NumberSequenceKeypoint.new(1,0,0)
                })
                s1.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
                s1.Color = ColorSequence.new(slashes_state.color or Color3.fromRGB(255,255,255))
                s1.Parent = parent
                s1.Enabled = true
                table.insert(emitters_created, s1)

                -- slash2
                local s2 = Instance.new("ParticleEmitter")
                s2.Name = "slash2"
                s2.Texture = "rbxassetid://6732711844"
                s2.Rate = 10
                s2.ZOffset = 2
                s2.RotSpeed = NumberRange.new(1000)
                s2.VelocitySpread = 180
                s2.LockedToPart = true
                s2.LightEmission = -1
                s2.LightInfluence = 1
                s2.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0,1,0),
                    NumberSequenceKeypoint.new(0.02631578966975212,0.59375,0),
                    NumberSequenceKeypoint.new(0.06024930626153946,0,0),
                    NumberSequenceKeypoint.new(0.765625,0.956250011920929,0),
                    NumberSequenceKeypoint.new(1,1,0)
                })
                s2.Lifetime = NumberRange.new(1)
                s2.Speed = NumberRange.new(-0.060865648090839386,0.060865648090839386)
                s2.Rotation = NumberRange.new(-180,180)
                s2.SpreadAngle = Vector2.new(180,-180)
                s2.Size = NumberSequence.new({
                    NumberSequenceKeypoint.new(0,4.526882648468018,0),
                    NumberSequenceKeypoint.new(0.7523961663246155,2.891117811203003,0),
                    NumberSequenceKeypoint.new(1,0,0)
                })
                s2.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
                s2.Color = ColorSequence.new(slashes_state.color or Color3.fromRGB(255,255,255))
                s2.Parent = parent
                s2.Enabled = true
                table.insert(emitters_created, s2)

                -- slash3
                local s3 = Instance.new("ParticleEmitter")
                s3.Name = "slash3"
                s3.Texture = "rbxassetid://6732711844"
                s3.Rate = 10
                s3.ZOffset = 2
                s3.RotSpeed = NumberRange.new(1000)
                s3.VelocitySpread = 180
                s3.LockedToPart = true
                s3.LightEmission = -1
                s3.LightInfluence = 1
                s3.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0,1,0),
                    NumberSequenceKeypoint.new(0.02631578966975212,0.59375,0),
                    NumberSequenceKeypoint.new(0.06024930626153946,0,0),
                    NumberSequenceKeypoint.new(0.765625,0.956250011920929,0),
                    NumberSequenceKeypoint.new(1,1,0)
                })
                s3.Lifetime = NumberRange.new(1)
                s3.Speed = NumberRange.new(-0.060865648090839386,0.060865648090839386)
                s3.Rotation = NumberRange.new(-180,180)
                s3.SpreadAngle = Vector2.new(180,-180)
                s3.Size = NumberSequence.new({
                    NumberSequenceKeypoint.new(0,4.526882648468018,0),
                    NumberSequenceKeypoint.new(0.7523961663246155,2.891117811203003,0),
                    NumberSequenceKeypoint.new(1,0,0)
                })
                s3.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
                s3.Color = ColorSequence.new(slashes_state.color or Color3.fromRGB(255,255,255))
                s3.Parent = parent
                s3.Enabled = true
                table.insert(emitters_created, s3)
            else
                -- Slashesv1 (existing)
                local em = Instance.new("ParticleEmitter")
                em.Name = "Slashes1"
                em.Texture = "rbxassetid://10927170198"
                em.ZOffset = 10
                em.Rate = 10
                em.Rotation = NumberRange.new(-360, 360)
                em.RotSpeed = NumberRange.new(1000)
                em.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0, 0),
                    NumberSequenceKeypoint.new(0.5, 0, 0),
                    NumberSequenceKeypoint.new(1, 1, 0)
                })
                em.Lifetime = NumberRange.new(0.25, 0.5)
                em.Speed = NumberRange.new(0.012202076613903046)
                em.LightEmission = -10
                em.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
                em.SpreadAngle = Vector2.new(180, 180)
                em.VelocitySpread = 180
                em.LockedToPart = true
                em.Size = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 3.8040645122528076, 3.8040645122528076),
                    NumberSequenceKeypoint.new(1, 7.608129024505615, 0)
                })
                em.Color = ColorSequence.new(slashes_state.color or Color3.fromRGB(255,255,255))
                em.Parent = parent
                em.Enabled = true
                table.insert(emitters_created, em)
            end
            slashes_state.emitters = emitters_created
        end
        
        local function apply_slashes(char)
            if not char then return end
            -- wait briefly for parts to exist after respawn
            local hrp = char:FindFirstChild("HumanoidRootPart") or (char.WaitForChild and char:WaitForChild("HumanoidRootPart", 2))
            if not hrp then return end
            local attach = hrp:FindFirstChild("RootAttachment") or (hrp.WaitForChild and hrp:WaitForChild("RootAttachment", 1))
            create_emitter(attach or hrp)
        end
        
        local function enable_slashes()
            local lp = (vars and vars.lp) or (game and game:GetService("Players").LocalPlayer)
            if not lp then return end
            slashes_state.active = true
            
            local function schedule_tries(char)
                local function try_apply()
                    if slashes_state.active and lp.Character == char then
                        apply_slashes(char)
                    end
                end
                task.delay(0.25, try_apply)
                task.delay(0.6, try_apply)
                task.delay(1.0, try_apply)
                -- short-lived hook to catch late RootAttachment
                if slashes_state.desc_conn then
                    slashes_state.desc_conn:Disconnect()
                    slashes_state.desc_conn = nil
                end
                slashes_state.desc_conn = char.DescendantAdded:Connect(function(inst)
                    if not slashes_state.active or lp.Character ~= char then return end
                    if (inst.Name == "RootAttachment") or (inst:IsA("Attachment") and inst.Parent and inst.Parent.Name == "HumanoidRootPart") then
                        apply_slashes(char)
                        if slashes_state.desc_conn then
                            slashes_state.desc_conn:Disconnect()
                            slashes_state.desc_conn = nil
                        end
                    end
                end)
                task.delay(3, function()
                    if slashes_state.desc_conn then
                        slashes_state.desc_conn:Disconnect()
                        slashes_state.desc_conn = nil
                    end
                end)
            end

            if not slashes_state.conn then
                slashes_state.conn = lp.CharacterAdded:Connect(function(char)
                    task.wait(0.5)
                    if slashes_state.active and lp.Character == char then
                        apply_slashes(char)
                        schedule_tries(char)
                    end
                end)
            end
            if slashes_state.appearance_conn then
                slashes_state.appearance_conn:Disconnect()
                slashes_state.appearance_conn = nil
            end
            slashes_state.appearance_conn = ((vars and vars.lp) or (game and game:GetService("Players").LocalPlayer)).CharacterAppearanceLoaded:Connect(function(char)
                task.delay(0.2, function()
                    local cur = ((vars and vars.lp) or (game and game:GetService("Players").LocalPlayer)).Character
                    if slashes_state.active and cur == char then
                        apply_slashes(char)
                        schedule_tries(char)
                    end
                end)
            end)
            
            if lp.Character then
                apply_slashes(lp.Character)
                schedule_tries(lp.Character)
            end
        end
        
        local function disable_slashes()
            slashes_state.active = false
            if slashes_state.conn then
                slashes_state.conn:Disconnect()
                slashes_state.conn = nil
            end
            if slashes_state.appearance_conn then
                slashes_state.appearance_conn:Disconnect()
                slashes_state.appearance_conn = nil
            end
            if slashes_state.desc_conn then
                slashes_state.desc_conn:Disconnect()
                slashes_state.desc_conn = nil
            end
            destroy_emitter()
        end
        
        local function update_slashes_color(color)
            slashes_state.color = color
            if slashes_state.emitters then
                for _, em in ipairs(slashes_state.emitters) do
                    if em then
                        em.Color = ColorSequence.new(color)
                    end
                end
            end
        end
        
        -- UI
        local slashes_toggle = local_section:toggle({
            name = "Slashes",
            flag = "slashes_enabled",
            default = false,
            callback = function(state)
                if state then enable_slashes() else disable_slashes() end
            end
        })
        slashes_toggle:colorpicker({
            name = "Clr",
            flag = "slashes_color",
            color = Color3.fromRGB(255, 255, 255),
            callback = function(c)
                local col = (typeof(c) == "table" and (c.Color or c.color)) or c
                if col then
                    update_slashes_color(col)
                end
            end
        })
        do
            -- dependency box for type selector
            local dep = local_section:dependency_box()
            dep:setup_dependencies({ { slashes_toggle, true } })
            dep:dropdown({
                name = "Type",
                flag = "slashes_type",
                items = {"Slashesv1", "Slashesv2", "Slashesv3"},
                default = "Slashesv1",
                callback = function(opt)
                    -- coerce library return to string option
                    local items_map = {"Slashesv1", "Slashesv2", "Slashesv3"}
                    if typeof(opt) == "table" then
                        opt = opt.text or opt.value or opt.Name or opt[1]
                    end
                    if typeof(opt) == "number" then
                        opt = items_map[opt]
                    end
                    if type(opt) ~= "string" then
                        opt = "Slashesv1"
                    end
                    slashes_state.type = opt
                    if slashes_state.active then
                        destroy_emitter()
                        local lp = (vars and vars.lp) or (game and game:GetService("Players").LocalPlayer)
                        local char = lp and lp.Character
                        if char then
                            apply_slashes(char)
                        end
                    end
                end
            })
        end
        -- esp system end (slashes local)
    end
    
    -- ChinaHat (Local) functionality
    do
        -- aimbot system start (local chinahat)
        local lhat = {
            enabled = false,
            style = "Custom",
            c1 = Color3.fromRGB(128, 18, 255),
            c2 = Color3.fromRGB(255, 0, 128),
            c3 = Color3.fromRGB(0, 200, 255),
            c4 = Color3.fromRGB(255, 255, 0),
            height = 0.7,
            radius = 2,
            sides = 25,
            hat_trs = 0.35,
            line_trs = 1.0,
            drawings = {},
            conn = nil,
            speed = 0.2
        }
        local function mix(a, b, t)
            return a + (b - a) * t
        end
        local function lerp_color(a, b, t)
            return Color3.new(mix(a.R, b.R, t), mix(a.G, b.G, t), mix(a.B, b.B, t))
        end
        local function cycle_custom(t0, time)
            local s = (t0 + time * lhat.speed) % 1
            if s < 0.25 then
                return lerp_color(lhat.c1, lhat.c2, s / 0.25)
            elseif s < 0.5 then
                return lerp_color(lhat.c2, lhat.c3, (s - 0.25) / 0.25)
            elseif s < 0.75 then
                return lerp_color(lhat.c3, lhat.c4, (s - 0.5) / 0.25)
            else
                return lerp_color(lhat.c4, lhat.c1, (s - 0.75) / 0.25)
            end
        end
        local function palette_cycle(pal, t0, time, spd)
            local n = #pal
            if n == 0 then return Color3.new(1, 1, 1) end
            if n == 1 then return pal[1] end
            local s = (t0 + time * (spd or lhat.speed)) % 1
            local x = s * n
            local i = math.floor(x) + 1
            local f = x - math.floor(x)
            local a = pal[i]
            local b = pal[i % n + 1]
            return lerp_color(a, b, f)
        end
        local function astolfo(t0, time)
            local pal = {Color3.fromRGB(255, 105, 180), Color3.fromRGB(255, 75, 150), Color3.fromRGB(135, 206, 250)}
            return palette_cycle(pal, t0, time, 0.25)
        end
        local function rainbow(t0, time)
            local h = (time * 0.2 + t0) % 1
            return Color3.fromHSV(h, 0.6, 1)
        end
        local palettes = {
            CustomPalette1 = {Color3.fromRGB(255, 94, 58), Color3.fromRGB(255, 154, 0), Color3.fromRGB(255, 212, 0)},
            CustomPalette2 = {Color3.fromRGB(0, 212, 255), Color3.fromRGB(0, 128, 255), Color3.fromRGB(0, 64, 128), Color3.fromRGB(0, 40, 80)},
            CustomPalette3 = {Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 102, 0)},
            CustomPalette4 = {Color3.fromRGB(200, 255, 255), Color3.fromRGB(150, 220, 255), Color3.fromRGB(100, 200, 255), Color3.fromRGB(80, 160, 220), Color3.fromRGB(60, 120, 190)},
            CustomPalette5 = {Color3.fromRGB(88, 0, 255), Color3.fromRGB(255, 0, 191), Color3.fromRGB(0, 160, 255)},
            CustomPalette6 = {Color3.fromRGB(0, 255, 128), Color3.fromRGB(255, 0, 255), Color3.fromRGB(0, 255, 255)},
            CustomPalette7 = {Color3.fromRGB(255, 255, 255), Color3.fromRGB(200, 200, 200), Color3.fromRGB(150, 150, 150), Color3.fromRGB(100, 100, 100)},
            CustomPalette8 = {Color3.fromRGB(255, 20, 147), Color3.fromRGB(186, 85, 211), Color3.fromRGB(72, 61, 139)},
            CustomPalette9 = {Color3.fromRGB(0, 255, 255), Color3.fromRGB(173, 216, 230), Color3.fromRGB(25, 25, 112)},
            CustomPalette10 = {Color3.fromRGB(255, 215, 0), Color3.fromRGB(255, 165, 0), Color3.fromRGB(255, 69, 0)},
            CustomPalette11 = {Color3.fromRGB(124, 252, 0), Color3.fromRGB(50, 205, 50), Color3.fromRGB(0, 128, 0)},
            CustomPalette12 = {Color3.fromRGB(0, 0, 0), Color3.fromRGB(45, 0, 80), Color3.fromRGB(120, 0, 200), Color3.fromRGB(255, 0, 255)},
            CustomPalette13 = {Color3.fromRGB(0, 0, 128), Color3.fromRGB(0, 0, 255), Color3.fromRGB(0, 191, 255), Color3.fromRGB(135, 206, 250)},
            CustomPalette14 = {Color3.fromRGB(255, 105, 180), Color3.fromRGB(255, 182, 193), Color3.fromRGB(135, 206, 250)},
            CustomPalette15 = {Color3.fromRGB(240, 255, 255), Color3.fromRGB(176, 224, 230), Color3.fromRGB(135, 206, 235), Color3.fromRGB(70, 130, 180)},
            CustomPalette16 = {Color3.fromRGB(255, 255, 240), Color3.fromRGB(255, 250, 205), Color3.fromRGB(250, 250, 210), Color3.fromRGB(238, 232, 170)}
        }
        local function pick_color(t0, time)
            local st = lhat.style
            if st == "Rainbow" then
                return rainbow(t0, time)
            elseif st == "Astolfo" then
                return astolfo(t0, time)
            elseif palettes[st] ~= nil then
                return palette_cycle(palettes[st], t0, time, 0.2)
            else
                return cycle_custom(t0, time)
            end
        end
        local function ensure_draws()
            if #lhat.drawings == lhat.sides then return end
            for _, pair in ipairs(lhat.drawings) do
                pcall(function() if pair[1] then pair[1]:Remove() end end)
                pcall(function() if pair[2] then pair[2]:Remove() end end)
            end
            lhat.drawings = {}
            for i = 1, lhat.sides do
                local ln = Drawing.new("Line")
                local tri = Drawing.new("Triangle")
                ln.ZIndex = 2
                ln.Thickness = 1
                tri.ZIndex = 1
                tri.Filled = true
                table.insert(lhat.drawings, {ln, tri})
            end
        end
        local function set_visible(vis)
            for _, pair in ipairs(lhat.drawings) do
                local ln, tri = pair[1], pair[2]
                if ln then ln.Visible = vis end
                if tri then tri.Visible = vis end
            end
        end
        local function cleanup()
            if lhat.conn then
                pcall(function() lhat.conn:Disconnect() end)
                lhat.conn = nil
            end
            for _, pair in ipairs(lhat.drawings) do
                pcall(function() if pair[1] then pair[1]:Remove() end end)
                pcall(function() if pair[2] then pair[2]:Remove() end end)
            end
            lhat.drawings = {}
        end
        local function update_hat()
            if not lhat.enabled then
                cleanup()
                return
            end
            local lp = (vars and vars.lp) or (game and game:GetService("Players").LocalPlayer)
            local char = lp and lp.Character or nil
            local head = char and char:FindFirstChild("Head")
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            if not (char and head and hum and hum.Health > 0) then
                set_visible(false)
                return
            end
            ensure_draws()
            local cam = (B and B.cam) or workspace.CurrentCamera
            local t = tick()
            local twoPi = math.pi * 2
            local base = head.Position + Vector3.new(0, 0.75, 0)
            local top = base + Vector3.new(0, lhat.height, 0)
            local sp, on = cam:WorldToViewportPoint(head.Position)
            if not on or sp.Z <= 0 then
                set_visible(false)
                return
            end
            for idx = 1, lhat.sides do
                local ln, tri = lhat.drawings[idx][1], lhat.drawings[idx][2]
                local t0 = idx / lhat.sides
                local t1 = (idx % lhat.sides + 1) / lhat.sides
                local a = t0 * twoPi
                local b = t1 * twoPi
                local p1 = base + Vector3.new(math.cos(a), 0, math.sin(a)) * lhat.radius
                local p2 = base + Vector3.new(math.cos(b), 0, math.sin(b)) * lhat.radius
                local v1 = cam:WorldToViewportPoint(p1)
                local v2 = cam:WorldToViewportPoint(p2)
                local v3 = cam:WorldToViewportPoint(top)
                local col = pick_color(t0, t)
                ln.From = Vector2.new(v1.X, v1.Y)
                ln.To = Vector2.new(v2.X, v2.Y)
                ln.Color = col
                ln.Transparency = lhat.line_trs
                ln.Visible = true
                tri.PointA = Vector2.new(v3.X, v3.Y)
                tri.PointB = ln.From
                tri.PointC = ln.To
                tri.Color = col
                tri.Transparency = lhat.hat_trs
                tri.Visible = true
            end
        end
        -- UI
        local chinahat_toggle = local_section:toggle({
            name = "ChinaHat",
            flag = "selfhat_enabled",
            default = false,
            callback = function(state)
                lhat.enabled = state
                if state then
                    if not lhat.conn then
                        lhat.conn = (B and B.run or game:GetService("RunService")).RenderStepped:Connect(update_hat)
                    end
                else
                    cleanup()
                end
            end
        })
        chinahat_toggle:colorpicker({name = "Color 1", flag = "selfhat_c1", default = lhat.c1, callback = function(col) lhat.c1 = col end})
        chinahat_toggle:colorpicker({name = "Color 2", flag = "selfhat_c2", default = lhat.c2, callback = function(col) lhat.c2 = col end})
        chinahat_toggle:colorpicker({name = "Color 3", flag = "selfhat_c3", default = lhat.c3, callback = function(col) lhat.c3 = col end})
        chinahat_toggle:colorpicker({name = "Color 4", flag = "selfhat_c4", default = lhat.c4, callback = function(col) lhat.c4 = col end})
        local chinahat_dep = local_section:dependency_box()
        chinahat_dep:setup_dependencies({{chinahat_toggle, true}})
        chinahat_dep:dropdown({
            name = "Style",
            flag = "selfhat_style",
            items = {
                "Custom",
                "Rainbow",
                "Astolfo",
                "CustomPalette1",
                "CustomPalette2",
                "CustomPalette3",
                "CustomPalette4",
                "CustomPalette5",
                "CustomPalette6",
                "CustomPalette7",
                "CustomPalette8",
                "CustomPalette9",
                "CustomPalette10",
                "CustomPalette11",
                "CustomPalette12",
                "CustomPalette13",
                "CustomPalette14",
                "CustomPalette15",
                "CustomPalette16"
            },
            default = "Custom",
            callback = function(val)
                lhat.style = val
            end
        })
        -- also track via global connections for script cleanup
        table.insert(a.connections, {
            Disconnect = function()
                cleanup()
            end
        })
        -- aimbot system end (local chinahat)
    end
end

for hz, cL in next, f.preset do
    pcall(
        function()
            j:update_theme(hz, cL)
        end
    )
end
j:notification({text = "hello, client is loaded, onyx hub = zalupa ebanaya", time = 10})
