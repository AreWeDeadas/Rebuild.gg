loadstring(game:HttpGet("https://pastebin.com/raw/gimbTwW1"))()
local library, dim2, hex, rgbseq, rgbkey, themes, flags, random, lp = loadstring(game:HttpGet("https://raw.githubusercontent.com/AreWeDeadas/Rebuild.gg/refs/heads/main/libraryv2"))()

local window = library:window({
	name = os.date("Rebuild.gg - skidded by 32vision - %b %d %Y - Private - onyxhub sucks - cursed by 32vision to win - creds to chagpt "),
	size = dim2(0, 614, 0, 639),
})
-- custom hud system end
local Aimbot = window:tab({ name = "Rage" })
local Misc = window:tab({ name = "Misc" })
local Visuals = window:tab({ name = "Visuals" })
local Players = window:tab({ name = "Players" })
local Settings = window:tab({ name = "Settings" })
--
local watermark = library:watermark({
	default = os.date("Rebuild.gg - fuckass - %b %d %Y - %H:%M:%S"),
})
--
local radar = library:radar({
	size = 200,
	clamp = true,
})
--
local custom_hud = library:custom_hud({
	size = dim2(0, 280, 0, 32),
	position = dim2(0, 250, 0, 300),
	hud_type = "Rust"
})
--

-- cached services and common objects
local vars = {
	ps = game:GetService("Players"),
	run = game:GetService("RunService"),
	uis = game:GetService("UserInputService"),
	ts = game:GetService("TweenService"),
	hs = game:GetService("HttpService"),
	cam = workspace.CurrentCamera,
	camera = workspace.CurrentCamera, -- alias for code paths using vars.camera
	workspace = workspace, -- alias for code paths using vars.workspace
	math = math,
	cf = CFrame,
	v2 = Vector2,
	v3 = Vector3,
	Vector3 = Vector3, -- alias for vars.Vector3.new(...)
	RaycastParams = RaycastParams, -- alias for vars.RaycastParams
	task = task,
	tick = tick, -- alias for vars.tick()
}

-- enable debug logs
flags["Debug"] = true
print("[Rebuild] Debug enabled")

-- utility system start
local utility = {}
do
	-- validate player has alive character
	function utility:ValidateClient(player)
		if not player then return false end
		local char = player.Character
		if not char then return false end
		local hum = char:FindFirstChildOfClass("Humanoid")
		if not hum or hum.Health <= 0 then return false end
		return true
	end

	-- визуализация десинка start
	local function ensure_visuals()
		-- Part (создаем один раз)
		if not state.viz_part then
			local p = Instance.new("Part")
			p.Name = "RB_DesyncViz"
			p.Anchored = true
			p.CanCollide = false
			p.Massless = true
			p.Material = Enum.Material.Neon
			p.Color = Color3.fromRGB(255, 80, 80)
			p.Size = Vector3.new(0.6, 0.6, 0.6)
			p.Transparency = 0.1
			p.Parent = workspace
			state.viz_part = p
		end
		-- Tracer Line (Drawing)
		if not state.viz_line then
			local line = Drawing.new("Line")
			line.Visible = false
			line.Thickness = 2
			line.Transparency = 1
			line.Color = Color3.fromRGB(255, 80, 80)
			state.viz_line = line
		end
	end

	local function get_desync_cf()
		if state.followMode then
			local _, _, hrp = desync_utility:getPlayerParts(LocalPlayer)
			return hrp and hrp.CFrame or nil
		end
		return state.targetCFrame or state.realCFrame
	end

	local function update_visuals()
		if not state.viz_enabled then return end
		if not desync_utility:ValidateClient(LocalPlayer) then return end
		ensure_visuals()
		local cf = get_desync_cf()
		local part = state.viz_part
		local line = state.viz_line
		if not cf or not part or not line then return end
		-- обновляем позицию парта
		part.CFrame = cf
		-- 2D трейсер от мыши к позиции парта
		local pos = cf.Position
		local v3p, on = desync_vars.cam:WorldToViewportPoint(pos)
		local start2 = desync_vars.uis:GetMouseLocation()
		local end2 = Vector2.new(v3p.X, v3p.Y)
		line.From = start2
		line.To = end2
		line.Visible = on == true
		-- сам Part включен/выключен видимостью через прозрачность
		part.Transparency = 0.1
	end

	local function start_visuals()
		if state.viz_conn then return end
		state.viz_conn = desync_vars.RunService.RenderStepped:Connect(function()
			if not state.viz_enabled then return end
			update_visuals()
		end)
	end

	local function stop_visuals()
		if state.viz_conn then pcall(function() state.viz_conn:Disconnect() end) state.viz_conn = nil end
		if state.viz_line then state.viz_line.Visible = false end
		if state.viz_part then state.viz_part.Transparency = 1 end
	end
	-- визуализация десинка end

	-- preferred body part for targeting
	function utility:GetPreferredPart(char)
		return char and (
			char:FindFirstChild("HumanoidRootPart")
			or char:FindFirstChild("Head")
			or char:FindFirstChild("UpperTorso")
			or char:FindFirstChild("Torso")
		) or nil
	end

	-- world position to screen point
	function utility:ToScreen(pos)
		local v3p, on = vars.cam:WorldToViewportPoint(pos)
		return vars.v2.new(v3p.X, v3p.Y), on
	end

	-- mouse helpers
	function utility:GetMouseLocation()
		return vars.uis:GetMouseLocation()
	end
	function utility:GetMouseDistance(screenPoint)
		return (self:GetMouseLocation() - screenPoint).Magnitude
	end

	-- get closest player to mouse on screen
	function utility:GetClosestToMouse()
		local best, bestd = nil, nil
		for _, plr in ipairs(vars.ps:GetPlayers()) do
			if plr ~= lp and self:ValidateClient(plr) then
				local char = plr.Character
				local part = self:GetPreferredPart(char)
				if part then
					local sp, on = self:ToScreen(part.Position)
					if on then
						local d = self:GetMouseDistance(sp)
						if not bestd or d < bestd then
							best, bestd = plr, d
						end
					end
				end
			end
		end
		return best, bestd or vars.math.huge
	end

	-- damage detection framework start
	-- listeners storage
	utility._hit_listeners = {}

	-- target info feed storage
	utility._target = {
		info = nil, -- table with all fields
		listeners = {},
	}

	-- subscribe to hit event
	function utility:OnHit(callback)
		if typeof(callback) == "function" then
			table.insert(self._hit_listeners, callback)
		end
	end

	-- subscribe to target info updates
	function utility:OnTargetUpdate(callback)
		if typeof(callback) == "function" then
			table.insert(self._target.listeners, callback)
		end
	end

	-- internal: emit hit event safely
	function utility:_emit_hit(info)
		for _, fn in ipairs(self._hit_listeners) do
			pcall(fn, info)
		end
	end

	-- internal: print to chat helper
	function utility:_chat(msg)
		local sg = game:GetService("StarterGui")
		pcall(function()
			sg:SetCore("ChatMakeSystemMessage", { Text = msg })
		end)
		print(msg)
	end

	-- public: get current target info and istarget flag
	function utility:GetTargetInfo()
		local info = self._target.info
		return info ~= nil, info
	end

	-- public: set current target info by player (auto-collects fields)
	function utility:SetTargetInfo(player)
		local info = nil
		-- always drive damage detector override immediately
		utility._dd.override_player = player or nil
		if player and player.Character then
			local char = player.Character
			local hum = char:FindFirstChildOfClass("Humanoid")
			local root = hum and hum.RootPart or char:FindFirstChild("HumanoidRootPart")
			local health = hum and hum.Health or nil
			local maxh = hum and hum.MaxHealth or nil
			-- use dot to test method existence, then call via ':' safely
			local cf = root and root.CFrame or ((char.GetPivot and char:GetPivot()) or nil)
			local pos = root and root.Position or (cf and cf.Position or nil)
			info = {
				isTarget = true,
				player = player,
				userId = player.UserId,
				name = player.Name,
				displayName = player.DisplayName,
				character = char,
				humanoid = hum,
				root = root,
				cframe = cf,
				position = pos,
				health = health,
				maxHealth = maxh,
				alive = hum and hum.Health > 0,
				time = os.clock(),
			}
		end
		self._target.info = info
		-- notify listeners
		for _, fn in ipairs(self._target.listeners) do
			pcall(fn, info)
		end
		if flags and flags["Debug"] then
			if info then
				print("[TargetFeed] SetTargetInfo:", info.name)
			else
				print("[TargetFeed] SetTargetInfo (char not ready):", player and player.Name or "nil")
			end
		end
	end

	function utility:ClearTargetInfo()
		self._target.info = nil
		utility._dd.override_player = nil
		for _, fn in ipairs(self._target.listeners) do
			pcall(fn, nil)
		end
		if flags and flags["Debug"] then
			print("[TargetFeed] ClearTargetInfo")
		end
	end

	-- internal state for damage detection
	utility._dd = {
		last_target = nil,
		last_char = nil,
		hum = nil,
		last_health = nil,
		last_max = nil,
		conn = nil,
		hum_conn = nil,
		last_debug_t = 0,
		override_player = nil, -- приоритетная цель, установленная таргетингом вручную
	}

	-- external setter: таргетинг сообщает текущую цель
	function utility:SetCurrentTarget(player)
		utility._dd.override_player = player
		if flags and flags["Debug"] then
			print("[DD] SetCurrentTarget:", player and player.Name)
		end
	end

	function utility:ClearCurrentTarget()
		utility._dd.override_player = nil
		if flags and flags["Debug"] then
			print("[DD] ClearCurrentTarget")
		end
	end

	-- start heartbeat watcher once
	if not utility._dd.conn then
		utility._dd.conn = vars.run.Heartbeat:Connect(function()
			local dd = utility._dd
			-- используем приоритетно цель, установленную через SetCurrentTarget
			local current = utility._dd.override_player or (targeting_state and targeting_state.current or nil)

			-- periodic debug heartbeat
			if flags and flags["Debug"] then
				local now = os.clock()
				if now - (dd.last_debug_t or 0) > 1 then
					dd.last_debug_t = now
					print(string.format("[DD] hb: current=%s hum=%s lh=%s lm=%s", 
						current and current.Name or "nil",
						(dd.hum and "ok" or "nil"),
						tostring(dd.last_health),
						tostring(dd.last_max)
					))
				end
			end

			-- target switched: hard reset
			if current ~= dd.last_target then
				dd.last_target = current
				dd.last_char = nil
				dd.hum = nil
				dd.last_health = nil
				dd.last_max = nil

				-- disconnect previous humanoid connection
				if dd.hum_conn then pcall(function() dd.hum_conn:Disconnect() end) dd.hum_conn = nil end
				if flags and flags["Debug"] then
					print("[DD] target switched to:", current and current.Name)
				end
			end

			if not current then return end

			-- refresh humanoid if character changed (respawn) or missing
			local char = current.Character
			if char ~= dd.last_char or (dd.hum and not dd.hum.Parent) then
				dd.last_char = char
				dd.hum = char and char:FindFirstChildOfClass("Humanoid") or nil
				dd.last_health = nil
				dd.last_max = nil
				-- reconnect HealthChanged for new humanoid
				if dd.hum_conn then pcall(function() dd.hum_conn:Disconnect() end) dd.hum_conn = nil end
				if dd.hum then
					-- wait for humanoid to be ready
					vars.run.Heartbeat:Wait()
					if flags and flags["Debug"] then
						print("[DD] humanoid bound for:", current and current.Name)
					end
					dd.hum_conn = dd.hum.HealthChanged:Connect(function(ch)
						local cm = dd.hum and dd.hum.MaxHealth or 0
						if dd.last_health == nil or dd.last_max == nil or cm ~= dd.last_max then
							dd.last_health = ch
							dd.last_max = cm
							return
						end
						if ch ~= dd.last_health then
							local dmg = dd.last_health - ch
							if dmg > 0 then
								local percent = vars.math.floor(((cm > 0 and ch / cm or 0) * 100) + 0.5)
								local hitinfo = {
									player = current,
									damage = dmg,
									health = ch,
									max = cm,
									percentage = percent,
								}
								if flags and flags["Debug"] then
									print("[DD] hit:", hitinfo.player and hitinfo.player.Name, hitinfo.damage, hitinfo.health, hitinfo.max, hitinfo.percentage)
								end
								-- utility:_emit_hit(hitinfo) -- disabled: using new damage detection system
							end
							dd.last_health = ch
							dd.last_max = cm
						end
					end)
				end
			end

			local hum = dd.hum
			if not hum or not hum.Parent then return end

			local ch = hum.Health
			local cm = hum.MaxHealth

			-- initialize or reset when MaxHealth changes to avoid false positives
			if dd.last_health == nil or dd.last_max == nil or cm ~= dd.last_max then
				dd.last_health = ch
				dd.last_max = cm
				return
			end

			if ch ~= dd.last_health then
				local dmg = dd.last_health - ch
				if dmg > 0 then
					local percent = vars.math.floor(((cm > 0 and ch / cm or 0) * 100) + 0.5)
					local info = {
						player = current,
						damage = dmg,
						health = ch,
						max = cm,
						percentage = percent,
					}
					utility:_emit_hit(info)
				end
				dd.last_health = ch
				dd.last_max = cm
			end
		end)
		-- default listener: print to chat
		utility:OnHit(function(info)
			local name = (info.player and info.player.Name) or "?"
			local dmg = vars.math.floor(info.damage + 0.5)
			local hp = vars.math.floor(info.health + 0.5)
			local mx = vars.math.floor(info.max + 0.5)
			local pct = vars.math.floor(info.percentage + 0.5)
			utility:_chat(string.format("[Hit] %s -%d HP | %d/%d (%d%%)", name, dmg, hp, mx, pct))
		end)
	end
	-- damage detection framework end

end
-- utility system end

-- desync system start
do
	-- unified configuration
	local config = {
		Desync = {
			Enabled = false, -- включайте при первом вызове API
			LogInterval = 2, -- сек
		}
	}

	-- frequently used cache
	local desync_vars = {
		Players = game:GetService("Players"),
		RunService = game:GetService("RunService"),
		StarterGui = game:GetService("StarterGui"),
		newcf = CFrame.new,
		v3 = Vector3.new,
		typeof = typeof,
		task = task,
		math = math,
		cam = workspace.CurrentCamera,
		uis = game:GetService("UserInputService"),
	}

	local LocalPlayer = desync_vars.Players.LocalPlayer
	local wait = task.wait

	-- module state
	local state = {
		enabled = false,
		targetCFrame = nil,   -- позиция десинка (куда «телепортируется» на кадр)
		realCFrame = nil,     -- реальная позиция игрока (для маскировки и возврата)
		hookInstalled = false,
		logStarted = false,
		followMode = false,   -- режим слежения: цель = текущий HRP каждый кадр
		-- визуализация
		viz_enabled = false,
		viz_part = nil,
		viz_line = nil,
		viz_conn = nil,
	}

	-- // Utility Functions
	local desync_utility = {}

	function desync_utility:ValidateClient(player)
		if not player then return false end
		local char = player.Character
		if not char then return false end
		local hum = char:FindFirstChildOfClass("Humanoid")
		if not hum or hum.Health <= 0 then return false end
		local hrp = hum.RootPart
		return hrp ~= nil
	end

	function desync_utility:getPlayerParts(player)
		local char = player and player.Character
		local hum = char and char:FindFirstChildOfClass("Humanoid")
		local hrp = hum and hum.RootPart
		return char, hum, hrp
	end

	local function asCFrame(x, y, z)
		local t = desync_vars.typeof(x)
		if t == "CFrame" then return x end
		if t == "Vector3" then return desync_vars.newcf(x) end
		if t == "table" and x[1] and x[2] and x[3] then
			return desync_vars.newcf(x[1], x[2], x[3])
		end
		if t == "number" and type(y) == "number" and type(z) == "number" then
			return desync_vars.newcf(x, y, z)
		end
		return nil
	end

	-- перехват чтения CFrame для сокрытия резких смещений на кадр
	local function installHook()
		if state.hookInstalled then return end
		if not hookmetamethod or not newcclosure or not checkcaller then
			-- среда не поддерживает перехват — пропустим
			state.hookInstalled = true -- помечаем, чтобы не пытаться снова
			return
		end

		local oldIndex
		oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
			if not checkcaller() then
				if key == "CFrame" and state.enabled then
					local _, hum, hrp = desync_utility:getPlayerParts(LocalPlayer)
					if hrp and self == hrp and state.realCFrame then
						return state.realCFrame
					end
				end
			end
			return oldIndex(self, key)
		end))

		state.hookInstalled = true
	end

	-- основной цикл десинка: коротко переносит HRP в targetCFrame и возвращает обратно
	local function startHeartbeat()
		if state.heartbeatConn then return end

		state.heartbeatConn = desync_vars.RunService.Heartbeat:Connect(function()
			if not config.Desync.Enabled or not state.enabled then return end
			if not desync_utility:ValidateClient(LocalPlayer) then return end

			local _, _, hrp = desync_utility:getPlayerParts(LocalPlayer)
			if not hrp then return end

			state.realCFrame = hrp.CFrame
			local target
			if state.followMode then
				target = hrp.CFrame
			else
				target = state.targetCFrame or state.realCFrame
			end

			-- перенос на кадр в цель, затем возврат
			hrp.CFrame = target
			desync_vars.RunService.RenderStepped:Wait()
			hrp.CFrame = state.realCFrame
		end)
	end

	-- логгирование позиции десинка
	local function startLogger()
		if state.logStarted then return end
		state.logStarted = true

		desync_vars.task.spawn(function()
			while true do
				desync_vars.task.wait(config.Desync.LogInterval)
				if config.Desync.Enabled and state.enabled then
					local pos
					if state.targetCFrame then
						pos = state.targetCFrame.Position
					else
						local _, _, hrp = desync_utility:getPlayerParts(LocalPlayer)
						pos = hrp and hrp.Position or nil
					end
					if pos then
						print(string.format("[DesyncLibrary] Pos: (%.2f, %.2f, %.2f)", pos.X, pos.Y, pos.Z))
					else
						print("[DesyncLibrary] Pos: nil (not set)")
					end
				end
			end
		end)
	end

	-- публичное API
	local DesyncLibrary = {}

	-- перемещение десинка в координаты/вектор/кадровый CFrame
	function DesyncLibrary.movedesyncto(x, y, z)
		local cf = asCFrame(x, y, z)
		if not cf then error("movedesyncto: invalid coordinates") end

		state.targetCFrame = cf
		state.followMode = false
		config.Desync.Enabled = true
		state.enabled = true

		installHook()
		startHeartbeat()
		startLogger()

		return cf
	end

	-- проверка текущей позиции десинка (возвращает Vector3 | nil)
	function DesyncLibrary.checksyncposition()
		local pos
		if state.targetCFrame then
			pos = state.targetCFrame.Position
		else
			local _, _, hrp = desync_utility:getPlayerParts(LocalPlayer)
			pos = hrp and hrp.Position or nil
		end
		if pos then
			print(string.format("[DesyncLibrary] Pos: (%.2f, %.2f, %.2f)", pos.X, pos.Y, pos.Z))
		else
			print("[DesyncLibrary] Pos: nil (not set)")
		end
		return pos
	end

	-- возвращает десинк к позиции локального игрока
	function DesyncLibrary.SynchronizeSyncWithPlayer()
		if not desync_utility:ValidateClient(LocalPlayer) then
			error("SynchronizeSyncWithPlayer: player not ready")
		end
		-- follow mode: делаем цель равной текущему положению игрока динамически
		state.targetCFrame = nil
		state.followMode = true

		config.Desync.Enabled = true
		state.enabled = true

		installHook()
		startHeartbeat()
		startLogger()

		local _, _, hrp = desync_utility:getPlayerParts(LocalPlayer)
		return hrp and hrp.CFrame or nil
	end

	-- вкл/выкл визуализацию из UI/кода
	function DesyncLibrary.SetVisualiseEnabled(enabled)
		state.viz_enabled = enabled and true or false
		if state.viz_enabled then
			ensure_visuals()
			start_visuals()
		else
			stop_visuals()
		end
		return state.viz_enabled
	end

	-- опционально экспортируем в getgenv для удобства
	pcall(function()
		getgenv().DesyncLibrary = DesyncLibrary
	end)

	-- экспортируем в глобальную область для использования в других модулях
	_G.DesyncLibrary = DesyncLibrary
end
-- desync system end

-- shared targeting state (used by targeting UI and aimbot)
local targeting_state = { current = nil }
-- targeting system start
do
	-- framework function
	local framework = {}

    -- highlight state (for visuals)
	    -- highlight state (for visuals)
    local hl_state = { 
        last_char = nil, 
        hl = nil,           -- LOS highlight (DepthMode = Occluded), parented to real char
        occ_hl = nil,       -- OCC highlight (AlwaysOnTop), parented to cloned model
        occ_model = nil,    -- cloned model welded to real character parts
        char_added_conn = nil,
        char_removing_conn = nil,
        died_conn = nil, 
        bound_player = nil,
        update_counter = 0
    }
    local HL_NAME = "RB_HL_32v"
    
    -- больше не создаем заранее и не переиспользуем
    local function get_or_create_highlight()
        local h = Instance.new("Highlight")
        h.Name = HL_NAME
        -- default DepthMode adjusted when applied
        h.DepthMode = Enum.HighlightDepthMode.Occluded
        return h
    end

    local function build_occ_model(char)
        -- destroy previous model
        if hl_state.occ_model then pcall(function() hl_state.occ_model:Destroy() end) hl_state.occ_model = nil end
        if not char then return end
        local m = Instance.new("Model")
        m.Name = "RB_TH_OCC"
        m.Parent = workspace
        for _, child in ipairs(char:GetChildren()) do
            if child:IsA("BasePart") then
                local cloned = child:Clone()
                cloned:ClearAllChildren()
                cloned.CanCollide = false
                if cloned:IsA("MeshPart") then cloned.TextureID = "" end
                cloned.Size = cloned.Size * 0.99 -- prevent z-fighting
                cloned.Parent = m
                local weld = Instance.new("WeldConstraint")
                weld.Part0 = cloned
                weld.Part1 = child
                weld.Parent = cloned
            end
        end
        hl_state.occ_model = m
    end

    local function clear_highlight()
        -- soft clear: disable visuals, keep singletons, cleanup cloned model
        if hl_state.hl then
            hl_state.hl.Enabled = false
            hl_state.hl.Adornee = nil
            hl_state.hl.Parent = nil
        end
        if hl_state.occ_hl then
            hl_state.occ_hl.Enabled = false
            hl_state.occ_hl.Adornee = nil
            hl_state.occ_hl.Parent = nil
        end
        if hl_state.occ_model then pcall(function() hl_state.occ_model:Destroy() end) hl_state.occ_model = nil end
        if hl_state.died_conn then pcall(function() hl_state.died_conn:Disconnect() end) hl_state.died_conn = nil end
        if hl_state.char_added_conn then pcall(function() hl_state.char_added_conn:Disconnect() end) hl_state.char_added_conn = nil end
        if hl_state.char_removing_conn then pcall(function() hl_state.char_removing_conn:Disconnect() end) hl_state.char_removing_conn = nil end
        hl_state.last_char = nil
        hl_state.bound_player = nil
    end

    local function clear_highlight_visual()
        -- ТОЛЬКО визуальная очистка: не уничтожаем, а отключаем singleton
        if hl_state.hl then
            hl_state.hl.Enabled = false
            hl_state.hl.Adornee = nil
        end
        if hl_state.occ_hl then
            hl_state.occ_hl.Enabled = false
            hl_state.occ_hl.Adornee = nil
        end
        hl_state.last_char = nil
        -- НЕ трогаем char_added_conn/char_removing_conn/died_conn здесь
    end

	    -- utility getters for flags
    local function get_cp_color(flag, default)
        local v = flags and flags[flag]
        if v == nil then return default end
        local t = typeof(v)
        if t == "table" and v.Color then return v.Color end
        if t == "Color3" then return v end
        return default
    end

    local function get_num(flag, default)
        local v = flags and flags[flag]
        if typeof(v) == "number" then return v end
        return default
    end

    local function apply_highlight(char)
        -- выключаем визуал, если настроек нет или цель отсутствует
        if not char or not flags or not flags["target_highlight"] then
            clear_highlight_visual()
            return
        end

        -- ensure LOS/OCC singletons
        if not hl_state.hl then hl_state.hl = get_or_create_highlight() end
        if not hl_state.occ_hl then hl_state.occ_hl = get_or_create_highlight() end
        if not hl_state.occ_model or not hl_state.occ_model.Parent then build_occ_model(char) end

        -- LOS highlight on real char (Occluded)
        local h = hl_state.hl
        h.DepthMode = Enum.HighlightDepthMode.Occluded
        h.FillColor = get_cp_color("th_fill", Color3.fromRGB(255, 255, 0))
        h.OutlineColor = get_cp_color("th_out", Color3.fromRGB(0, 0, 0))
        h.FillTransparency = get_num("th_ftrs", 0.5)
        h.OutlineTransparency = get_num("th_otrs", 0.5)
        if h.Adornee ~= char then h.Adornee = char end
        if h.Parent ~= char then h.Parent = char end
        h.Enabled = true

        -- OCC highlight on cloned model (AlwaysOnTop)
        local oh = hl_state.occ_hl
        oh.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        oh.FillColor = get_cp_color("th_occ_fill", Color3.fromRGB(0, 170, 255))
        oh.OutlineColor = get_cp_color("th_occ_out", Color3.fromRGB(0, 0, 0))
        oh.FillTransparency = get_num("th_occ_ftrs", 0.3)
        oh.OutlineTransparency = get_num("th_occ_otrs", 0.7)
        if oh.Adornee ~= hl_state.occ_model then oh.Adornee = hl_state.occ_model end
        if oh.Parent ~= hl_state.occ_model then oh.Parent = hl_state.occ_model end
        oh.Enabled = true

        hl_state.last_char = char
    end

    local function bind_humanoid_died(char)
        if not char then return end
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            if hl_state.died_conn then pcall(function() hl_state.died_conn:Disconnect() end) end
            hl_state.died_conn = hum.Died:Connect(function()
                -- цель умерла: убираем только визуал, оставляем подписки для авто-реапплая
                print("[TH] Humanoid died for:", char.Name, "- removing visual highlight")
                clear_highlight_visual()
            end)
        end
    end

    -- utility: disable highlight (не удаляем, только отключаем)
    local function remove_all_highlights(char)
        if not char then return end
        print("[TH] Cleanup highlights for:", char.Name)
        if hl_state.hl then
            hl_state.hl.Enabled = false
            hl_state.hl.Adornee = nil
        end
        -- очищаем другие highlight если есть
        for _, obj in ipairs(char:GetDescendants()) do
            if typeof(obj) == "Instance" and obj:IsA("Highlight") and obj ~= hl_state.hl then
                pcall(function() obj:Destroy() end)
            end
        end
    end

    local function setup_target_highlight_bindings(player)
        if not player then return end
        
        -- отключаем старые подключения
        if hl_state.char_added_conn then 
            pcall(function() hl_state.char_added_conn:Disconnect() end) 
        end
        if hl_state.char_removing_conn then 
            pcall(function() hl_state.char_removing_conn:Disconnect() end) 
        end
        
        hl_state.bound_player = player
        
        -- обработчик удаления персонажа
        hl_state.char_removing_conn = player.CharacterRemoving:Connect(function()
            print("[TH] CharacterRemoving for:", player.Name)
            -- только визуальная очистка, сохраняем подписки
            clear_highlight_visual()
        end)
        
        -- обработчик добавления персонажа (как в scripttoskid)
        hl_state.char_added_conn = player.CharacterAdded:Connect(function(newChar)
            if not newChar then return end
            print("[TH] CharacterAdded for:", player.Name)
            -- ждем загрузки персонажа
            game:GetService("RunService").Heartbeat:Wait()
            
            -- проверяем что этот игрок все еще является текущей целью
            local is_current_target = targeting_state and targeting_state.current and 
                (targeting_state.current == player or 
                 (targeting_state.current.UserId and targeting_state.current.UserId == player.UserId))
            
            if is_current_target and flags and flags["target_highlight"] then
                print("[TH] Reapplying highlight after respawn for:", player.Name)
                apply_highlight(newChar)
                bind_humanoid_died(newChar)
            end
        end)
        
        -- применяем к текущему персонажу если существует
        if player.Character then
            apply_highlight(player.Character)
            bind_humanoid_died(player.Character)
        end
    end
    
    -- простое обновление: при смене цели пересоздаем highlight
    local function is_visible(char)
        if not char then return false end
        local cam = workspace.CurrentCamera
        local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Head")
        if not root then return false end
        local origin = cam.CFrame.Position
        local dir = (root.Position - origin)
        local rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        rayParams.FilterDescendantsInstances = { lp.Character, char, hl_state.occ_model }
        local hit = workspace:Raycast(origin, dir, rayParams)
        return hit == nil
    end

    function framework:update_target_highlight()
        -- выключено в UI -> очищаем и выходим
        if not flags or not flags["target_highlight"] then
            clear_highlight()
            return
        end

        local current = targeting_state and targeting_state.current
        local char = current and current.Character
        if not char then
            clear_highlight()
            return
        end

        -- при смене цели пересоздаем
        if hl_state.last_char ~= char then
            apply_highlight(char)
            bind_humanoid_died(char)
        end

        -- toggle occlusion highlight based on visibility
        local vis = is_visible(char)
        if hl_state.occ_hl then hl_state.occ_hl.Enabled = not vis end
    end

	-- use shared state instead of a private upvalue
	-- current target is stored in `targeting_state.current`
	
	function framework:selectTarget() 
		-- проверка включен ли targeting
		if not flags or not flags["Targeting_Enabled"] then 
			return 
		end
		
		if flags and flags["Debug"] then print("[Targeting] selectTarget called") end

		if targeting_state.current then
			if flags and flags["Debug"] then print("[Targeting] Releasing target:", targeting_state.current.Name) end
			clear_highlight()
			targeting_state.current = nil
			-- очищаем информацию о цели для детекции урона
			utility:ClearTargetInfo()
			utility:ClearCurrentTarget()
			-- обновляем видимость бинда
			if targeting_keybind and targeting_keybind.update_visibility then
				targeting_keybind.update_visibility()
			end
			if flags and flags["Debug"] then print("[Targeting] Target cleared") end
		else
			-- Acquire new target via utility
			local best_player, best_dist = utility:GetClosestToMouse()
			if best_player then
				targeting_state.current = best_player
				-- устанавливаем цель для детекции урона
				utility:SetTargetInfo(best_player)
				utility:SetCurrentTarget(best_player)
				if flags and flags["target_highlight"] then
					setup_target_highlight_bindings(best_player)
				end
				-- обновляем видимость бинда
				if targeting_keybind and targeting_keybind.update_visibility then
					targeting_keybind.update_visibility()
				end
				if flags and flags["Debug"] then
					print("[Targeting] Target acquired:", targeting_state.current.Name, "(MouseDist:", vars.math.floor(best_dist), ")")
				end
			else
				if flags and flags["Debug"] then print("[Targeting] No target found") end
			end
		end
	end
	
	-- ui elements
	local rage_col = Aimbot:column()
	local TargetSec, VisSec = rage_col:multi_section({ names = { "Targeting", "Visuals" } })
	
	local targeting_keybind -- объявляем переменную для доступа к keybind
	local targeting_toggle = TargetSec:toggle({
		name = "Enabled",
		flag = "Targeting_Enabled",
		default = false,
		callback = function(state)
			if not state then
				if flags and flags["Debug"] then print("[Targeting] Disabled -> clearing target") end
				-- clear visuals and state
				clear_highlight()
				targeting_state.current = nil
				utility:ClearTargetInfo()
				utility:ClearCurrentTarget()
				-- update keybind visibility if available
				if targeting_keybind and targeting_keybind.update_visibility then
					targeting_keybind.update_visibility()
				end
			end
		end,
	})
	
	targeting_keybind = targeting_toggle:keybind({
		name = "Target",
		flag = "Target_Select_Bind",
		default = "t",
		visibility_condition = function()
			-- Показываем в бинд листе только когда есть выбранная цель
			return targeting_state and targeting_state.current ~= nil
		end,
		callback = function()
			framework:selectTarget()
		end,
	})

  -- targeting mode dropdown (Sticky/Nuker)
  local targeting_mode = TargetSec:dropdown({
      name = "Selecting Mode",
      flag = "Targeting_Mode",
      items = { "Sticky", "Nuker" },
      default = "Sticky",
  })

    local function refresh_hl_from_ui()
        if not flags or not flags["target_highlight"] then return end
        local char = hl_state and hl_state.last_char
        if (not char) and targeting_state and targeting_state.current then
            char = targeting_state.current.Character
            -- обновляем last_char если получили новый персонаж
            if char then
                hl_state.last_char = char
            end
        end
        if char then 
            apply_highlight(char) 
            bind_humanoid_died(char)
        end
    end

    local th_toggle = VisSec:toggle({
        name = "Target Highlight",
        flag = "target_highlight",
        default = false,
        callback = function(state)
            if state then
                refresh_hl_from_ui()
            else
                clear_highlight()
            end
        end
    })
    -- colorpickers привязаны к toggle (видны только при включенном TargetHighlight)
    th_toggle:colorpicker({ name = "Fill", flag = "th_fill", default = Color3.fromRGB(255, 255, 0), callback = function()
        refresh_hl_from_ui()
    end })
    th_toggle:colorpicker({ name = "Outline",  flag = "th_out",  default = Color3.fromRGB(0, 0, 0), callback = function()
        refresh_hl_from_ui()
    end })
    -- occluded colorpickers (для случая, когда цель не видима)
    th_toggle:colorpicker({ name = "OccludedFill", flag = "th_occ_fill", default = Color3.fromRGB(0, 170, 255), callback = function()
        refresh_hl_from_ui()
    end })
    th_toggle:colorpicker({ name = "OccludedOutline",  flag = "th_occ_out",  default = Color3.fromRGB(0, 0, 0), callback = function()
        refresh_hl_from_ui()
    end })
	-- dependent transparency sliders (interval 0.01)
	local th_dep = VisSec:dependency_box()
	th_dep:setup_dependencies({ { th_toggle, true } })
	th_dep:slider({ name = "Fill Transparency", flag = "th_ftrs", min = 0, max = 1, default = 0.5, interval = 0.01, callback = function()
        refresh_hl_from_ui()
    end })
    th_dep:slider({ name = "Outline Transparency", flag = "th_otrs", min = 0, max = 1, default = 0.5, interval = 0.01, callback = function()
        refresh_hl_from_ui()
    end })
    th_dep:slider({ name = "OccludedFill Transparency", flag = "th_occ_ftrs", min = 0, max = 1, default = 0.3, interval = 0.01, callback = function()
        refresh_hl_from_ui()
    end })
    th_dep:slider({ name = "OccludedOutline Transparency", flag = "th_occ_otrs", min = 0, max = 1, default = 0.7, interval = 0.01, callback = function()
        refresh_hl_from_ui()
    end })

    -- chams system start
    do
        local chams_state = {
            enabled = false,
            folder = nil,
            handles = {},
            fill_color = hex("#ffffff"),
            fill_transparency = 0.5,
            last_target = nil
        }

        local function cleanup_chams()
            for _, handle in pairs(chams_state.handles) do
                pcall(function() handle:Destroy() end)
            end
            chams_state.handles = {}
            if chams_state.folder then
                pcall(function() chams_state.folder:Destroy() end)
                chams_state.folder = nil
            end
        end

        local function create_chams(char)
            if not char then return end
            
            -- создаем папку для хранения
            if not chams_state.folder then
                chams_state.folder = Instance.new("Folder")
                chams_state.folder.Name = "RB_Chams"
                chams_state.folder.Parent = workspace.CurrentCamera
            end

            -- очищаем старые
            for _, handle in pairs(chams_state.handles) do
                pcall(function() handle:Destroy() end)
            end
            chams_state.handles = {}

            -- создаем chams для каждой части тела
            for _, part in ipairs(char:GetChildren()) do
                if part:IsA("BasePart") and (
                    part.Name:find("Arm") or 
                    part.Name:find("Leg") or 
                    part.Name:find("Hand") or 
                    part.Name:find("Feet") or 
                    part.Name:find("Foot") or
                    part.Name:find("Torso") or 
                    part.Name == "Head"
                ) then
                    local handle = Instance.new("BoxHandleAdornment")
                    handle.Size = part.Size
                    
                    handle.Adornee = part
                    handle.AlwaysOnTop = true
                    handle.ZIndex = 0
                    handle.Transparency = chams_state.fill_transparency
                    handle.Color3 = chams_state.fill_color
                    handle.Parent = chams_state.folder
                    
                    table.insert(chams_state.handles, handle)
                end
            end
        end

        local function update_chams()
            if not chams_state.enabled then
                cleanup_chams()
                return
            end

            local target = targeting_state and targeting_state.current
            if not target or not target.Character then
                cleanup_chams()
                chams_state.last_target = nil
                return
            end

            -- если цель изменилась, пересоздаем
            if chams_state.last_target ~= target.Character then
                create_chams(target.Character)
                chams_state.last_target = target.Character
            end

            -- обновляем свойства
            for _, handle in pairs(chams_state.handles) do
                if handle and handle.Parent then
                    handle.Color3 = chams_state.fill_color
                    handle.Transparency = chams_state.fill_transparency
                    handle.AlwaysOnTop = true
                end
            end
        end

        -- ui элементы
        local chams_toggle = VisSec:toggle({
            name = "Target Chams",
            flag = "target_chams",
            default = false,
            callback = function(state)
                chams_state.enabled = state
                if state then
                    update_chams()
                else
                    cleanup_chams()
                end
            end
        })

        chams_toggle:colorpicker({
            name = "Color",
            flag = "chams_color",
            default = hex("#ffffff"),
            callback = function(color)
                chams_state.fill_color = color
                update_chams()
            end
        })

        local chams_dep = VisSec:dependency_box()
        chams_dep:setup_dependencies({ { chams_toggle, true } })
        
        chams_dep:slider({
            name = "Trs",
            flag = "chams_trs",
            min = 0,
            max = 1,
            default = 0.5,
            interval = 0.01,
            callback = function(value)
                chams_state.fill_transparency = value
                update_chams()
            end
        })

        -- Walls always on: chams drawn through walls by default

        -- подключаем к обновлению
        table.insert(library.connections, vars.run.RenderStepped:Connect(function()
            if chams_state.enabled then
                update_chams()
            end
        end))

        -- очистка при смене цели
        utility:OnTargetUpdate(function(info)
            if not info then
                cleanup_chams()
                chams_state.last_target = nil
            end
        end)
    end
    -- chams system end

    -- ChinaHat system start
    do
        local hat = {
            enabled = false,
            style = "Custom", -- Custom/Rainbow/Astolfo
            c1 = Color3.fromRGB(128, 18, 255),
            c2 = Color3.fromRGB(255, 0, 128),
            c3 = Color3.fromRGB(0, 200, 255),
            c4 = Color3.fromRGB(255, 255, 0),
            height = 0.7,
            radius = 2,
            sides = 25,
            hat_trs = 0.35,
            line_trs = 1.0,
            drawings = {},
            conn = nil,
            speed = 0.2,
        }

        local function lerp(a, b, t)
            return a + (b - a) * t
        end

        local function lerp_color(a, b, t)
            return Color3.new(
                lerp(a.R, b.R, t),
                lerp(a.G, b.G, t),
                lerp(a.B, b.B, t)
            )
        end

        local function custom_gradient(t, time)
            -- animated 4-stop gradient using C1..C4
            local tt = (t + (time * hat.speed)) % 1
            if tt < 0.25 then
                return lerp_color(hat.c1, hat.c2, tt / 0.25)
            elseif tt < 0.5 then
                return lerp_color(hat.c2, hat.c3, (tt - 0.25) / 0.25)
            elseif tt < 0.75 then
                return lerp_color(hat.c3, hat.c4, (tt - 0.5) / 0.25)
            else
                return lerp_color(hat.c4, hat.c1, (tt - 0.75) / 0.25)
            end
        end

        -- Generic palette interpolation helper
        local function palette_color(colors, t, time, speed)
            local n = #colors
            if n == 0 then return Color3.new(1,1,1) end
            if n == 1 then return colors[1] end
            local tt = (t + (time * (speed or hat.speed))) % 1
            local seg = tt * n
            local i = math.floor(seg) + 1
            local f = seg - math.floor(seg)
            local a = colors[i]
            local b = colors[(i % n) + 1]
            return lerp_color(a, b, f)
        end

        local function astolfo_color(t, time)
            -- three-tone: pink -> hotpink -> blue (rotating)
            local colors = {
                Color3.fromRGB(255, 105, 180), -- pink
                Color3.fromRGB(255, 75, 150),  -- deeper pink
                Color3.fromRGB(135, 206, 250), -- light blue
            }
            return palette_color(colors, t, time, 0.25)
        end

        local function rainbow_color(t, time)
            local hue = (time * 0.2 + t) % 1
            return Color3.fromHSV(hue, 0.6, 1)
        end

        local function ensure_drawings()
            if #hat.drawings == hat.sides then return end
            -- cleanup first
            for _, pair in ipairs(hat.drawings) do
                pcall(function() if pair[1] then pair[1]:Remove() end end)
                pcall(function() if pair[2] then pair[2]:Remove() end end)
            end
            hat.drawings = {}
            for i = 1, hat.sides do
                local line = Drawing.new("Line")
                local tri = Drawing.new("Triangle")
                line.ZIndex = 2
                line.Thickness = 1
                tri.ZIndex = 1
                tri.Filled = true
                table.insert(hat.drawings, { line, tri })
            end
        end

        local function set_visible_all(v)
            for _, pair in ipairs(hat.drawings) do
                local line, tri = pair[1], pair[2]
                if line then line.Visible = v end
                if tri then tri.Visible = v end
            end
        end

        local function cleanup_hat()
            if hat.conn then
                pcall(function() hat.conn:Disconnect() end)
                hat.conn = nil
            end
            for _, pair in ipairs(hat.drawings) do
                pcall(function() if pair[1] then pair[1]:Remove() end end)
                pcall(function() if pair[2] then pair[2]:Remove() end end)
            end
            hat.drawings = {}
        end

        -- Predefined palettes with neutral names
        local palettes = {
            CustomPalette1  = { Color3.fromRGB(255,94,58),  Color3.fromRGB(255,154,0),  Color3.fromRGB(255,212,0) },
            CustomPalette2  = { Color3.fromRGB(0,212,255),  Color3.fromRGB(0,128,255),  Color3.fromRGB(0,64,128),  Color3.fromRGB(0,40,80) },
            CustomPalette3  = { Color3.fromRGB(255,0,0),    Color3.fromRGB(255,102,0) },
            CustomPalette4  = { Color3.fromRGB(200,255,255),Color3.fromRGB(150,220,255),Color3.fromRGB(100,200,255),Color3.fromRGB(80,160,220), Color3.fromRGB(60,120,190) },
            CustomPalette5  = { Color3.fromRGB(88,0,255),   Color3.fromRGB(255,0,191),  Color3.fromRGB(0,160,255) },
            CustomPalette6  = { Color3.fromRGB(0,255,128),  Color3.fromRGB(255,0,255),  Color3.fromRGB(0,255,255) },
            -- new palettes
            CustomPalette7  = { Color3.fromRGB(255,255,255),Color3.fromRGB(200,200,200),Color3.fromRGB(150,150,150),Color3.fromRGB(100,100,100) },
            CustomPalette8  = { Color3.fromRGB(255,20,147), Color3.fromRGB(186,85,211), Color3.fromRGB(72,61,139) },
            CustomPalette9  = { Color3.fromRGB(0,255,255),  Color3.fromRGB(173,216,230),Color3.fromRGB(25,25,112) },
            CustomPalette10 = { Color3.fromRGB(255,215,0),  Color3.fromRGB(255,165,0),  Color3.fromRGB(255,69,0) },
            CustomPalette11 = { Color3.fromRGB(124,252,0),  Color3.fromRGB(50,205,50),  Color3.fromRGB(0,128,0) },
            CustomPalette12 = { Color3.fromRGB(0,0,0),      Color3.fromRGB(45,0,80),    Color3.fromRGB(120,0,200), Color3.fromRGB(255,0,255) },
            CustomPalette13 = { Color3.fromRGB(0,0,128),    Color3.fromRGB(0,0,255),    Color3.fromRGB(0,191,255), Color3.fromRGB(135,206,250) },
            CustomPalette14 = { Color3.fromRGB(255,105,180),Color3.fromRGB(255,182,193),Color3.fromRGB(135,206,250) },
            CustomPalette15 = { Color3.fromRGB(240,255,255),Color3.fromRGB(176,224,230),Color3.fromRGB(135,206,235), Color3.fromRGB(70,130,180) },
            CustomPalette16 = { Color3.fromRGB(255,255,240),Color3.fromRGB(255,250,205),Color3.fromRGB(250,250,210), Color3.fromRGB(238,232,170) },
        }

        local function get_color_at(frac, time)
            local style = hat.style
            if style == "Rainbow" then
                return rainbow_color(frac, time)
            elseif style == "Astolfo" then
                return astolfo_color(frac, time)
            elseif palettes[style] ~= nil then
                return palette_color(palettes[style], frac, time, 0.2)
            else
                return custom_gradient(frac, time)
            end
        end

        local function update_hat()
            if not hat.enabled then
                cleanup_hat()
                return
            end
            local target = targeting_state and targeting_state.current
            local char = (target and target.Character) or nil
            local head = char and char:FindFirstChild("Head")
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            if not (char and head and hum and hum.Health > 0) then
                cleanup_hat()
                return
            end
            ensure_drawings()

            local cam = workspace.CurrentCamera
            local timeNow = tick()
            local tau = math.pi * 2
            local pos = head.Position + Vector3.new(0, 0.75, 0)
            local topWorld = pos + Vector3.new(0, hat.height, 0)

            -- offscreen/behind camera: just hide this frame to avoid artifacts
            local head2d, onScreen = cam:WorldToViewportPoint(head.Position)
            if (not onScreen) or head2d.Z <= 0 then
                set_visible_all(false)
                return
            end

            for i = 1, hat.sides do
                local line, tri = hat.drawings[i][1], hat.drawings[i][2]
                local last = (i / hat.sides)
                local nextf = ((i % hat.sides) + 1) / hat.sides
                local angA = last * tau
                local angB = nextf * tau
                local lastWorld = pos + Vector3.new(math.cos(angA), 0, math.sin(angA)) * hat.radius
                local nextWorld = pos + Vector3.new(math.cos(angB), 0, math.sin(angB)) * hat.radius

                local a2d = cam:WorldToViewportPoint(lastWorld)
                local b2d = cam:WorldToViewportPoint(nextWorld)
                local t2d = cam:WorldToViewportPoint(topWorld)

                local col = get_color_at(last, timeNow)

                line.From = Vector2.new(a2d.X, a2d.Y)
                line.To = Vector2.new(b2d.X, b2d.Y)
                line.Color = col
                line.Transparency = hat.line_trs
                line.Visible = true

                tri.PointA = Vector2.new(t2d.X, t2d.Y)
                tri.PointB = line.From
                tri.PointC = line.To
                tri.Color = col
                tri.Transparency = hat.hat_trs
                tri.Visible = true
            end
        end

        -- UI
        local hat_toggle = VisSec:toggle({
            name = "Target ChinaHat",
            flag = "china_hat",
            default = false,
            callback = function(state)
                hat.enabled = state
                if state then
                    update_hat()
                else
                    cleanup_hat()
                end
            end
        })

        hat_toggle:colorpicker({ name = "Color 1", flag = "hat_c1", default = hat.c1, callback = function(c) hat.c1 = c end })
        hat_toggle:colorpicker({ name = "Color 2", flag = "hat_c2", default = hat.c2, callback = function(c) hat.c2 = c end })
        hat_toggle:colorpicker({ name = "Color 3", flag = "hat_c3", default = hat.c3, callback = function(c) hat.c3 = c end })
        hat_toggle:colorpicker({ name = "Color 4", flag = "hat_c4", default = hat.c4, callback = function(c) hat.c4 = c end })

        local hat_dep = VisSec:dependency_box()
        hat_dep:setup_dependencies({ { hat_toggle, true } })
        local hat_style = hat_dep:dropdown({
            name = "Style",
            flag = "hat_style",
            items = { "Custom", "Rainbow", "Astolfo",
                "CustomPalette1", "CustomPalette2", "CustomPalette3", "CustomPalette4", "CustomPalette5", "CustomPalette6",
                "CustomPalette7", "CustomPalette8", "CustomPalette9", "CustomPalette10", "CustomPalette11", "CustomPalette12",
                "CustomPalette13", "CustomPalette14", "CustomPalette15", "CustomPalette16" },
            default = "Custom",
            callback = function(val) hat.style = val end
        })

        table.insert(library.connections, vars.run.RenderStepped:Connect(function()
            if hat.enabled then update_hat() end
        end))

        -- cleanup on target cleared and hide during transition
        utility:OnTargetUpdate(function(info)
            if not info then
                cleanup_hat()
            end
        end)
    end
    -- ChinaHat system end

    -- TargetESP system start
    do
        -- state
        local targetesp_state = {
            enabled = false,
            color = hex("#ffffff"),
            size = 1.0,
            speed = 1.0,
            bill = nil,
            img = nil,
            angle = 0,
            conn = nil,
            last_tick = os.clock(),
            asset_items = nil, -- cached dropdown items
            asset_map = nil,   -- name -> asset path
        }

        -- utils
        local function as_asset(path)
            if getcustomasset then return getcustomasset(path) end
            if getsynasset then return getsynasset(path) end
            return path
        end

        -- scan assets folder and prepare dropdown items and name->path map
        local function scan_assets()
            local dir = (library and library.directory or "Rebuild.gg") .. "/assets"
            local items, map = {}, {}
            local ok, files = pcall(function()
                return listfiles and listfiles(dir) or {}
            end)
            if ok and files and #files > 0 then
                table.sort(files)
                for _, f in ipairs(files) do
                    local lower = string.lower(f)
                    if lower:sub(-4) == ".png" or lower:sub(-4) == ".jpg" or lower:sub(-5) == ".jpeg" then
                        local name = f:match("([^/\\]+)$") or f
                        table.insert(items, name)
                        map[name] = as_asset(f)
                    end
                end
            end
            targetesp_state.asset_items = items
            targetesp_state.asset_map = map
            return items, map
        end

        local function set_image_by_name(name)
            if not name or name == "" then return end
            local map = targetesp_state.asset_map or select(2, scan_assets())
            local path = map and map[name]
            if targetesp_state.img then
                targetesp_state.img.Image = path or targetesp_state.img.Image or ""
            end
        end

        local function pick_asset_image()
            local dir = (library and library.directory or "Rebuild.gg") .. "/assets"
            local ok, files = pcall(function()
                return listfiles and listfiles(dir) or {}
            end)
            if not ok or not files or #files == 0 then return nil end
            table.sort(files)
            for _, f in ipairs(files) do
                local lower = string.lower(f)
                if lower:sub(-4) == ".png" or lower:sub(-4) == ".jpg" or lower:sub(-5) == ".jpeg" then
                    return as_asset(f)
                end
            end
            return as_asset(files[1])
        end

        local function ensure_gui()
            if targetesp_state.bill then return end
            local bill = Instance.new("BillboardGui")
            bill.Name = "RB_TargetESP"
            bill.AlwaysOnTop = true
            bill.LightInfluence = 0
            bill.Size = UDim2.new(targetesp_state.size, 0, targetesp_state.size, 0)
            bill.Enabled = true

            local img = Instance.new("ImageLabel")
            img.Name = "CrosshairImage"
            img.BackgroundTransparency = 1
            img.Size = UDim2.new(1, 0, 1, 0)
            img.Position = UDim2.fromScale(0, 0)
            -- prefer selected dropdown item; fallback to first asset; fallback to auto-pick
            if not targetesp_state.asset_items or not targetesp_state.asset_map then
                scan_assets()
            end
            local selected_name = (flags and flags["target_esp_image"]) or (targetesp_state.asset_items and targetesp_state.asset_items[1])
            img.Image = (selected_name and targetesp_state.asset_map and targetesp_state.asset_map[selected_name]) or (pick_asset_image() or "")
            img.ImageColor3 = targetesp_state.color
            img.Parent = bill

            targetesp_state.bill = bill
            targetesp_state.img = img
        end

        local function destroy_gui()
            if targetesp_state.bill then pcall(function() targetesp_state.bill:Destroy() end) end
            targetesp_state.bill = nil
            targetesp_state.img = nil
        end

        local function get_target_part()
            local player = targeting_state and targeting_state.current
            if not player or not player.Character then return nil end
            local char = player.Character
            local selected = flags and flags["aimbot_part"]
            if selected and char:FindFirstChild(selected) then
                return char[selected]
            end
            return utility:GetPreferredPart(char)
        end

        local function update_gui()
            if not targetesp_state.enabled then return end
            ensure_gui()

            local part = get_target_part()
            if not part then
                if targetesp_state.bill then targetesp_state.bill.Parent = nil end
                return
            end

            -- parent & adornee
            targetesp_state.bill.Adornee = part
            targetesp_state.bill.Parent = part

            -- distance scale
            local cam = (vars and vars.cam) or workspace.CurrentCamera
            local dist = (cam.CFrame.Position - part.Position).Magnitude
            local scale = math.clamp(dist / 30, 0.8, 4)
            local final = (flags and (flags["target_esp_size"])) or targetesp_state.size
            final = (final or 1) * scale
            targetesp_state.bill.Size = UDim2.new(final, 0, final, 0)

            -- rotation with delta time
            local now = os.clock()
            local dt = math.max(0, now - (targetesp_state.last_tick or now))
            targetesp_state.last_tick = now
            local spd = (flags and (flags["target_esp_speed"])) or targetesp_state.speed
            targetesp_state.angle = (targetesp_state.angle + (spd or 1) * 180 * dt) % 360
            if targetesp_state.img then
                targetesp_state.img.Rotation = targetesp_state.angle
                local color = (flags and flags["target_esp_color"]) or targetesp_state.color
                if type(color) == "table" then
                    -- Handle different color formats
                    if color.R and color.G and color.B then
                        -- Color3 format with uppercase
                        targetesp_state.img.ImageColor3 = Color3.new(color.R, color.G, color.B)
                    elseif color.r and color.g and color.b then
                        -- Color3 format with lowercase
                        targetesp_state.img.ImageColor3 = Color3.new(color.r, color.g, color.b)
                    else
                        -- Fallback to white if format unknown
                        targetesp_state.img.ImageColor3 = Color3.new(1, 1, 1)
                    end
                else
                    -- Already a Color3 object
                    targetesp_state.img.ImageColor3 = color
                end
            end
        end

        -- UI
        local tesp_toggle = VisSec:toggle({
            name = "Target Esp",
            flag = "target_esp",
            default = false,
            callback = function(state)
                targetesp_state.enabled = state
                if state then
                    ensure_gui()
                    if not targetesp_state.conn then
                        targetesp_state.conn = vars.run.RenderStepped:Connect(update_gui)
                        table.insert(library.connections, targetesp_state.conn)
                    end
                else
                    if targetesp_state.conn then
                        pcall(function() targetesp_state.conn:Disconnect() end)
                    end
                    targetesp_state.conn = nil
                    destroy_gui()
                end
            end,
        })
        tesp_toggle:colorpicker({
            name = "Color",
            flag = "target_esp_color",
            default = hex("#ffffff"),
            callback = function(color)
                targetesp_state.color = color
                if targetesp_state.img then targetesp_state.img.ImageColor3 = color end
            end,
        })

        local tesp_dep = VisSec:dependency_box()
        tesp_dep:setup_dependencies({ { tesp_toggle, true } })
        -- populate asset dropdown items once
        local items = (scan_assets())
        local default_item = (items and items[1]) or nil
        tesp_dep:dropdown({
            name = "Image",
            flag = "target_esp_image",
            items = items or {},
            default = default_item,
            callback = function(name)
                set_image_by_name(name)
            end
        })
        tesp_dep:slider({
            name = "Size",
            flag = "target_esp_size",
            min = 0.1,
            max = 40,
            default = 1,
            interval = 0.05,
            callback = function(v)
                targetesp_state.size = v
            end,
        })
        tesp_dep:slider({
            name = "Speed",
            flag = "target_esp_speed",
            min = 0.1,
            max = 10,
            default = 1,
            interval = 0.1,
            callback = function(v)
                targetesp_state.speed = v
            end,
        })

        -- cleanup on target cleared
        utility:OnTargetUpdate(function(info)
            if not info then
                destroy_gui()
            end
        end)

        -- cleanup on unload
        table.insert(library.connections, {
            Disconnect = function()
                if targetesp_state.conn then pcall(function() targetesp_state.conn:Disconnect() end) end
                targetesp_state.conn = nil
                destroy_gui()
            end
        })
    end
    -- TargetESP system end

    -- TargetTracer system
    do
        local tracer_state = {
            enabled = false,
            body_part = "HumanoidRootPart",
            origin = "mouse",
            line = nil,
            outline = nil,
            connection = nil,
            line_thickness = 2,
            outline_thickness = 4,
            line_color = Color3.fromRGB(255, 255, 255),
            outline_color = Color3.fromRGB(0, 0, 0)
        }
        
        local function cleanup_tracer()
            if tracer_state.line then
                pcall(function() tracer_state.line:Remove() end)
                tracer_state.line = nil
            end
            if tracer_state.outline then
                pcall(function() tracer_state.outline:Remove() end)
                tracer_state.outline = nil
            end
            if tracer_state.connection then
                tracer_state.connection:Disconnect()
                tracer_state.connection = nil
            end
        end
        
        local function create_tracer()
            if not tracer_state.enabled then
                cleanup_tracer()
                return
            end
            
            if not tracer_state.outline then
                tracer_state.outline = Drawing.new("Line")
                tracer_state.outline.Visible = false
                tracer_state.outline.Color = tracer_state.outline_color
                tracer_state.outline.Thickness = tracer_state.outline_thickness
            end
            
            if not tracer_state.line then
                tracer_state.line = Drawing.new("Line")
                tracer_state.line.Visible = false
                tracer_state.line.Color = tracer_state.line_color
                tracer_state.line.Thickness = tracer_state.line_thickness
            end
            
            if not tracer_state.connection then
                local RS = (vars and vars.run) or game:GetService("RunService")
                local UIS = (vars and vars.uis) or game:GetService("UserInputService")
                local Camera = (workspace and workspace.CurrentCamera) or game:GetService("Workspace").CurrentCamera
                
                tracer_state.connection = RS.RenderStepped:Connect(function()
                    if not tracer_state.enabled or not targeting_state.current then
                        if tracer_state.line then tracer_state.line.Visible = false end
                        if tracer_state.outline then tracer_state.outline.Visible = false end
                        if tracer_state.beam_line then tracer_state.beam_line.Enabled = false end
                        if tracer_state.beam_outline then tracer_state.beam_outline.Enabled = false end
                        return
                    end
                    
                    local target = targeting_state.current
                    local char = target and target.Character
                    if not char then
                        if tracer_state.line then tracer_state.line.Visible = false end
                        if tracer_state.outline then tracer_state.outline.Visible = false end
                        return
                    end
                    
                    local part = char:FindFirstChild(tracer_state.body_part)
                    if not part then
                        if tracer_state.line then tracer_state.line.Visible = false end
                        if tracer_state.outline then tracer_state.outline.Visible = false end
                        return
                    end
                    
                    -- 3D style removed

                    local screen_pos, on_screen = Camera:WorldToViewportPoint(part.Position)
                    if not on_screen then
                        if tracer_state.line then tracer_state.line.Visible = false end
                        if tracer_state.outline then tracer_state.outline.Visible = false end
                        -- also hide 3D if exists
                        if tracer_state.beam_line then tracer_state.beam_line.Enabled = false end
                        if tracer_state.beam_outline then tracer_state.beam_outline.Enabled = false end
                        return
                    end
                    
                    local end_pos = Vector2.new(screen_pos.X, screen_pos.Y)
                    local start_pos
                    
                    if tracer_state.origin == "mouse" then
                        start_pos = UIS:GetMouseLocation()
                    elseif tracer_state.origin == "top" then
                        start_pos = Vector2.new(Camera.ViewportSize.X / 2, 0)
                    elseif tracer_state.origin == "bottom" then
                        start_pos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                    elseif tracer_state.origin == "center" then
                        start_pos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                    end
                    
                    if tracer_state.outline then
                        tracer_state.outline.From = start_pos
                        tracer_state.outline.To = end_pos
                        tracer_state.outline.Visible = true
                        tracer_state.outline.Thickness = tracer_state.outline_thickness
                    end
                    
                    if tracer_state.line then
                        tracer_state.line.From = start_pos
                        tracer_state.line.To = end_pos
                        tracer_state.line.Visible = true
                        tracer_state.line.Thickness = tracer_state.line_thickness
                        tracer_state.line.Color = tracer_state.line_color
                    end
                end)
            end
        end
        
        -- UI elements
        local tt_toggle = VisSec:toggle({
            name = "Target Tracer",
            flag = "target_tracer",
            default = false,
            callback = function(state)
                tracer_state.enabled = state
                if state then
                    create_tracer()
                else
                    cleanup_tracer()
                end
            end
        })
        
        -- colorpickers attached to toggle (CustomUI style)
        tt_toggle:colorpicker({
            name = "Outline",
            flag = "tt_out",
            default = Color3.fromRGB(0, 0, 0),
            callback = function(color)
                tracer_state.outline_color = color
                if tracer_state.outline then
                    tracer_state.outline.Color = color
                end
            end
        })
        tt_toggle:colorpicker({
            name = "Fill",
            flag = "tt_fill",
            default = Color3.fromRGB(255, 255, 255),
            callback = function(color)
                tracer_state.line_color = color
                if tracer_state.line then
                    tracer_state.line.Color = color
                end
            end
        })

        -- dependency box для остальных настроек
        local tt_dep = VisSec:dependency_box()
        tt_dep:setup_dependencies({ { tt_toggle, true } })
        
        -- dropdowns
        tt_dep:dropdown({
            name = "Part",
            flag = "tt_part",
            items = {
                "HumanoidRootPart", "Head", "UpperTorso", "LowerTorso",
                "LeftUpperArm", "LeftLowerArm", "LeftHand",
                "RightUpperArm", "RightLowerArm", "RightHand",
                "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
                "RightUpperLeg", "RightLowerLeg", "RightFoot"
            },
            default = "HumanoidRootPart",
            callback = function(value)
                tracer_state.body_part = value
            end
        })
        
        tt_dep:dropdown({
            name = "Origin",
            flag = "tt_origin",
            items = { "mouse", "top", "bottom", "center" },
            default = "mouse",
            callback = function(value)
                tracer_state.origin = value
            end
        })
        
        -- hide tracer on target cleared (don't destroy, just hide)
        utility:OnTargetUpdate(function(info)
            if not info then
                -- только скрываем, не удаляем полностью
                if tracer_state.line then tracer_state.line.Visible = false end
                if tracer_state.outline then tracer_state.outline.Visible = false end
                if tracer_state.beam_line then tracer_state.beam_line.Enabled = false end
                if tracer_state.beam_outline then tracer_state.beam_outline.Enabled = false end
            end
        end)

        -- cleanup on unload
        table.insert(library.connections, {
            Disconnect = function()
                cleanup_tracer()
            end
        })
    end

  -- nuker runtime: continuously picks closest to mouse, no FOV, no keybind
  do
      local RunService = game:GetService("RunService")
      local Players = game:GetService("Players")
      local LocalPlayer = Players.LocalPlayer
      local Camera = workspace.CurrentCamera
      local UIS = game:GetService("UserInputService")

      local function get_preferred_part(char)
          return char and (char:FindFirstChild("HumanoidRootPart")
              or char:FindFirstChild("Head")
              or char:FindFirstChild("UpperTorso")
              or char:FindFirstChild("Torso"))
      end

      local conn = RunService.RenderStepped:Connect(function()
          if not flags then return end
          if not flags["Targeting_Enabled"] then return end
          if flags["Targeting_Mode"] ~= "Nuker" then return end

          local mouse = UIS:GetMouseLocation()
          local best_player, best_dist
          best_dist = math.huge

          for _, plr in ipairs(Players:GetPlayers()) do
              if plr ~= LocalPlayer then
                  local char = plr.Character
                  local part = get_preferred_part(char)
                  if part then
                      local screen, on_screen = Camera:WorldToViewportPoint(part.Position)
                      if on_screen then
                          local d = (mouse - Vector2.new(screen.X, screen.Y)).Magnitude
                          if d < best_dist then
                              best_dist = d
                              best_player = plr
                          end
                      end
                  end
              end
          end

          targeting_state.current = best_player
          -- visuals sync for Nuker (только при смене персонажа)
          if best_player then
              if flags and flags["target_highlight"] then
                  local char = best_player.Character
                  if char and (hl_state.last_char ~= char) then
                      apply_highlight(char)
                  end
              end
          else
              -- no target -> clear highlight если был активен
              if hl_state and hl_state.hl then
                  clear_highlight()
              end
          end
      end)
      table.insert(library.connections, conn)
  end
end
-- targeting system end

-- aimbot/prediction/resolver UI start
do
    -- create a single column on Rage and place multi-sections inside
    local RageCol = Aimbot:column()
    local AimSec, PredSec, ResSec = RageCol:multi_section({ names = { "Aimbot", "Prediction", "Resolver" } })
    -- Tweaks/OnDamage multi-section in the same column
    local Tweaks, OnDamage = RageCol:multi_section({ names = { "Tweaks", "OnDamage" } })
    
    -- Tweaks: AutoAir toggle
    do
        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local last_fire, cooldown = 0, 0.2
        local autoair_conn

        local function disconnect_autoair()
            if autoair_conn then
                autoair_conn:Disconnect()
                autoair_conn = nil
            end
        end

        local function connect_autoair()
            if autoair_conn then return end
            autoair_conn = RunService.RenderStepped:Connect(function()
                -- lightweight early guards
                if not (flags and flags["aimbot_enabled"]) then return end
                local target = targeting_state and targeting_state.current
                if not (target and target.Character) then return end
                local hrp = target.Character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end

                local character = LocalPlayer.Character
                if not character then return end
                local head = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
                if not head then return end

                -- raycast LOS from local head to target hrp
                local origin = head.Position
                local direction = hrp.Position - origin
                if direction.Magnitude <= 0 then return end
                local params = RaycastParams.new()
                params.FilterType = Enum.RaycastFilterType.Blacklist
                params.FilterDescendantsInstances = { character, target.Character }
                local result = workspace:Raycast(origin, direction, params)
                if result then return end -- obstructed

                -- velocity check
                local vel = hrp.AssemblyLinearVelocity or hrp.Velocity or Vector3.zero
                if vel.Y <= 15 then return end

                -- cooldown and fire
                local now = tick()
                if (now - last_fire) < cooldown then return end
                last_fire = now
                local tool = character:FindFirstChildOfClass("Tool")
                if tool then pcall(function() tool:Activate() end) end
            end)
            table.insert(library.connections, autoair_conn)
        end

        Tweaks:toggle({
            name = "AutoAir",
            flag = "autoair_enabled",
            default = false,
            callback = function(on)
                if on then connect_autoair() else disconnect_autoair() end
            end,
        })
    end
    
    -- Tweaks: AutoReload toggle
    do
        -- aimbot system start
        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local LocalPlayer = Players.LocalPlayer
        local last_reload, cooldown = 0, 1 -- 1s debounce similar to wait(1)
        local autoreload_conn

        local function disconnect_autoreload()
            if autoreload_conn then
                autoreload_conn:Disconnect()
                autoreload_conn = nil
            end
        end

        local function connect_autoreload()
            if autoreload_conn then return end
            autoreload_conn = RunService.Heartbeat:Connect(function()
                -- lightweight guards
                local char = LocalPlayer and LocalPlayer.Character
                if not char then return end
                local tool = char:FindFirstChildOfClass("Tool")
                if not tool then return end
                local ammo = tool:FindFirstChild("Ammo")
                if not ammo then return end
                local value = tonumber(ammo.Value)
                if not value then return end
                if value > 0 then return end

                local now = tick()
                if (now - last_reload) < cooldown then return end
                last_reload = now

                pcall(function()
                    ReplicatedStorage.MainEvent:FireServer("Reload", tool)
                end)
            end)
            table.insert(library.connections, autoreload_conn)
        end

        Tweaks:toggle({
            name = "AutoReload",
            flag = "autoreload_enabled",
            default = false,
            callback = function(on)
                if on then connect_autoreload() else disconnect_autoreload() end
            end,
        })
    end
    
    -- Tweaks: LookAtTarget toggle
    do
        local lookat_conn
        
        local function disconnect_lookat()
            if lookat_conn then
                lookat_conn:Disconnect()
                lookat_conn = nil
            end
        end
        
        local function connect_lookat()
            if lookat_conn then return end
            lookat_conn = vars.run.RenderStepped:Connect(function()
                -- guards
                local target = targeting_state and targeting_state.current
                if not (target and utility:ValidateClient(target)) then return end
                
                local lchar = lp and lp.Character
                if not lchar then return end
                local lroot = lchar:FindFirstChild("HumanoidRootPart")
                if not lroot then return end
                
                local part = utility:GetPreferredPart(target.Character)
                if not part then return end
                
                local local_pos = lroot.Position
                local dir = part.Position - local_pos
                dir = vars.v3.new(dir.X, 0, dir.Z) -- yaw only
                local mag = dir.Magnitude
                if mag < 1e-6 then return end
                
                local aim_dir = dir.Unit
                lroot.CFrame = vars.cf.new(local_pos, local_pos + aim_dir)
            end)
            table.insert(library.connections, lookat_conn)
        end
        
        Tweaks:toggle({
            name = "LookAtTarget",
            flag = "lookat_enabled",
            default = false,
            callback = function(on)
                if on then connect_lookat() else disconnect_lookat() end
            end,
        })
    end
    
    -- Tweaks: ForceReload (press R -> change loadout to knife slot3)
    do
        local UserInputService = game:GetService("UserInputService")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local forcere_conn, forcere_auto_conn
        local last_fire, cooldown = 0, 0.15 -- key repeat debounce
        local last_auto, auto_cd = 0, 1 -- auto debounce similar to AutoReload

        -- helper: async auto-equip with short retry window (handles post-ChangeLoadout latency)
        local function equip_revolver_async()
            local lp = LocalPlayer
            if not lp then return end
            local tries, maxTries = 0, 60 -- ~2.0s on Heartbeat
            local conn
            conn = RunService.Heartbeat:Connect(function()
                tries = tries + 1
                -- stop if parent toggles are off
                if not (flags and flags["forcereload_enabled"] and flags["forcereload_autoequip"]) then
                    if conn then conn:Disconnect() end
                    return
                end

                local char = lp.Character
                if not char then
                    if tries >= maxTries and conn then conn:Disconnect() end
                    return
                end
                local hum = char:FindFirstChildOfClass("Humanoid")
                local bp = lp:FindFirstChildOfClass("Backpack") or lp:FindFirstChild("Backpack")
                local function get_tool(container)
                    if not container then return nil end
                    local t = container:FindFirstChild("[Revolver]")
                    if t and t:IsA("Tool") and t:FindFirstChild("Handle") then return t end
                    return nil
                end

                -- prefer tool already in character: just EquipTool to make it active
                local tool_in_char = get_tool(char)
                if tool_in_char then
                    if hum then pcall(function() hum:EquipTool(tool_in_char) end) end
                    if conn then conn:Disconnect() end
                    return
                end

                -- otherwise move from backpack to character and equip
                local tool_in_bp = get_tool(bp)
                if tool_in_bp then
                    pcall(function() tool_in_bp.Parent = char end)
                    if hum then pcall(function() hum:EquipTool(tool_in_bp) end) end
                    if conn then conn:Disconnect() end
                    return
                end

                if tries >= maxTries then
                    if conn then conn:Disconnect() end
                    return
                end
            end)
            table.insert(library.connections, conn)
        end

        local function disconnect_forcereload()
            if forcere_conn then
                forcere_conn:Disconnect()
                forcere_conn = nil
            end
        end

        local function connect_forcereload()
            if forcere_conn then return end
            forcere_conn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if gameProcessed then return end
                if input.UserInputType ~= Enum.UserInputType.Keyboard then return end
                if input.KeyCode ~= Enum.KeyCode.R then return end
                if UserInputService:GetFocusedTextBox() then return end
                local now = tick()
                if (now - last_fire) < cooldown then return end
                last_fire = now

                local args = { "ChangeLoadout", "[Knife]", "Slot3" }
                pcall(function()
                    ReplicatedStorage:WaitForChild("MainEvent"):FireServer(unpack(args))
                end)
            end)
            table.insert(library.connections, forcere_conn)
        end

        local function disconnect_forcereload_auto()
            if forcere_auto_conn then
                forcere_auto_conn:Disconnect()
                forcere_auto_conn = nil
            end
        end

        local function connect_forcereload_auto()
            if forcere_auto_conn then return end
            forcere_auto_conn = RunService.Heartbeat:Connect(function()
                -- require main toggle enabled
                if not (flags and flags["forcereload_enabled"]) then return end

                local char = LocalPlayer and LocalPlayer.Character
                if not char then return end
                local tool = char:FindFirstChildOfClass("Tool")
                if not tool then return end
                local ammo = tool:FindFirstChild("Ammo")
                if not ammo then return end
                local value = tonumber(ammo.Value)
                if not value or value > 0 then return end

                local now = tick()
                if (now - last_auto) < auto_cd then return end
                last_auto = now

                local args = { "ChangeLoadout", "[Knife]", "Slot3" }
                pcall(function()
                    ReplicatedStorage:WaitForChild("MainEvent"):FireServer(unpack(args))
                end)
                -- optionally auto-equip revolver back (with retries)
                if flags and flags["forcereload_autoequip"] then
                    equip_revolver_async()
                end
            end)
            table.insert(library.connections, forcere_auto_conn)
        end

        local function disconnect_forcereload_autoequip()
            if forcere_autoequip_conn then
                forcere_autoequip_conn:Disconnect()
                forcere_autoequip_conn = nil
            end
        end

        local function connect_forcereload_autoequip()
            if forcere_autoequip_conn then return end
            forcere_autoequip_conn = RunService.Heartbeat:Connect(function()
                -- both parent and autoequip must be enabled (AutoEquip UI зависит от Auto)
                if not (flags and flags["forcereload_enabled"] and flags["forcereload_autoequip"]) then return end
                local lp = LocalPlayer
                if not lp then return end
                local char = lp.Character
                if not char then return end
                local hum = char:FindFirstChildOfClass("Humanoid")
                if not hum then return end

                -- throttle attempts
                local now = os.clock()
                if (now - (last_equip_try or 0)) < 0.2 then return end
                last_equip_try = now

                local rev_in_char = char:FindFirstChild("[Revolver]")
                if rev_in_char then
                    -- ensure equipped explicitly
                    pcall(function() hum:EquipTool(rev_in_char) end)
                else
                    -- not in character, try async equip from backpack
                    equip_revolver_async()
                end
            end)
            table.insert(library.connections, forcere_autoequip_conn)
        end

        local fr_toggle = Tweaks:toggle({
            name = "ForceReload",
            flag = "forcereload_enabled",
            default = false,
            callback = function(on)
                if on then
                    connect_forcereload()
                    if flags and flags["forcereload_auto"] then
                        connect_forcereload_auto()
                    end
                    if flags and flags["forcereload_autoequip"] then
                        connect_forcereload_autoequip()
                    end
                else
                    disconnect_forcereload()
                    disconnect_forcereload_auto()
                    disconnect_forcereload_autoequip()
                    -- ensure dependent toggle state is reset when parent is disabled
                    if flags then
                        flags["forcereload_auto"] = false
                        flags["forcereload_autoequip"] = false
                    end
                end
            end,
        })

        local fr_dep = Tweaks:dependency_box()
        fr_dep:setup_dependencies({ { fr_toggle, true } })
        local auto_toggle = fr_dep:toggle({
            name = "Auto",
            flag = "forcereload_auto",
            default = false,
            callback = function(on)
                if on then
                    if flags and flags["forcereload_enabled"] then
                        connect_forcereload_auto()
                    end
                else
                    disconnect_forcereload_auto()
                end
            end,
        })

        -- nested dependency: visible only when both ForceReload and Auto are enabled
        local auto_dep = Tweaks:dependency_box()
        auto_dep:setup_dependencies({ { fr_toggle, true }, { auto_toggle, true } })
        auto_dep:toggle({
            name = "AutoEquip",
            flag = "forcereload_autoequip",
            default = false,
            callback = function(on)
                if flags and flags["forcereload_enabled"] and on then
                    connect_forcereload_autoequip()
                else
                    disconnect_forcereload_autoequip()
                end
            end,
        })
    end

    -- Tweaks: MagicBullets
    do
        -- cache frequently used
        local RunService = vars.run
        local Players = vars.ps
        local LocalPlayer = Players.LocalPlayer
        local ReplicatedStorage = game:GetService("ReplicatedStorage")

        -- state
        local mb_conn
        local last_shot = 0
        local COOLDOWN = 0.00000000001 -- seconds

        -- helpers
        local function is_player_ko(player)
            local char = player and player.Character
            local be = char and char:FindFirstChild("BodyEffects")
            local ko = be and be:FindFirstChild("K.O")
            return (ko and ko.Value) and true or false
        end

        local function has_forcefield(player)
            local char = player and player.Character
            return (char and char:FindFirstChildOfClass("ForceField")) and true or false
        end

        local function get_current_tool()
            local char = LocalPlayer and LocalPlayer.Character
            if not char then return nil end
            for _, inst in ipairs(char:GetChildren()) do
                if inst:IsA("Tool") then return inst end
            end
            return nil
        end

        local function shoot_at_player(player)
            if not (player and player.Character) then return end
            -- cooldown
            local now = os.clock()
            if (now - (last_shot or 0)) < COOLDOWN then return end

            -- ammo/tool checks
            local tool = get_current_tool()
            if not tool then return end
            local ammo = tool:FindFirstChild("Ammo")
            if ammo and ammo.Value and ammo.Value <= 0 then return end
            local handle = tool:FindFirstChild("Handle")
            if not handle then return end

            local head = player.Character:FindFirstChild("Head")
            if not head then return end
            local head_pos = head.Position

            local pts = { head_pos, head_pos, head_pos, head_pos, head_pos }
            local norms = { Vector3.new(0,1,0), Vector3.new(0,1,0), Vector3.new(0,1,0), Vector3.new(0,1,0), Vector3.new(0,1,0) }
            local parts = { head, head, head, head, head }

            local args = {
                "ShootGun",
                handle,
                head_pos,
                pts,
                parts,
                norms,
                {},
                os.clock(),
                math.huge,
                pts,
                5,
                0.2,
                head_pos,
            }

            local evt = ReplicatedStorage:FindFirstChild("ShootEvent")
            if evt then
                last_shot = now
                pcall(function()
                    evt:FireServer(unpack(args))
                end)
            end
        end

        local function disconnect_magicbullets()
            if mb_conn then mb_conn:Disconnect() mb_conn = nil end
        end

        local function connect_magicbullets()
            if mb_conn then return end
            mb_conn = RunService.Heartbeat:Connect(function()
                if not (flags and flags["magicbullets_enabled"]) then return end
                local target = targeting_state and targeting_state.current
                if not target then return end
                -- optional checks controlled by UI (multi-dropdown)
                local selected = flags and flags["magicbullets_checks"]
                local checkKO, checkFF = false, false
                if typeof(selected) == "table" then
                    for _, v in ipairs(selected) do
                        if v == "KO" then checkKO = true end
                        if v == "FF" then checkFF = true end
                    end
                end
                if checkKO and is_player_ko(target) then return end
                if checkFF and has_forcefield(target) then return end
                shoot_at_player(target)
            end)
            table.insert(library.connections, mb_conn)
        end

        local mb_toggle = Tweaks:toggle({
            name = "MagicBullets",
            flag = "magicbullets_enabled",
            default = false,
            callback = function(on)
                if on then connect_magicbullets() else disconnect_magicbullets() end
            end
        })

        local mb_dep = Tweaks:dependency_box()
        mb_dep:setup_dependencies({ { mb_toggle, true } })
        mb_dep:label({ name = "Checks" })
        mb_dep:dropdown({
            name = "Checks",
            flag = "magicbullets_checks",
            items = {"KO", "FF"},
            default = {"KO", "FF"},
            multi = true,
            callback = function() end
        })
    end
    
    -- ondamage system start
    do
        -- collect sounds from library directory
        local function get_sound_files()
            local items = {}
            local dir = (library and library.directory or "Rebuild.gg") .. "/sounds"
            local ok, files = pcall(function()
                return listfiles and listfiles(dir) or {}
            end)
            if ok and type(files) == "table" then
                for _, path in ipairs(files) do
                    -- get filename only
                    local name = path:match("[^/\\]+$")
                    if name then table.insert(items, name) end
                end
            end
            table.sort(items)
            return (#items > 0) and items or { "ding.ogg", "bell.wav", "hit.mp3" }
        end

        -- play helper (global for external call sites)
        function play_hitsound(file)
            local SoundService = game:GetService("SoundService")
            local sound = SoundService:FindFirstChild("RB_HitSound")
            if not sound then
                sound = Instance.new("Sound")
                sound.Name = "RB_HitSound"
                sound.Looped = false
                sound.Parent = SoundService
            end
            local base = (library and library.directory or "Rebuild.gg") .. "/sounds/" .. tostring(file or "")
            local asset
            if getcustomasset then
                asset = getcustomasset(base)
            elseif getsynasset then
                asset = getsynasset(base)
            end
            if asset then
                sound.SoundId = asset
                sound.Volume = tonumber(flags["hs_volume"]) or 0.5
                local pitch = tonumber(flags["hs_pitch"]) or 1
                sound.PlaybackSpeed = pitch
                pcall(function() sound:Play() end)
            end
        end

        -- UI: hitsound
        local hs_toggle = OnDamage:toggle({ name = "Sounds", flag = "hitsound_enabled", default = false })
        local hs_dep = OnDamage:dependency_box()
        hs_dep:setup_dependencies({ { hs_toggle, true } })
        local hs_dropdown = hs_dep:dropdown({ name = "Sound", flag = "hs_file", items = get_sound_files() })
        hs_dep:slider({ name = "Vol", flag = "hs_volume", min = 0, max = 10, default = 0.5, interval = 0.05 })
        hs_dep:slider({ name = "Pitch", flag = "hs_pitch", min = 0.5, max = 2, default = 1, interval = 0.05 })
        hs_dep:toggle({ name = "MuteOriginalSound", flag = "hs_mute_original", default = false })

        -- sound muting framework (targets common hit sounds) per-toggle
        local V = { Sound = {} }
        V.Sound.TargetIds = V.Sound.TargetIds or {
            "rbxassetid://6773912589",
            "6773912589",
            "http://www.roblox.com/asset/?id=6773912589",
        }

        function V.Sound.MuteTargetSound(sound)
            if not sound or not sound:IsA("Sound") then return false end
            local soundId = tostring(sound.SoundId or ""):lower()
            for _, targetId in pairs(V.Sound.TargetIds) do
                if soundId:find(tostring(targetId):lower(), 1, true) then
                    if flags and flags["hs_mute_original"] then
                        pcall(function()
                            sound:Stop()
                            sound.Volume = 0
                            sound.Playing = false
                        end)
                        -- guard future re-plays
                        if not V.Sound._guarded then V.Sound._guarded = {} end
                        if not V.Sound._guarded[sound] then
                            V.Sound._guarded[sound] = sound:GetPropertyChangedSignal("Playing"):Connect(function()
                                if flags and flags["hs_mute_original"] and sound.Playing then
                                    pcall(function()
                                        sound:Stop()
                                        sound.Volume = 0
                                    end)
                                end
                            end)
                        end
                        return true
                    end
                end
            end
            return false
        end

        function V.Sound.MuteExistingSounds()
            for _, obj in ipairs(game:GetDescendants()) do
                if obj:IsA("Sound") then
                    V.Sound.MuteTargetSound(obj)
                end
            end
        end

        -- initial sweep and live hook
        task.defer(function()
            V.Sound.MuteExistingSounds()
        end)
        if not V.Sound._conn then
            V.Sound._conn = game.DescendantAdded:Connect(function(obj)
                if obj:IsA("Sound") then
                    V.Sound.MuteTargetSound(obj)
                end
            end)
        end

        -- runtime bind moved to single subscription at end
    end
    -- ondamage system end

    -- notifications system start
    do
        -- UI: notifications
        local notif_toggle = OnDamage:toggle({ name = "Notifications", flag = "notif_enabled", default = false })
        local notif_dep = OnDamage:dependency_box()
        notif_dep:setup_dependencies({ { notif_toggle, true } })
        notif_dep:slider({ name = "Duration", flag = "notif_duration", min = 0.5, max = 3, default = 1.5, interval = 0.1 })

    end
    -- notifications system end

    -- single OnHit subscription for all features
    utility:OnHit(function(info)
        -- hitsounds
        if flags and flags["hitsound_enabled"] then
            local file = flags["hs_file"]
            if file and file ~= "" then
                play_hitsound(file)
            end
        end
        
        -- hitchams (moved here to work properly)
        if flags and flags["hitchams_enabled"] and info and info.player then
            HitChams(info.player)
        end
        
        -- notifications
        local f = flags or (library and library.flags) or {}
        local enabled = (f["notif_enabled"] == true) or (f["notif_enabled"] == 1) or (f["notif_enabled"] == "true")
        if not enabled then return end
        
        -- enrich info
        if info and info.player and info.player.Character then
            local char = info.player.Character
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid then
                info.health = humanoid.Health
                info.remaining_health = humanoid.Health
            end
        end
        
        -- simple text: "Name HP"
        local name = "Player"
        if info then
            if info.player then
                if typeof(info.player) == "Instance" then
                    name = info.player.Name or "Player"
                else
                    name = tostring(info.player)
                end
            elseif info.name then
                name = tostring(info.name)
            end
        end
        local hp = 0
        if info and info.health then
            local hpn = tonumber(info.health)
            hp = hpn and math.floor(hpn) or 0
        end
        local text = tostring(name) .. " " .. tostring(hp)
        local duration = tonumber((f and f["notif_duration"]) or flags and flags["notif_duration"]) or 1.5
        if duration <= 0 or duration > 10 or duration ~= duration then duration = 1.5 end
        if library and library.notification then
            library:notification({ text = text, time = duration })
        end
    end)

    -- hitchams system start
    local HitChams -- forward declaration
    do
        HitChams = function(Player)
            if not flags["hitchams_enabled"] then return end

            if Player and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
                Player.Character.Archivable = true
                local Cloned = Player.Character:Clone()
                Cloned.Name = "Player Clone"

                local BodyParts = {
                    "Head", "UpperTorso", "LowerTorso",
                    "LeftUpperArm", "LeftLowerArm", "LeftHand",
                    "RightUpperArm", "RightLowerArm", "RightHand",
                    "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
                    "RightUpperLeg", "RightLowerLeg", "RightFoot"
                }

                for _, Part in ipairs(Cloned:GetChildren()) do
                    if Part:IsA("BasePart") then
                        local PartValid = false
                        for _, validPart in ipairs(BodyParts) do
                            if Part.Name == validPart then
                                PartValid = true
                                break
                            end
                        end
                        
                        if not PartValid then
                            Part:Destroy()
                        end
                    elseif Part:IsA("Accessory") or Part:IsA("Tool") or Part.Name == "face" or Part:IsA("Shirt") or Part:IsA("Pants") or Part:IsA("Hat") then
                        Part:Destroy()
                    end
                end

                if Cloned:FindFirstChild("Humanoid") then
                    Cloned.Humanoid:Destroy()
                end

                -- цвет из актуальных флагов UI без фолбэка
                local lib_flags = (library and library.flags) or {}
                local raw = (lib_flags["hitchams_color"] or lib_flags["hitcham_color"]) or nil
                local hitchams_color = raw and (raw.Color or raw) or nil
                
                for _, BodyPart in ipairs(Cloned:GetChildren()) do
                    if BodyPart:IsA("BasePart") then
                        BodyPart.CanCollide = false
                        BodyPart.Anchored = true
                        BodyPart.Transparency = flags["hitchams_transparency"] or 0.5
                        if hitchams_color then
                            BodyPart.Color = hitchams_color
                        end
                        BodyPart.Material = flags["hitchams_material"] or Enum.Material.Neon
                    end
                end

                if Cloned:FindFirstChild("Head") then
                    local Head = Cloned.Head
                    Head.Transparency = flags["hitchams_transparency"] or 0.5
                    if hitchams_color then
                        Head.Color = hitchams_color
                    end
                    Head.Material = flags["hitchams_material"] or Enum.Material.Neon

                    if Head:FindFirstChild("face") then
                        Head.face:Destroy()
                    end
                end

                Cloned.Parent = game.Workspace

                local tweenInfo = TweenInfo.new(
                    flags["hitchams_duration"] or 2,
                    Enum.EasingStyle.Sine,
                    Enum.EasingDirection.InOut,
                    0,
                    true
                )

                for _, BodyPart in ipairs(Cloned:GetChildren()) do
                    if BodyPart:IsA("BasePart") then
                        local tween = game:GetService("TweenService"):Create(BodyPart, tweenInfo, { Transparency = 1 })
                        tween:Play()
                    end
                end

                task.delay(flags["hitchams_duration"] or 2, function()
                    if Cloned and Cloned.Parent then
                        Cloned:Destroy()
                    end
                end)
            end
        end

        -- UI: HitChams
        local hitchams_toggle = OnDamage:toggle({ name = "Chams", flag = "hitchams_enabled", default = false })
        hitchams_toggle:colorpicker({ name = "Color", flag = "hitchams_color", default = Color3.fromRGB(255, 0, 0) })
        
        local hitchams_dep = OnDamage:dependency_box()
        hitchams_dep:setup_dependencies({ { hitchams_toggle, true } })
        hitchams_dep:dropdown({ 
            name = "Material", 
            flag = "hitchams_material", 
            items = { "Neon", "ForceField", "Glass", "Plastic", "Metal", "Concrete" },
            default = "Neon"
        })
        hitchams_dep:slider({ name = "Duration", flag = "hitchams_duration", min = 0.5, max = 5, default = 2, interval = 0.1 })
        hitchams_dep:slider({ name = "Trs", flag = "hitchams_transparency", min = 0, max = 1, default = 0.5, interval = 0.05 })

        -- HitChams is now integrated into main OnHit subscription above
    end
    -- hitchams system end
    
    -- hiteffects system start
    do
        local effect_types = {}
        local effect_folder = nil
        
        -- создаем папку для эффектов
        local function get_effects_folder()
            if not effect_folder or not effect_folder.Parent then
                effect_folder = workspace:FindFirstChild("RebuildHitEffects") or Instance.new("Folder")
                effect_folder.Name = "RebuildHitEffects"
                effect_folder.Parent = workspace
            end
            return effect_folder
        end
        
        -- инициализация эффектов
        local function init_effects()
            -- Coom
            local Cum = Instance.new("Attachment")
            local foam = Instance.new("ParticleEmitter")
            foam.Name = "Foam"
            foam.LightInfluence = 0.5
            foam.Lifetime = NumberRange.new(1, 1)
            foam.SpreadAngle = Vector2.new(360, -360)
            foam.VelocitySpread = 360
            foam.Speed = NumberRange.new(20, 20)
            foam.Brightness = 2.5
            foam.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.1, 0.65), NumberSequenceKeypoint.new(0.65, 1.42), NumberSequenceKeypoint.new(1, 0)})
            foam.Enabled = false
            foam.Acceleration = Vector3.new(0, -66, 0)
            foam.Rate = 100
            foam.Texture = "rbxassetid://8297030850"
            foam.Rotation = NumberRange.new(-90, -90)
            foam.Orientation = Enum.ParticleOrientation.VelocityParallel
            foam.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255)) -- белый цвет по умолчанию
            foam.Parent = Cum
            
            effect_types["Cum"] = Cum
            
            -- Particle
            local particle = Instance.new("Attachment")
            
            local dots1 = Instance.new("ParticleEmitter")
            dots1.Name = "Dots 1"
            dots1.LightEmission = 1
            dots1.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255)) -- белый цвет по умолчанию
            dots1.LockedToPart = false
            dots1.ZOffset = 10
            dots1.Texture = "rbxassetid://7216849075"
            dots1.VelocitySpread = 360
            dots1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0.663)})
            dots1.Lifetime = NumberRange.new(1, 5)
            dots1.Speed = NumberRange.new(1, 210)
            dots1.SpreadAngle = Vector2.new(360, -360)
            dots1.Rate = 60
            dots1.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.1), NumberSequenceKeypoint.new(0.428, 0), NumberSequenceKeypoint.new(1, 0.627)})
            dots1.Enabled = false
            dots1.Parent = particle
            
            local dots2 = Instance.new("ParticleEmitter")
            dots2.Name = "Dots 2"
            dots2.LightEmission = 1
            dots2.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255)) -- белый цвет по умолчанию
            dots2.LockedToPart = false
            dots2.ZOffset = 10
            dots2.Texture = "rbxassetid://7216849075"
            dots2.VelocitySpread = 360
            dots2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0.663)})
            dots2.Lifetime = NumberRange.new(1, 5)
            dots2.Speed = NumberRange.new(1, 210)
            dots2.SpreadAngle = Vector2.new(360, -360)
            dots2.Rate = 100
            dots2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.1), NumberSequenceKeypoint.new(0.502, 1.438), NumberSequenceKeypoint.new(0.925, 1.125), NumberSequenceKeypoint.new(1, 0.397)})
            dots2.Enabled = false
            dots2.Orientation = Enum.ParticleOrientation.FacingCamera
            dots2.Parent = particle
            
            effect_types["Particle"] = particle

            -- Break (ForceField-Break-01)
            local breakEff = Instance.new("Attachment")

            local break2 = Instance.new("ParticleEmitter")
            break2.Name = "Break2"
            break2.RotSpeed = NumberRange.new(1000)
            break2.VelocitySpread = -360
            break2.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255)) -- белый цвет по умолчанию
            break2.Rate = 1
            break2.Texture = "rbxassetid://11973936966"
            break2.Rotation = NumberRange.new(-360, 360)
            break2.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 1, 0),
                NumberSequenceKeypoint.new(0.10972569137811661, 0.27699530124664307, 0),
                NumberSequenceKeypoint.new(0.5, 0, 0),
                NumberSequenceKeypoint.new(1, 1, 0)
            })
            break2.Lifetime = NumberRange.new(0.5)
            break2.Speed = NumberRange.new(0.01)
            break2.LightEmission = 0.5
            break2.SpreadAngle = Vector2.new(-360, 360)
            break2.Size = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 6, 0),
                NumberSequenceKeypoint.new(1, 6, 0)
            })
            break2.Enabled = false
            break2.Parent = breakEff

            local break3 = Instance.new("ParticleEmitter")
            break3.Name = "Break3"
            break3.RotSpeed = NumberRange.new(-150, 150)
            break3.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255)) -- белый цвет по умолчанию
            break3.ZOffset = 4
            break3.Rotation = NumberRange.new(-360, 360)
            break3.Texture = "rbxassetid://5726444189"
            break3.Lifetime = NumberRange.new(0.5)
            break3.Speed = NumberRange.new(0.01)
            break3.LightEmission = 1
            break3.Rate = 1
            break3.Size = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 7, 0),
                NumberSequenceKeypoint.new(1, 7, 0)
            })
            break3.Enabled = false
            break3.Parent = breakEff

            local break1 = Instance.new("ParticleEmitter")
            break1.Name = "Break1"
            break1.VelocitySpread = -360
            break1.Texture = "rbxassetid://12239789629"
            break1.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255)) -- белый цвет по умолчанию
            break1.LockedToPart = true
            break1.ZOffset = 3
            break1.LightEmission = 0.5
            break1.Rotation = NumberRange.new(-360, 360)
            break1.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 1, 0),
                NumberSequenceKeypoint.new(0.5, 0, 0),
                NumberSequenceKeypoint.new(1, 1, 0)
            })
            break1.Lifetime = NumberRange.new(0.5)
            break1.Speed = NumberRange.new(0.01)
            break1.SpreadAngle = Vector2.new(-360, 360)
            break1.Rate = 1
            break1.Size = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 10, 0),
                NumberSequenceKeypoint.new(1, 10, 0)
            })
            break1.Enabled = false
            break1.Parent = breakEff

            effect_types["Break"] = breakEff
        end
        
        -- утилита: нормализует значение в Color3
        local function normalize_color(v)
            if typeof(v) == "Color3" then return v end
            if typeof(v) == "table" then
                -- поддержка структур от colorpicker: { Color = Color3, ... }
                local inner = v.Color or v.color or v.Value or v.value
                if inner and typeof(inner) == "Color3" then
                    return inner
                end
                -- поддержка таблиц с r/g/b или R/G/B, а также массив [r,g,b]
                local r,g,b = v.r or v.R or v[1], v.g or v.G or v[2], v.b or v.B or v[3]
                if r and g and b then
                    if r <= 1 and g <= 1 and b <= 1 then
                        return Color3.new(r, g, b)
                    else
                        return Color3.fromRGB(r, g, b)
                    end
                end
            end
            if typeof(v) == "string" then
                -- попытка распарсить #RRGGBB
                local hex = v:match("#?([%da-fA-F]+)")
                if hex and (#hex == 6) then
                    local r = tonumber(hex:sub(1,2), 16)
                    local g = tonumber(hex:sub(3,4), 16)
                    local b = tonumber(hex:sub(5,6), 16)
                    if r and g and b then return Color3.fromRGB(r,g,b) end
                end
            end
            return Color3.fromRGB(255, 0, 0)
        end

        -- применить эффект
        function HitEffect(target, effect_type)
            if not target or not target.Character then return end
            
            local hrp = target.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            
            -- инициализируем эффекты если еще не созданы
            if not next(effect_types) then
                init_effects()
            end
            
            local effect_template = effect_types[effect_type]
            if not effect_template then return end
            
            local effect = effect_template:Clone()
            
            -- получаем цвет из флага ПЕРЕД установкой Parent (с откатом на старый флаг)
            local lib_flags = library and library.flags or {}
            local color = normalize_color(
                (lib_flags["hiteffects_color"] or lib_flags["hiteffect_color"]) or Color3.fromRGB(255, 255, 255)
            )
            
            -- применяем цвет ДО установки Parent (один ключ, единый цвет)
            for _, obj in pairs(effect:GetDescendants()) do
                if obj:IsA("ParticleEmitter") then
                    obj.Color = ColorSequence.new(color)
                elseif obj:IsA("Trail") then
                    obj.Color = ColorSequence.new(color)
                elseif obj:IsA("Beam") then
                    obj.Color = ColorSequence.new(color)
                end
            end
            
            -- теперь устанавливаем Parent
            effect.Parent = hrp
            
            -- активируем эмиттеры ПОСЛЕ установки Parent
            for _, obj in pairs(effect:GetDescendants()) do
                if obj:IsA("ParticleEmitter") then
                    obj:Emit(obj.Rate or 100)
                end
            end
            
            -- удаляем через 2 секунды
            task.delay(2, function()
                if effect and effect.Parent then
                    effect:Destroy()
                end
            end)
        end
        
        -- глобальная функция для вызова из damage detection
        _G.HitEffect = HitEffect
        
        -- UI: HitEffects
        local hiteffect_toggle = OnDamage:toggle({ name = "Effects", flag = "hiteffect_enabled", default = false })
        -- пикер привязан к тогглу (всегда рядом), без зависимости
        hiteffect_toggle:colorpicker({ name = "Color", flag = "hiteffects_color", default = Color3.fromRGB(255, 255, 255) })

        local hiteffect_dep = OnDamage:dependency_box()
        hiteffect_dep:setup_dependencies({ { hiteffect_toggle, true } })
        hiteffect_dep:dropdown({
            name = "Type",
            flag = "hiteffect_type",
            items = {"Cum", "Particle", "Break"},
            default = "Cum"
        })
    end
    -- hiteffects system end
    
    -- damage detection system start
    do
        local targetHealth = nil
        local last_target = nil
        local last_damage_time = 0
        local damage_cooldown = 0.1 -- минимальная задержка между регистрациями урона
        local min_damage_threshold = 0.5 -- минимальный урон для регистрации
        
        local function updateTargetHealth()
            local target = targeting_state and targeting_state.current
            if not target or not target.Character then 
                targetHealth = nil
                last_target = nil
                return 
            end
            
            local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
            if not humanoid then 
                targetHealth = nil
                return 
            end
            
            -- reset health tracking when target changes
            if last_target ~= target then
                targetHealth = humanoid.Health
                last_target = target
                last_damage_time = 0
                return
            end
            
            local currentHealth = humanoid.Health
            local current_time = tick()
            
            -- check for damage with cooldown and threshold
            if targetHealth and currentHealth < targetHealth then
                local damageDealt = targetHealth - currentHealth
                
                -- проверяем cooldown и минимальный урон
                if damageDealt >= min_damage_threshold and (current_time - last_damage_time) >= damage_cooldown then
                    last_damage_time = current_time
                    
                    -- trigger hitchams
                    if flags and flags["hitchams_enabled"] then
                        HitChams(target)
                    end
                    
                    -- trigger hiteffects
                    if flags and flags["hiteffect_enabled"] then
                        local effect_type = flags["hiteffect_type"] or "Cum"
                        if _G.HitEffect then
                            _G.HitEffect(target, effect_type)
                        end
                    end
                    
                    -- trigger hitsound
                    if flags and flags["hitsound_enabled"] then
                        local file = flags["hs_file"]
                        if file and file ~= "" then
                            play_hitsound(file)
                        end
                    end
                    
                    -- trigger hit notification
                    local enabled = flags and flags["notif_enabled"]
                    if enabled then
                        local name = target.Name or "Player"
                        local hp = math.floor(math.max(currentHealth, 0))
                        local text = tostring(name) .. " " .. tostring(hp)
                        local duration = tonumber(flags["notif_duration"]) or 1.5
                        if duration <= 0 or duration > 10 or duration ~= duration then duration = 1.5 end
                        if library and library.notification then
                            library:notification({ text = text, time = duration })
                        end
                    end
                end
            end
            
            targetHealth = currentHealth
        end
        
        -- hook into render loop
        vars.run.Stepped:Connect(function()
            updateTargetHealth()
        end)
    end
    -- damage detection system end

    -- Aimbot section
    local aimbot_toggle = AimSec:toggle({
        name = "Enabled",
        flag = "aimbot_enabled",
        default = false,
    })
    local aimbot_dep = AimSec:dependency_box()
    aimbot_dep:setup_dependencies({ { aimbot_toggle, true } })
    aimbot_dep:dropdown({
        name = "Part",
        flag = "aimbot_part",
        items = {
            "HumanoidRootPart","Head","UpperTorso","LowerTorso",
            "LeftUpperArm","LeftLowerArm","LeftHand","RightUpperArm","RightLowerArm","RightHand",
            "LeftUpperLeg","LeftLowerLeg","LeftFoot","RightUpperLeg","RightLowerLeg","RightFoot"
        },
        default = "HumanoidRootPart",
    })

    -- Prediction section
    local pred_toggle = PredSec:toggle({
        name = "Enabled",
        flag = "pred_enabled",
        default = false,
    })
    local pred_dep = PredSec:dependency_box()
    pred_dep:setup_dependencies({ { pred_toggle, true } })
    local mode_dd = pred_dep:dropdown({
        name = "Prediction Mode",
        flag = "pred_mode",
        items = { "Sets", "Auto" },
        default = "Auto",
    })
    
    -- XYZ labels and textboxes (visible only in Sets mode)
    local sets_dep = PredSec:dependency_box()
    sets_dep:setup_dependencies({ { pred_toggle, true }, { mode_dd, "Sets" } })
    sets_dep:label({ name = "PredictionX" })
    sets_dep:textbox({ flag = "pred_x", default = "0" })
    sets_dep:label({ name = "PredictionY" })
    sets_dep:textbox({ flag = "pred_y", default = "0" })
    sets_dep:label({ name = "PredictionZ" })
    sets_dep:textbox({ flag = "pred_z", default = "0" })
    
    -- Show prediction tracer
    PredSec:toggle({
        name = "ShowPrediction",
        flag = "show_prediction",
        default = false,
    }):colorpicker({
        name = "Color",
        flag = "prediction_color",
        default = hex("#ffffff"),
    })

    -- Resolver section
    local res_toggle = ResSec:toggle({
        name = "Enabled",
        flag = "resolver_enabled",
        default = false,
    })
    local res_dep = ResSec:dependency_box()
    res_dep:setup_dependencies({ { res_toggle, true } })
    res_dep:dropdown({
        name = "Resolver Mode",
        flag = "resolver_mode",
        items = { "Velocity", "Recalculate", "MoveDirection", "LookVector", "CalculateCFrame" },
        default = "Velocity",
    })
end
-- aimbot/prediction/resolver UI end

-- aimbot runtime start
do
    -- preferences
    local PreferredParts = { "HumanoidRootPart", "Head", "UpperTorso", "Torso" }

    -- ping -> scalar prediction table (Auto mode)
    local predictionTable = {
        {20,0.08960952},
        {21,0.091171428},{22,0.092733336},{23,0.094295244},{24,0.095857152},{25,0.09741906},
        {26,0.098980968},{27,0.100542876},{28,0.102104784},{29,0.103666692},{30,0.11252476},
        {31,0.112978758},{32,0.113432756},{33,0.113886754},{34,0.114340752},{35,0.11479475},
        {36,0.115248748},{37,0.115702746},{38,0.116156744},{39,0.116610742},{40,0.11706474},
        {41,0.117518738},{42,0.117972736},{43,0.118426734},{44,0.118880732},{45,0.11933473},
        {46,0.119788728},{47,0.120242726},{48,0.120696724},{49,0.121150722},{50,0.13544},
        {51,0.1348236},{52,0.1342072},{53,0.1335908},{54,0.1329744},{55,0.132358},
        {56,0.1317416},{57,0.1311252},{58,0.1305088},{59,0.1298924},{60,0.129276},
        {61,0.1286596},{62,0.1280432},{63,0.1274268},{64,0.1268104},{65,0.1264236},
        {66,0.1262627},{67,0.1261018},{68,0.1259409},{69,0.12578},{70,0.12533},
        {71,0.125474},{72,0.125618},{73,0.125762},{74,0.125906},{75,0.12605},
        {76,0.126194},{77,0.126338},{78,0.126482},{79,0.126626},{80,0.13934},
        {81,0.1395937},{82,0.1398474},{83,0.1401011},{84,0.1403548},{85,0.1406085},
        {86,0.1408622},{87,0.1411159},{88,0.1413696},{89,0.1416233},{90,0.141877},
        {91,0.1421307},{92,0.1423844},{93,0.1426381},{94,0.1428918},{95,0.1431455},
        {96,0.1433992},{97,0.1436529},{98,0.1439066},{99,0.1441603},{100,0.141987},
        {101,0.1423107},{102,0.1426344},{103,0.1429581},{104,0.1432818},{105,0.1436055},
        {106,0.1439292},{107,0.1442529},{108,0.1445766},{109,0.1449003},{110,0.144634},
        {111,0.1449577},{112,0.1452814},{113,0.1456051},{114,0.1459288},{115,0.1462525},
        {116,0.1465762},{117,0.1468999},{118,0.1472236},{119,0.1475473},{120,0.147281},
        {121,0.1476047},{122,0.1479284},{123,0.1482521},{124,0.1485758},{125,0.1488995},
        {126,0.1492232},{127,0.1495469},{128,0.1498706},{129,0.1501943},{130,0.149928},
        {131,0.1502517},{132,0.1505754},{133,0.1508991},{134,0.1512228},{135,0.1515465},
        {136,0.1518702},{137,0.1521939},{138,0.1525176},{139,0.1528413},{140,0.152575},
        {141,0.1528987},{142,0.1532224},{143,0.1535461},{144,0.1538698},{145,0.1541935},
        {146,0.1545172},{147,0.1548409},{148,0.1551646},{149,0.1554883},{150,0.155222},
        {151,0.1555457},{152,0.1558694},{153,0.1561931},{154,0.1565168},{155,0.1568405},
        {156,0.1571642},{157,0.1574879},{158,0.1578116},{159,0.1581353},{160,0.157869},
        {161,0.1581927},{162,0.1585164},{163,0.1588401},{164,0.1591638},{165,0.1594875},
        {166,0.1598112},{167,0.1601349},{168,0.1604586},{169,0.1607823},{170,0.160516},
        {171,0.1608397},{172,0.1611634},{173,0.1614871},{174,0.1618108},{175,0.1621345},
        {176,0.1624582},{177,0.1627819},{178,0.1631056},{179,0.1634293},{180,0.163163},
        {181,0.1634867},{182,0.1638104},{183,0.1641341},{184,0.1644578},{185,0.1647815},
        {186,0.1651052},{187,0.1654289},{188,0.1657526},{189,0.1660763},{190,0.16581},
        {191,0.1661337},{192,0.1664574},{193,0.1667811},{194,0.1671048},{195,0.1674285},
        {196,0.1677522},{197,0.1680759},{198,0.1683996},{199,0.1687233},{200,0.168457},
        {201,0.1687807},{202,0.1691044},{203,0.1694281},{204,0.1697518},{205,0.1700755},
        {206,0.1703992},{207,0.1707229},{208,0.1710466},{209,0.1713703},{210,0.171104},
        {211,0.1714277},{212,0.1717514},{213,0.1720751},{214,0.1723988},{215,0.1727225},
        {216,0.1730462},{217,0.1733699},{218,0.1736936},{219,0.1740173},{220,0.173751},
        {221,0.1740747},{222,0.1743984},{223,0.1747221},{224,0.1750458},{225,0.1753695},
        {226,0.1756932},{227,0.1760169},{228,0.1763406},{229,0.1766643},{230,0.176398},
        {231,0.1767217},{232,0.1770454},{233,0.1773691},{234,0.1776928},{235,0.1780165},
        {236,0.1783402},{237,0.1786639},{238,0.1789876},{239,0.1793113},{240,0.179045},
        {241,0.1793687},{242,0.1796924},{243,0.1800161},{244,0.1803398},{245,0.1806635},
        {246,0.1809872},{247,0.1813109},{248,0.1816346},{249,0.1819583},{250,0.181692},
        {251,0.1820157},{252,0.1823394},{253,0.1826631},{254,0.1829868},{255,0.1833105},
        {256,0.1836342},{257,0.1839579},{258,0.1842816},{259,0.1846053},{260,0.184339},
        {261,0.1846627},{262,0.1849864},{263,0.1853101},{264,0.1856338},{265,0.1859575},
        {266,0.1862812},{267,0.1866049},{268,0.1869286},{269,0.1872523},{270,0.186986},
        {271,0.1873097},{272,0.1876334},{273,0.1879571},{274,0.1882808},{275,0.1886045},
        {276,0.1889282},{277,0.1892519},{278,0.1895756},{279,0.1898993},{280,0.189633},
        {281,0.1899567},{282,0.1902804},{283,0.1906041},{284,0.1909278},{285,0.1912515},
        {286,0.1915752},{287,0.1918989},{288,0.1922226},{289,0.1925463},{290,0.19228},
        {291,0.1926037},{292,0.1929274},{293,0.1932511},{294,0.1935748},{295,0.1938985},
        {296,0.1942222},{297,0.1945459},{298,0.1948696},{299,0.1951933},{300,0.194927}
    }

    local function get_auto_scalar()
        local stats = game:GetService("Stats")
        local pingMs
        local ok, _ = pcall(function()
            local s = stats.Network.ServerStatsItem["Data Ping"]:GetValueString() -- e.g. "45 ms"
            pingMs = tonumber((s or ""):match("%d+"))
        end)
        if not ok or not pingMs then return 0 end
        local bestVal, bestDiff
        for _, pair in ipairs(predictionTable) do
            local diff = math.abs(pingMs - pair[1])
            if not bestDiff or diff < bestDiff then
                bestDiff = diff
                bestVal = pair[2]
            end
        end
        return bestVal or 0
    end

    local function get_target_part(player)
        if not player or not player.Character then return nil end
        local char = player.Character
        -- prefer user-selected part
        local selected = flags and flags["aimbot_part"]
        if selected and char:FindFirstChild(selected) then
            return char[selected]
        end
        for _, name in ipairs(PreferredParts) do
            local p = char:FindFirstChild(name)
            if p then return p end
        end
        return nil
    end

    local resolver_cache = { lastPos = nil, lastTick = nil, lastPart = nil }

    local function get_predicted_position(part)
        if not part then return nil end
        local pos = part.Position
        if flags["pred_enabled"] then
            -- resolver velocity selection
            local vel
            local resolverOn = flags["resolver_enabled"]
            local modeRes = flags["resolver_mode"]
            if resolverOn and modeRes and modeRes ~= "Velocity" then
                if modeRes == "Recalculate" or modeRes == "CalculateCFrame" then
                    if resolver_cache.lastPart ~= part then
                        resolver_cache.lastPos, resolver_cache.lastTick, resolver_cache.lastPart = part.Position, tick(), part
                    end
                    local now = tick()
                    local dt = (resolver_cache.lastTick and (now - resolver_cache.lastTick)) or 0
                    if dt > 0 and resolver_cache.lastPos then
                        vel = (part.Position - resolver_cache.lastPos) / dt
                    else
                        vel = part.AssemblyLinearVelocity or part.Velocity or Vector3.zero
                    end
                    resolver_cache.lastPos, resolver_cache.lastTick = part.Position, now
                elseif modeRes == "MoveDirection" then
                    local humanoid = part.Parent and part.Parent:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        vel = humanoid.MoveDirection * (humanoid.WalkSpeed or 16)
                    end
                elseif modeRes == "LookVector" then
                    local humanoid = part.Parent and part.Parent:FindFirstChildOfClass("Humanoid")
                    local speed = (humanoid and humanoid.WalkSpeed) or 16
                    vel = part.CFrame.LookVector * (speed * 1.5)
                end
            end
            vel = vel or part.AssemblyLinearVelocity or part.Velocity or Vector3.zero
            local mode = flags["pred_mode"]
            if mode == "Auto" then
                local s = get_auto_scalar()
                pos = pos + (vel * Vector3.new(s, s, s))
            else
                local vx = tonumber(flags["pred_x"]) or 0
                local vy = tonumber(flags["pred_y"]) or 0
                local vz = tonumber(flags["pred_z"]) or 0
                pos = pos + (vel * Vector3.new(vx, vy, vz))
            end
        end
        return pos
    end

    local mt = getrawmetatable(game)
    local oldIndex = mt.__index
    setreadonly(mt, false)

    mt.__index = newcclosure(function(self, key)
        -- enable only when aimbot is on
        if not checkcaller() and key and (key == "Hit" or key == "Silent" or key == "Target") and flags and flags["aimbot_enabled"] then
            local player = targeting_state.current
            local part = get_target_part(player)
            if part then
                local predicted = get_predicted_position(part) or part.Position
                if key == "Hit" then
                    return CFrame.new(predicted)
                elseif key == "Silent" or key == "Target" then
                    return part
                end
            end
        end
        return oldIndex(self, key)
    end)

    setreadonly(mt, true)
end
-- aimbot runtime end


-- prediction tracer runtime start
do
    local Drawing = Drawing
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera
    
    -- guard against duplicates: cleanup previous tracer if exists
    do
        local prev = getgenv().PredictionTracer
        if prev and prev.cleanup then
            pcall(prev.cleanup)
        end
    end
    local PT = { }
    getgenv().PredictionTracer = PT
    
    -- create tracer outline (for nicer look)
    local tracerOutline = Drawing.new("Line")
    tracerOutline.Visible = false
    tracerOutline.Thickness = 6 -- base, will sync to tracer.Thickness + 2
    tracerOutline.Transparency = 0.7
    tracerOutline.Color = Color3.fromRGB(0, 0, 0)
    PT.tracerOutline = tracerOutline
    
    -- create tracer line
    local tracer = Drawing.new("Line")
    tracer.Visible = false
    tracer.Thickness = 1.5 -- slightly thinner
    tracer.Transparency = 1
    PT.tracer = tracer
    
    -- base tip radius for end circles
    local baseTipR = 4
    
    -- endpoint circles (start/end) with outlines
    local startOutline = Drawing.new("Circle")
    startOutline.Visible = false
    startOutline.Filled = false -- outline stroke to match tracer thickness
    startOutline.Color = Color3.fromRGB(0, 0, 0)
    startOutline.Transparency = 0.8
    startOutline.Radius = 4 -- outline radius
    PT.startOutline = startOutline
    
    local startCircle = Drawing.new("Circle")
    startCircle.Visible = false
    startCircle.Filled = true
    startCircle.Color = Color3.fromRGB(255, 255, 255)
    startCircle.Transparency = 1
    startCircle.Radius = 2
    PT.startCircle = startCircle
    
    local endOutline = Drawing.new("Circle")
    endOutline.Visible = false
    endOutline.Filled = false -- outline stroke to match tracer thickness
    endOutline.Color = Color3.fromRGB(0, 0, 0)
    endOutline.Transparency = 0.8
    endOutline.Radius = 4
    PT.endOutline = endOutline
    
    local endCircle = Drawing.new("Circle")
    endCircle.Visible = false
    endCircle.Filled = true
    endCircle.Color = Color3.fromRGB(255, 255, 255)
    endCircle.Transparency = 1
    endCircle.Radius = 2
    PT.endCircle = endCircle
    
    -- preferences (reuse from aimbot)
    local PreferredParts = { "HumanoidRootPart", "Head", "UpperTorso", "Torso" }
    -- ping -> scalar prediction table (Auto mode)
    local predictionTable = {
        {20, 0.08960952},{30, 0.11252476},{50, 0.13544},{65, 0.1264236},{70, 0.12533},
        {80, 0.13934},{100, 0.141987},{110, 0.144634},{120, 0.147281},{130, 0.149928},
        {140, 0.152575},{150, 0.155222},{160, 0.157869},{170, 0.160516},{180, 0.163163},
        {190, 0.16581},{200, 0.168457},{210, 0.171104},{220, 0.173751},{230, 0.176398},
        {240, 0.179045},{250, 0.181692},{260, 0.184339},{270, 0.186986},{280, 0.189633},
        {290, 0.19228},{300, 0.194927}
    }

    local lastAuto = { t = 0, val = 0 }
    local function get_auto_scalar()
        local now = tick and tick() or os.clock()
        if now - (lastAuto.t or 0) < 0.25 then
            return lastAuto.val or 0
        end
        local stats = game:GetService("Stats")
        local pingMs
        local ok, _ = pcall(function()
            local s = stats.Network.ServerStatsItem["Data Ping"]:GetValueString()
            pingMs = tonumber((s or ""):match("%d+"))
        end)
        if not ok or not pingMs then return lastAuto.val or 0 end
        local bestVal, bestDiff
        for _, pair in ipairs(predictionTable) do
            local diff = math.abs(pingMs - pair[1])
            if not bestDiff or diff < bestDiff then
                bestDiff = diff
                bestVal = pair[2]
            end
        end
        lastAuto.t = now
        lastAuto.val = bestVal or lastAuto.val or 0
        return lastAuto.val or 0
    end
    
    local function get_target_part(player)
        if not player or not player.Character then return nil end
        local char = player.Character
        -- prefer user-selected part
        local selected = flags and flags["aimbot_part"]
        if selected and char:FindFirstChild(selected) then
            return char[selected]
        end
        for _, name in ipairs(PreferredParts) do
            local p = char:FindFirstChild(name)
            if p then return p end
        end
        return nil
    end
    
    local function get_predicted_position(part)
        if not part then return nil end
        local pos = part.Position
        if flags["pred_enabled"] then
            local vel = part.AssemblyLinearVelocity or part.Velocity or Vector3.zero
            local mode = flags["pred_mode"]
            if mode == "Auto" then
                local s = get_auto_scalar()
                pos = pos + (vel * Vector3.new(s, s, s))
            else
                local vx = tonumber(flags["pred_x"]) or 0
                local vy = tonumber(flags["pred_y"]) or 0
                local vz = tonumber(flags["pred_z"]) or 0
                pos = pos + (vel * Vector3.new(vx, vy, vz))
            end
        end
        return pos
    end
    
    -- update tracer
    local conn = RunService.RenderStepped:Connect(function()
        if flags["show_prediction"] and targeting_state.current then
            local part = get_target_part(targeting_state.current)
            if part then
                local predicted = get_predicted_position(part)
                if predicted then
                    local screen_pos, on_screen = Camera:WorldToViewportPoint(predicted)
                    if on_screen then
                        -- get mouse position
                        local mouse_pos = UserInputService:GetMouseLocation()
                        
                        -- update tracer outline (behind main line)
                        tracerOutline.From = mouse_pos
                        tracerOutline.To = Vector2.new(screen_pos.X, screen_pos.Y)
                        tracerOutline.Thickness = math.max(1, (tracer.Thickness or 2) + 2)
                        if not tracerOutline.Visible then tracerOutline.Visible = true end

                        -- update tracer
                        tracer.From = mouse_pos
                        tracer.To = Vector2.new(screen_pos.X, screen_pos.Y)
                        local newColor = (flags["prediction_color"] and flags["prediction_color"].Color) or Color3.fromRGB(255, 255, 255)
                        if tracer.Color ~= newColor then tracer.Color = newColor end
                        if not tracer.Visible then tracer.Visible = true end

                        -- update endpoint circles
                        local tipColor = tracer.Color
                        local endPos = Vector2.new(screen_pos.X, screen_pos.Y)

                        -- inner circles first (to use their radius for outlines)
                        startCircle.Position = mouse_pos
                        startCircle.Radius = math.max(1, baseTipR * 0.25) -- mouse tip: 0.25x
                        if startCircle.Color ~= tipColor then startCircle.Color = tipColor end
                        if not startCircle.Visible then startCircle.Visible = true end

                        endCircle.Position = endPos
                        endCircle.Radius = math.max(1, baseTipR * 0.5) -- end tip: 0.5x
                        if endCircle.Color ~= tipColor then endCircle.Color = tipColor end
                        if not endCircle.Visible then endCircle.Visible = true end

                        -- outlines sync after inner set
                        local outlineThk = math.max(1, (tracer.Thickness or 2) + 2)
                        startOutline.Position = mouse_pos
                        startOutline.Thickness = outlineThk
                        startOutline.Radius = startCircle.Radius + (outlineThk / 2)
                        if not startOutline.Visible then startOutline.Visible = true end

                        endOutline.Position = endPos
                        endOutline.Thickness = outlineThk
                        endOutline.Radius = endCircle.Radius + (outlineThk / 2)
                        if not endOutline.Visible then endOutline.Visible = true end
                    else
                        if tracer.Visible then tracer.Visible = false end
                        if tracerOutline.Visible then tracerOutline.Visible = false end
                        if startCircle.Visible then startCircle.Visible = false end
                        if endCircle.Visible then endCircle.Visible = false end
                        if startOutline.Visible then startOutline.Visible = false end
                        if endOutline.Visible then endOutline.Visible = false end
                    end
                else
                    if tracer.Visible then tracer.Visible = false end
                    if tracerOutline.Visible then tracerOutline.Visible = false end
                    if startCircle.Visible then startCircle.Visible = false end
                    if endCircle.Visible then endCircle.Visible = false end
                    if startOutline.Visible then startOutline.Visible = false end
                    if endOutline.Visible then endOutline.Visible = false end
                end
            else
                if tracer.Visible then tracer.Visible = false end
                if tracerOutline.Visible then tracerOutline.Visible = false end
                if startCircle.Visible then startCircle.Visible = false end
                if endCircle.Visible then endCircle.Visible = false end
                if startOutline.Visible then startOutline.Visible = false end
                if endOutline.Visible then endOutline.Visible = false end
            end
        else
            if tracer.Visible then tracer.Visible = false end
            if tracerOutline.Visible then tracerOutline.Visible = false end
            if startCircle.Visible then startCircle.Visible = false end
            if endCircle.Visible then endCircle.Visible = false end
            if startOutline.Visible then startOutline.Visible = false end
            if endOutline.Visible then endOutline.Visible = false end
        end
    end)
    table.insert(library.connections, conn)
    PT.conn = conn

    -- provide cleanup for future reloads
    PT.cleanup = function()
        pcall(function() if PT.conn then PT.conn:Disconnect() end end)
        local function safe_remove(obj)
            if obj and obj.Remove then pcall(function() obj:Remove() end) end
        end
        safe_remove(PT.tracer)
        safe_remove(PT.tracerOutline)
        safe_remove(PT.startCircle)
        safe_remove(PT.startOutline)
        safe_remove(PT.endCircle)
        safe_remove(PT.endOutline)
        getgenv().PredictionTracer = nil
    end
end
-- prediction tracer runtime end

-- target tracer system start
do
    local vars = {
        rs = game:GetService("RunService"),
        uis = game:GetService("UserInputService"),
        camera = workspace.CurrentCamera
    }
    
    -- tracer state
    local tracer_state = {
        line = nil,
        line_outline = nil,
        enabled = false,
        part = "HumanoidRootPart",
        origin = "mouse",
        connection = nil
    }
    
    -- r15 body parts
    local r15_parts = {
        "Head", "UpperTorso", "LowerTorso", "HumanoidRootPart",
        "LeftUpperArm", "LeftLowerArm", "LeftHand",
        "RightUpperArm", "RightLowerArm", "RightHand",
        "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
        "RightUpperLeg", "RightLowerLeg", "RightFoot"
    }

end

getgenv().load_config = function(name)
	library:load_config(readfile(library.directory .. "/configs/" .. name .. ".cfg"))
end

local column = Settings:column()
local section = column:section({ name = "Options" })
local old_config = library:get_config()
config_holder = section:list({ flag = "config_name_list" })
section:textbox({ flag = "config_name_text_box" })
section:button_holder({})
section:button({
    name = "Create",
    callback = function()
        writefile(library.directory .. "/configs/" .. flags["config_name_text_box"] .. ".cfg", library:get_config())
        library:config_list_update()
    end,
})
section:button({
	name = "Delete",
	callback = function()
		delfile(library.directory .. "/configs/" .. flags["config_name_list"] .. ".cfg")
		library:config_list_update()
	end,
})
section:button_holder({})
section:button({
	name = "Load",
	callback = function()
		library:load_config(readfile(library.directory .. "/configs/" .. flags["config_name_list"] .. ".cfg"))
		library:notification({
			text = "Loaded Config: " .. flags["config_name_list"],
			time = 3,
		})
	end,
})
section:button({
	name = "Save",
	callback = function()
		writefile(library.directory .. "/configs/" .. flags["config_name_list"] .. ".cfg", library:get_config())
		library:config_list_update()
		library:notification({
			text = "Saved Config: " .. flags["config_name_list"],
			time = 3,
		})
	end,
})
section:button_holder({})
section:button({
	name = "Refresh Configs",
	callback = function()
		library:config_list_update()
	end,
})
section:button_holder({})
section:button({
	name = "Unload Config",
	callback = function()
		library:load_config(old_config)
	end,
})
section:button({
	name = "Unload Menu",
	callback = function()
		library:load_config(old_config)

		for _, gui in library.guis do
			gui:Destroy()
		end

		for _, connection in library.connections do
			connection:Disconnect()
		end
	end,
})

local Theme, Game, HUD = Settings:column():multi_section({ names = { "Theme", "Game", "HUD" } })
Theme:label({ name = "Accent" }):colorpicker({
	name = "Accent",
	color = hex("#ffffff"),
	flag = "accent",
	callback = function(color, alpha)
		library:update_theme("accent", color)
	end,
})
Theme
	:label({ name = "Contrast" })
	:colorpicker({
		name = "Low",
		color = hex("#2d2d2d"),
		flag = "low_contrast",
		callback = function(color)
			if flags["high_contrast"] and flags["low_contrast"] then
				library:update_theme(
					"contrast",
					rgbseq({
						rgbkey(0, flags["low_contrast"].Color),
						rgbkey(1, flags["high_contrast"].Color),
					})
				)
			end
		end,
	})
	:colorpicker({
		name = "High",
		color = hex("#101010"),
		flag = "high_contrast",
		callback = function(color)
			library:update_theme(
				"contrast",
				rgbseq({
					rgbkey(0, flags["low_contrast"].Color),
					rgbkey(1, flags["high_contrast"].Color),
				})
			)
		end,
	})
Theme:label({ name = "Inline" }):colorpicker({
	name = "Inline",
	color = hex("#313131"),
	flag = "theme_inline",
	callback = function(color, alpha)
		library:update_theme("inline", color)
	end,
})
Theme:label({ name = "Outline" }):colorpicker({
	name = "Outline",
	color = hex("#000000"),
	flag = "theme_outline",
	callback = function(color, alpha)
		library:update_theme("outline", color)
	end,
})
Theme
	:label({ name = "Text Color" })
	:colorpicker({
		name = "Main",
		color = hex("#7b7b7b"),
		flag = "theme_text",
		callback = function(color, alpha)
			library:update_theme("text", color)
		end,
	})
	:colorpicker({
		name = "Outline",
		color = hex("#282828"),
		flag = "theme_text_outline",
		callback = function(color, alpha)
			library:update_theme("text_outline", color)
		end,
	})
Theme:label({ name = "Glow" }):colorpicker({
	name = "Glow",
	color = hex("#ffffff"),
	flag = "theme_glow",
	callback = function(color, alpha)
		library:update_theme("glow", color)
	end,
})
HUD:label({ name = "UI Bind" }):keybind({
	callback = window.set_menu_visibility,
	key = Enum.KeyCode.Insert,
})
HUD:toggle({
	name = "Keybind List",
	flag = "keybind_list",
	callback = function(bool)
		library.keybind_list_frame.Visible = bool
	end,
})
HUD:toggle({
    name = "CustomUI",
    flag = "custom_hud_enabled",
    callback = function(bool)
        custom_hud.set_visible(bool)
    end,
})
:colorpicker({
    name = "Health",
    flag = "hud_health_color",
    color = custom_hud.colors.health_bar,
    callback = function(color)
        custom_hud.colors.health_bar = color
        custom_hud.update_bar_colors()
    end,
})
:colorpicker({
    name = "Armor",
    flag = "hud_armor_color",
    color = custom_hud.colors.armor_bar,
    callback = function(color)
        custom_hud.colors.armor_bar = color
        custom_hud.update_bar_colors()
    end,
})
:colorpicker({
    name = "Text",
    flag = "hud_text_color",
    color = custom_hud.colors.text,
    callback = function(color)
        custom_hud.colors.text = color
        custom_hud.update_bar_colors()
    end,
})


-- build watermark text based on selected HUD -> Watermark -> Type items
local PLACE_NAME_CACHE
local function build_watermark_text()
    local sel = flags["watermark_type"]
    local out = {}

    -- cache place name once
    local function get_place_name()
        if PLACE_NAME_CACHE ~= nil then
            return PLACE_NAME_CACHE
        end
        local ok, info = pcall(function()
            return game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId)
        end)
        local name = ok and info and info.Name or tostring(game.PlaceId)
        PLACE_NAME_CACHE = name
        return name
    end

    if type(sel) == "table" then
        -- normalize selection to a set for stable ordering output
        local selected = {}
        for _, key in next, sel do selected[key] = true end
        if selected["Date"] then out[#out + 1] = os.date("%y:%m:%d") end
        if selected["Time"] then out[#out + 1] = os.date("%H:%M:%S") end
        if selected["Place"] then out[#out + 1] = get_place_name() end
        if selected["User"] then out[#out + 1] = (lp and lp.Name or "?") end
    end

    if #out == 0 then
        -- fallback: keep prior behavior-like time stamp
        out[1] = os.date("%H:%M:%S")
    end

    return "Rebuild.gg - " .. table.concat(out, " - ")
end

local wm_toggle = HUD:toggle({
    name = "Watermark",
    flag = "watermark",
    callback = function(bool)
        watermark.set_visible(bool)
        if bool then
            -- immediate refresh on toggle enable
            watermark.change_text(build_watermark_text())
        end
    end,
})
local wm_dep = HUD:dependency_box()
wm_dep:setup_dependencies({
    { wm_toggle, true }
})
wm_dep:dropdown({
    name = "Type",
    flag = "watermark_type",
    items = { "Time", "Date", "Place", "User" },
    multi = true,
    default = { "Time" },
    callback = function(selected)
        -- immediate refresh on selection change
        watermark.change_text(build_watermark_text())
    end,
})

-- radar hud start
local radar_toggle = HUD:toggle({
    name = "Radar",
    flag = "hud_radar",
    callback = function(bool)
        radar.set_visible(bool)
    end,
})
local radar_dep = HUD:dependency_box()
radar_dep:setup_dependencies({
    { radar_toggle, true },
})
radar_dep:slider({
    name = "Zoom",
    flag = "radar_zoom",
    min = 0.1,
    max = 2,
    default = 1,
    interval = 0.1,
    callback = function(v)
        radar.set_zoom(v)
    end,
})
-- radar hud end
Game:button_holder({})
Game:button({
	name = "Copy JobId",
	callback = function()
		setclipboard(game.JobId)
	end,
})
Game:button_holder({})
Game:button({
	name = "Copy GameID",
	callback = function()
		setclipboard(game.GameId)
	end,
})
Game:button_holder({})
Game:button({
	name = "Copy Join Script",
	callback = function()
		setclipboard(
			'game:GetService("TeleportService"):TeleportToPlaceInstance('
				.. game.PlaceId
				.. ', "'
				.. game.JobId
				.. '", game.Players.LocalPlayer)'
		)
	end,
})
Game:button_holder({})
Game:button({
	name = "Rejoin",
	callback = function()
		game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, lp)
	end,
})
Game:button_holder({})
Game:button({
	name = "Join New Server",
	callback = function()
		local apiRequest = game:GetService("HttpService"):JSONDecode(
			game:HttpGetAsync(
				"https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
			)
		)
		local data = apiRequest.data[random(1, #apiRequest.data)]

		if data.playing <= flags["max_players"] then
			game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, data.id)
		end
	end,
})
Game:slider({
    name = "Max Players",
    flag = "max_players",
    min = 0,
    max = 40,
    default = 15,
    interval = 1,
})
--
Aimbot.open_tab()

task.spawn(function()
    while task.wait(1) do
        watermark.change_text(build_watermark_text())
    end
end)
--

-- radar runtime start
do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    local function track_player(p)
        if p ~= lp then
            radar.add_dot(p)
        end
    end

    for _, p in ipairs(Players:GetPlayers()) do
        track_player(p)
    end

    table.insert(library.connections, Players.PlayerAdded:Connect(track_player))
    table.insert(library.connections, Players.PlayerRemoving:Connect(function(p)
        radar.remove_dot(p)
    end))

    table.insert(library.connections, RunService.RenderStepped:Connect(function()
        -- radar update
        if radar and flags["hud_radar"] then
            for _, p in ipairs(Players:GetPlayers()) do
                if p ~= lp then
                    local char = p.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        radar.update_dot(p, hrp.Position)
                    end
                end
            end
        end
    end))
end
-- radar runtime end

library:config_list_update()

for index, value in next, themes.preset do
	pcall(function()
		library:update_theme(index, value)
	end)
end

-- misc system start
do
	local misc_col = Misc:column()
	local DesyncSec = misc_col:section({ name = "Desync" })
	
	-- auto armor system
	local auto_armor_state = {
		enabled = false,
		value_to_buy = 100,
		loop_conn = nil,
		armor_conn = nil, -- Changed connection for instant reaction
		char_conn = nil,
		stopped = false,
		busy = false,
		last_click_t = 0,
		click_interval = 0.02,
		post_wait_frames = 2,
		last_attempt = 0,
		attempt_cooldown = 0.1, -- seconds between attempts to avoid spam
		shop_head = nil,
		shop_clickdet = nil,
	}

	-- общий приоритетный статус для систем десинка
	local desync_priority_state = {
		autostomp_active = false,
	}
	
	-- utility functions
	local function get_armor_value()
		local char = lp.Character
		if not char then return nil end
		local be = char:FindFirstChild("BodyEffects")
		local armor = be and be:FindFirstChild("Armor")
		return armor and armor.Value or nil
	end
	
	local function get_cash()
		local df = lp:FindFirstChild("DataFolder")
		local cur = df and df:FindFirstChild("Currency")
		return cur and cur.Value or 0
	end
	
	local function get_shop()
		local shop = workspace:FindFirstChild("Ignored")
		shop = shop and shop:FindFirstChild("Shop")
		if not shop then return nil end
		local items = shop:GetChildren()
		-- сначала пробуем фиксированный индекс
		local armor_item = items[16]
		local head, cd
		if armor_item then
			head = armor_item:FindFirstChild("Head")
			if head then
				cd = head:FindFirstChildOfClass("ClickDetector") or armor_item:FindFirstChildOfClass("ClickDetector")
			end
		end
		-- запасной поиск по структуре (Head + ClickDetector)
		if not (armor_item and head and cd) then
			armor_item, head, cd = nil, nil, nil
			for _, it in ipairs(items) do
				local h = it:FindFirstChild("Head")
				if h then
					local detector = h:FindFirstChildOfClass("ClickDetector") or it:FindFirstChildOfClass("ClickDetector")
					if detector then
						armor_item, head, cd = it, h, detector
						break
					end
				end
			end
		end
		return armor_item, head, cd
	end

	-- cache shop parts for faster reaction
	local function ensure_shop_cached()
		if auto_armor_state.shop_head and auto_armor_state.shop_clickdet then
			return auto_armor_state.shop_head, auto_armor_state.shop_clickdet
		end
		local _, head, clickdet = get_shop()
		auto_armor_state.shop_head, auto_armor_state.shop_clickdet = head, clickdet
		return head, clickdet
	end

	-- single entry point to attempt buying armor fast
	local function attempt_buy_armor()
		if not auto_armor_state.enabled or auto_armor_state.stopped or auto_armor_state.busy then return end
		local now = tick()
		if (now - auto_armor_state.last_attempt) < auto_armor_state.attempt_cooldown then return end
		auto_armor_state.last_attempt = now

		local cur = get_armor_value()
		if not cur then return end
		if cur >= 200 or cur > auto_armor_state.value_to_buy then return end
		if get_cash() < 1000 then return end

		local head, clickdet = ensure_shop_cached()
		if not (head and clickdet) then return end

		if _G.DesyncLibrary then
			auto_armor_state.busy = true
			if flags and flags["Debug"] then print("[AutoArmor] moving to shop (instant)") end
			_G.DesyncLibrary.movedesyncto(head.CFrame)
			pcall(function()
				vars.run.Heartbeat:Wait()
				vars.run.RenderStepped:Wait()
			end)

			for i = 1, 30 do
				if auto_armor_state.stopped or not auto_armor_state.enabled then break end
				local v = get_armor_value()
				if v and (v >= 200 or v >= auto_armor_state.value_to_buy) then break end
				if get_cash() < 1000 then break end
				vars.run.RenderStepped:Wait()
				pcall(fireclickdetector, clickdet)
				if auto_armor_state.click_interval and auto_armor_state.click_interval > 0 then
					vars.run.Heartbeat:Wait()
					_G.DesyncLibrary.SynchronizeSyncWithPlayer()
				end
			end
			if flags and flags["Debug"] then print("[AutoArmor] resynced after purchase") end
			auto_armor_state.busy = false
		end
	end

	local function connect_armor_listener()
		if auto_armor_state.armor_conn then return end
		local char = lp.Character
		if not char then return end
		local be = char:FindFirstChild("BodyEffects")
		local armor = be and be:FindFirstChild("Armor")
		if not armor then return end
		auto_armor_state.armor_conn = armor.Changed:Connect(function()
			-- моментальная реакция на падение брони
			attempt_buy_armor()
		end)
		-- также пробуем один раз при подключении
		attempt_buy_armor()
		-- обновление коннекта при респауне можно добавить в CharacterAdded хук, если он есть в vars/utility
	end

	local function connect_character_listener()
		if auto_armor_state.char_conn then return end
		auto_armor_state.char_conn = lp.CharacterAdded:Connect(function()
			-- подождем кадр, чтобы BodyEffects/Armor появились
			pcall(function()
				vars.run.Heartbeat:Wait()
				vars.run.RenderStepped:Wait()
			end)
			-- сбросим предыдущую подписку и кеш магазина
			if auto_armor_state.armor_conn then
				auto_armor_state.armor_conn:Disconnect()
				auto_armor_state.armor_conn = nil
			end
			auto_armor_state.shop_head, auto_armor_state.shop_clickdet = nil, nil
			-- переподключим мгновенную реакцию
			if auto_armor_state.enabled then
				ensure_shop_cached()
				connect_armor_listener()
				attempt_buy_armor()
			end
		end)
	end
	
	-- main auto armor loop
	local function start_auto_armor()
		if auto_armor_state.loop_conn then return end
		-- cache shop once and listen to armor changes for instant trigger
		ensure_shop_cached()
		connect_armor_listener()
		connect_character_listener()
		
		auto_armor_state.loop_conn = vars.task.spawn(function()
			while auto_armor_state.enabled do
				vars.task.wait(0.05) -- faster poll as a fallback; primary is event-driven
				
				if not auto_armor_state.stopped then
					attempt_buy_armor()
				end
			end
		end)
	end
	
	local function stop_auto_armor()
		if auto_armor_state.loop_conn then
			pcall(function() 
				vars.task.cancel(auto_armor_state.loop_conn)
			end)
			auto_armor_state.loop_conn = nil
		end
		if auto_armor_state.armor_conn then
			auto_armor_state.armor_conn:Disconnect()
			auto_armor_state.armor_conn = nil
		end
		if auto_armor_state.char_conn then
			auto_armor_state.char_conn:Disconnect()
			auto_armor_state.char_conn = nil
		end

		auto_armor_state.busy = false
		auto_armor_state.shop_head, auto_armor_state.shop_clickdet = nil, nil
		
		-- resync back to player when stopping auto armor
		if _G.DesyncLibrary then
			pcall(function()
				_G.DesyncLibrary.SynchronizeSyncWithPlayer()
			end)
		end
	end
	
	-- ui elements
	local auto_armor_toggle = DesyncSec:toggle({
		name = "Auto Armor",
		flag = "auto_armor_enabled",
		default = false,
		callback = function(state)
			auto_armor_state.enabled = state
			if state then
				start_auto_armor()
			else
				stop_auto_armor()
			end
			-- сброс состояния AutoStomp при изменении Auto Armor
			if autostomp_state and autostomp_state.enabled then
				autostomp_state.last_sync = 0 -- сброс таймера синхронизации
				autostomp_state.last_stomp = 0 -- сброс таймера стомпа
			end
			-- при выключении Auto Armor снимаем блокировку
			auto_armor_state.busy = state and auto_armor_state.busy or false
		end
	})
	
	-- dependency box for slider
	local armor_dep = DesyncSec:dependency_box()
	armor_dep:setup_dependencies({ { auto_armor_toggle, true } })
	
	armor_dep:slider({
		name = "BuyAt",
		flag = "armor_percent_to_buy",
		min = 1,
		max = 199,
		default = 100,
		callback = function(value)
			auto_armor_state.value_to_buy = value
		end
	})

	-- инициализация значения из сохраненного флага (обратная совместимость)
	auto_armor_state.value_to_buy = (flags and typeof(flags["armor_percent_to_buy"]) == "number") and flags["armor_percent_to_buy"] or auto_armor_state.value_to_buy
	
	-- autostomp system start
	do
		local autostomp_state = {
			enabled = false,
			loop_conn = nil,
			hb_conn = nil,
			stomp_rate = 10, -- раз в секунду
			last_stomp = 0,
			was_active = false,
			tu_registered = false,
			-- noclip state
			noclip_char = nil,
			noclip_parts = {}, -- [BasePart] = original CanCollide
			y_offset = 0,
			-- периодическая синхронизация
			last_sync = 0,
			sync_interval = 3, -- секунды между синхронизациями
		}
		
		-- проверка KO статуса игрока
		local function IsPlayerKO(player)
			return player and player.Character and player.Character:FindFirstChild("BodyEffects") and 
				   player.Character.BodyEffects:FindFirstChild("K.O") and player.Character.BodyEffects["K.O"].Value
		end
		
		-- получение позиции торса цели
		local function get_target_torso_position(player)
			if not player or not player.Character then return nil end
			local char = player.Character
			local upper_torso = char:FindFirstChild("UpperTorso")
			local lower_torso = char:FindFirstChild("LowerTorso")
			local torso = upper_torso or lower_torso
			return torso and torso.CFrame
		end
		
		-- управление коллизиями цели (noclip)
		local function restore_target_noclip()
			if autostomp_state.noclip_char then
				for part, original in pairs(autostomp_state.noclip_parts) do
					if part and part.Parent then
						pcall(function()
							part.CanCollide = original
						end)
					end
				end
				autostomp_state.noclip_parts = {}
				autostomp_state.noclip_char = nil
			end
		end
		local function apply_target_noclip(player)
			local char = player and player.Character
			if not char then return end
			if autostomp_state.noclip_char == char then return end
			-- восстановим с предыдущего персонажа, если был
			restore_target_noclip()
			autostomp_state.noclip_char = char
			for _, d in ipairs(char:GetDescendants()) do
				if d:IsA("BasePart") then
					autostomp_state.noclip_parts[d] = d.CanCollide
					pcall(function()
						d.CanCollide = false
					end)
				end
			end
		end
		
		-- основной цикл автостомпа (Heartbeat)
		local function start_autostomp()
			if autostomp_state.hb_conn then return end
			autostomp_state.last_stomp = 0
			autostomp_state.last_sync = 0
			autostomp_state.was_active = false
			-- подписка на смену цели (однократно)
			if not autostomp_state.tu_registered and utility and utility.OnTargetUpdate then
				autostomp_state.tu_registered = true
				utility:OnTargetUpdate(function(info)
					if not autostomp_state.enabled then return end
					-- при потере цели синхронизируем и восстанавливаем коллизии
					if not info and autostomp_state.was_active then
						restore_target_noclip()
						pcall(function()
							if _G.DesyncLibrary and _G.DesyncLibrary.SynchronizeSyncWithPlayer then
								_G.DesyncLibrary.SynchronizeSyncWithPlayer()
							end
						end)
						autostomp_state.was_active = false
					end
					-- сброс таймера для быстрого следующего стомпа
					autostomp_state.last_stomp = 0
				end)
			end

			autostomp_state.hb_conn = vars.run.Heartbeat:Connect(function()
				-- условия
				local target = targeting_state and targeting_state.current
				-- приоритет: блокировать только во время реальной покупки брони
				local armor_blocking = auto_armor_state.busy == true
				local active = autostomp_state.enabled and not armor_blocking and target and IsPlayerKO(target)
				-- сообщаем статус активности для приоритета Voiding
				desync_priority_state.autostomp_active = active and true or false
				
				-- дополнительная проверка: если Auto Armor выключился, сбрасываем состояние
				if not armor_blocking and autostomp_state.was_active and not active then
					autostomp_state.last_sync = 0
					autostomp_state.last_stomp = 0
				end
				if active then
					-- поддерживаем/применяем noclip для актуальной цели каждый кадр
					apply_target_noclip(target)
					autostomp_state.was_active = true
					
					-- периодическая синхронизация с игроком для снижения уязвимости
					local now = os.clock()
					if (now - autostomp_state.last_sync) >= autostomp_state.sync_interval then
						autostomp_state.last_sync = now
						pcall(function()
							if _G.DesyncLibrary and _G.DesyncLibrary.SynchronizeSyncWithPlayer then
								_G.DesyncLibrary.SynchronizeSyncWithPlayer()
							end
						end)
						-- vars.task.wait(0.1) -- убираем wait из Heartbeat цикла
					end
					
					-- постоянное обновление позиции десинка к актуальной части
					local torso_cf = get_target_torso_position(target)
					if torso_cf then
						pcall(function()
							if _G.DesyncLibrary and _G.DesyncLibrary.movedesyncto then
								_G.DesyncLibrary.movedesyncto(torso_cf.X, torso_cf.Y + autostomp_state.y_offset, torso_cf.Z)
							end
						end)
					end
					-- ограничение частоты события Stomp
					local now = os.clock()
					local interval = 1 / math.max(1, autostomp_state.stomp_rate)
					if (now - autostomp_state.last_stomp) >= interval then
						autostomp_state.last_stomp = now
						pcall(function()
							local mainEvent = game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent")
							if mainEvent then
								mainEvent:FireServer("Stomp")
							end
						end)
					end
				else
					-- выход из активного состояния
					if autostomp_state.was_active then
						restore_target_noclip()
						pcall(function()
							if _G.DesyncLibrary and _G.DesyncLibrary.SynchronizeSyncWithPlayer then
								_G.DesyncLibrary.SynchronizeSyncWithPlayer()
							end
						end)
						autostomp_state.was_active = false
					end
				end
			end)
		end
		
		-- остановка автостомпа
		local function stop_autostomp()
			-- legacy остановка таска
			if autostomp_state.loop_conn then
				vars.task.cancel(autostomp_state.loop_conn)
				autostomp_state.loop_conn = nil
			end
			-- отключаем Heartbeat
			if autostomp_state.hb_conn then
				autostomp_state.hb_conn:Disconnect()
				autostomp_state.hb_conn = nil
			end
			-- восстановим коллизии и синхронизируемся
			restore_target_noclip()
			pcall(function()
				if _G.DesyncLibrary and _G.DesyncLibrary.SynchronizeSyncWithPlayer then
					_G.DesyncLibrary.SynchronizeSyncWithPlayer()
				end
			end)
			autostomp_state.was_active = false
			desync_priority_state.autostomp_active = false
		end
		
		-- UI элемент
		local autostomp_toggle = DesyncSec:toggle({
			name = "AutoStomp",
			flag = "autostomp_enabled",
			default = false,
			callback = function(enabled)
				autostomp_state.enabled = enabled
				if enabled then
					start_autostomp()
				else
					stop_autostomp()
				end
			end
		})

		-- зависимые элементы для AutoStomp
		local as_dep = DesyncSec:dependency_box()
		as_dep:setup_dependencies({ { autostomp_toggle, true } })
		as_dep:slider({
			name = "YOff",
			flag = "autostomp_y_offset",
			min = -1,
			max = 3,
			default = 0,
			interval = 0.01,
			callback = function(v)
				autostomp_state.y_offset = v
			end
		})
	end
	-- autostomp system end

	-- voiding system start
	do
		local voiding_state = {
			enabled = false,
			hb_conn = nil,
			mode = "VoidStatic",
		}

		-- генераторы огромных случайных значений (без бесконечности)
		local function rand_huge_abs()
			-- 1e21 как достаточно большой масштаб (миллиарды/триллионы+)
			return vars.math.random() * 1e21
		end
		local function rand_huge_signed()
			return (vars.math.random() < 0.5 and -1 or 1) * rand_huge_abs()
		end

		local function start_voiding()
			if voiding_state.hb_conn then return end
			voiding_state.hb_conn = vars.run.Heartbeat:Connect(function()
				-- Приоритеты: 1) AutoArmor busy, 2) AutoStomp active, 3) Voiding
				local blocked = (auto_armor_state.busy == true) or (desync_priority_state.autostomp_active == true)
				if voiding_state.enabled and not blocked then
					pcall(function()
						if _G.DesyncLibrary and _G.DesyncLibrary.movedesyncto then
							local m = voiding_state.mode
							local x, y, z
							if m == "VoidStatic" then
								x, y, z = -18e18, -18e18, -18e18
							elseif m == "VoidRandom" then
								-- любой рандом, очень большие значения; Y всегда вниз
								x = rand_huge_signed()
								y = -rand_huge_abs()
								z = rand_huge_signed()
							elseif m == "SkyStatic" then
								x, y, z = 18e20, 18e20, 18e20
							elseif m == "SkyRandom" then
								-- любой рандом, очень большие значения; Y всегда вверх
								x = rand_huge_signed()
								y = rand_huge_abs()
								z = rand_huge_signed()
							elseif m == "WorldRandom" then
								-- полный 3D рандом огромных значений
								x = rand_huge_signed()
								y = rand_huge_signed()
								z = rand_huge_signed()
							elseif m == "Infinity" then
								x = vars.math.huge
								y = vars.math.huge
								z = -vars.math.huge
							else
								x, y, z = -18e18, -18e18, -18e18
							end
							_G.DesyncLibrary.movedesyncto(x, y, z)
						end
					end)
				end
			end)
		end

		local function stop_voiding()
			if voiding_state.hb_conn then
				voiding_state.hb_conn:Disconnect()
				voiding_state.hb_conn = nil
			end
			-- при выключении возвращаем десинк к игроку
			local blocked = (auto_armor_state.busy == true) or (desync_priority_state.autostomp_active == true)
			if not blocked then
				pcall(function()
					local lib = _G.DesyncLibrary
					if lib and lib.SynchronizeSyncWithPlayer then
						lib.SynchronizeSyncWithPlayer()
						return
					end
					-- fallback: вернуть десинк в позицию HRP локального игрока
					if lib and lib.movedesyncto then
						local lp = game and game.Players and game.Players.LocalPlayer
						local char = lp and lp.Character
						local hrp = char and char:FindFirstChild("HumanoidRootPart")
						if hrp then
							local p = hrp.Position
							lib.movedesyncto(p.X, p.Y, p.Z)
						end
					end
				end)
			end
		end

		-- UI элемент
		local voiding_toggle = DesyncSec:toggle({
			name = "Voiding",
			flag = "voiding_enabled",
			default = false,
			callback = function(state)
				voiding_state.enabled = state
				if state then
					start_voiding()
				else
					stop_voiding()
				end
			end
		})

		-- зависимые элементы для Voiding
		local void_dep = DesyncSec:dependency_box()
		void_dep:setup_dependencies({ { voiding_toggle, true } })
		void_dep:dropdown({
			name = "Mode",
			flag = "voiding_mode",
			items = { "VoidStatic", "VoidRandom", "SkyStatic", "SkyRandom", "WorldRandom", "Infinity" },
			callback = function(v)
				voiding_state.mode = v
			end
		})

	end
	-- voiding system end
	
	-- movement system start
	do
		local movement_col = Misc:column()
		local MovementSec = movement_col:section({ name = "Movement" })
		
		-- SpeedHack система с двумя состояниями
		local speedhack_state = {
			enabled = false,  -- toggle state
			active = false,   -- keybind state
			method = "Velocity",
			connection = nil,
			options = {
				Value = { Value = 16 },
				TPTiming = 0,
				TPFrequency = { Value = 0.1 },
				WallCheck = { Enabled = false },
				rayCheck = (vars and vars.RaycastParams and vars.RaycastParams.new()) or RaycastParams.new(),

				PulseLength = { Value = 0.5 },
				PulseDelay = { Value = 0.2 }
			},
			-- параметры коррекции движения
			correction = {
				mode = "None",      -- None | Lerp
				last_dir = nil       -- для сглаживания (Lerp)
			}
		}
		
		-- SpeedMethods список и таблица
		local SpeedMethodList = {'Velocity'}
		-- MoveFix список коррекций движения
		local CorrectionList = {'None','Lerp'}
		local SpeedMethods = {
			Velocity = function(options, moveDirection)
				local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
				if not root then return end
				root.AssemblyLinearVelocity = (moveDirection * options.Value.Value) + vars.Vector3.new(0, root.AssemblyLinearVelocity.Y, 0)
			end,
			Impulse = function(options, moveDirection)
				local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
				if not root then return end
				local diff = ((moveDirection * options.Value.Value) - root.AssemblyLinearVelocity) * vars.Vector3.new(1, 0, 1)
				if diff.Magnitude > (moveDirection == vars.Vector3.new(0, 0, 0) and 10 or 2) then
					root:ApplyImpulse(diff * root.AssemblyMass)
				end
			end,
			CFrame = function(options, moveDirection, dt)
				local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
				local humanoid = lp.Character and lp.Character:FindFirstChildOfClass("Humanoid")
				if not root or not humanoid then return end
				local dest = (moveDirection * vars.math.max(options.Value.Value - humanoid.WalkSpeed, 0) * dt)
				if options.WallCheck.Enabled then
					options.rayCheck.FilterDescendantsInstances = {lp.Character, vars.camera}
					options.rayCheck.CollisionGroup = root.CollisionGroup
					local ray = vars.workspace:Raycast(root.Position, dest, options.rayCheck)
					if ray then
						dest = ((ray.Position + ray.Normal) - root.Position)
					end
				end
				root.CFrame = root.CFrame + dest
			end,
			TP = function(options, moveDirection)
				if options.TPTiming < vars.tick() then
					options.TPTiming = vars.tick() + options.TPFrequency.Value
					SpeedMethods.CFrame(options, moveDirection, 1)
				end
			end,
			Pulse = function(options, moveDirection)
				local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
				local humanoid = lp.Character and lp.Character:FindFirstChildOfClass("Humanoid")
				if not root or not humanoid then return end
				local dt = vars.math.max(options.Value.Value - humanoid.WalkSpeed, 0)
				dt = dt * (1 - vars.math.min((vars.tick() % (options.PulseLength.Value + options.PulseDelay.Value)) / options.PulseLength.Value, 1))
				root.AssemblyLinearVelocity = (moveDirection * (humanoid.WalkSpeed + dt)) + vars.Vector3.new(0, root.AssemblyLinearVelocity.Y, 0)
			end
		}

		-- коррекция направления движения для более плавного перемещения
		local function apply_correction(dir, dt, root, humanoid)
			local mode = speedhack_state.correction.mode
			if mode == "None" then return dir end
			-- нормализуем вход, избегая NaN
			if dir.Magnitude > 1e-3 then dir = dir.Unit else return dir end
			if mode == "Lerp" then
				local last = speedhack_state.correction.last_dir or dir
				local alpha = ((vars and vars.math and vars.math.clamp) or math.clamp)((dt * 60) * 0.18, 0, 1)
				local new = last:Lerp(dir, alpha)
				speedhack_state.correction.last_dir = new
				return (new.Magnitude > 1e-3) and new.Unit or dir
			end
			return dir
		end
		
		-- добавляем все методы в список
		local tfind = (vars and vars.table and vars.table.find) or table.find
		local tinsert = (vars and vars.table and vars.table.insert) or table.insert
		for name in pairs(SpeedMethods) do
			if not tfind(SpeedMethodList, name) then
				tinsert(SpeedMethodList, name)
			end
		end
		
		local function get_move_direction()
			local humanoid = lp.Character and lp.Character:FindFirstChildOfClass("Humanoid")
			if not humanoid then return vars.Vector3.new(0, 0, 0) end
			return humanoid.MoveDirection
		end
		
		local function start_speedhack()
			-- already connected and alive
			if speedhack_state.connection and speedhack_state.connection.Connected then return end
			-- guards
			if not (vars and vars.run) then
				if flags and flags["Debug"] then warn("[SpeedHack] RunService missing; abort start") end
				return
			end
			if not lp then return end
			-- connect Heartbeat
			speedhack_state.connection = vars.run.Heartbeat:Connect(function(dt)
				-- runtime guards
				if not (speedhack_state.enabled and speedhack_state.active) then return end
				local lchar = lp.Character
				local humanoid = lchar and lchar:FindFirstChildOfClass("Humanoid")
				local root = lchar and lchar:FindFirstChild("HumanoidRootPart")
				if not (humanoid and root) then return end
				local method = SpeedMethods[speedhack_state.method]
				if method then
					local moveDirection = humanoid.MoveDirection or vars.Vector3.new(0, 0, 0)
					moveDirection = apply_correction(moveDirection, dt, root, humanoid)
					method(speedhack_state.options, moveDirection, dt)
				end
			end)
			if flags and flags["Debug"] then print("[SpeedHack] started (", speedhack_state.method, ")") end
		end
		
		local function stop_speedhack()
			if speedhack_state.connection then
				pcall(function()
					if speedhack_state.connection.Connected then speedhack_state.connection:Disconnect() end
				end)
				speedhack_state.connection = nil
				if flags and flags["Debug"] then print("[SpeedHack] stopped") end
			end
		end

		-- UI элементы SpeedHack
		local speedhack_toggle = MovementSec:toggle({
			name = "Speed",
			flag = "SpeedHack_Toggle",
			default = false,
			callback = function(val)
				speedhack_state.enabled = val
				if val then
					start_speedhack()
				else
					stop_speedhack()
				end
				if flags and flags["Debug"] then
					print("[SpeedHack] enabled:", val)
				end
			end,
		})

		-- начальное состояние флага активности для зависимостей
		if flags then flags["SpeedHack_Active"] = speedhack_state.active or false end
		
		local speedhack_keybind = speedhack_toggle:keybind({
			name = "Speed",
			flag = "SpeedHack_Keybind",
			default = "v",
			callback = function()
				speedhack_state.active = not speedhack_state.active
				if flags then flags["SpeedHack_Active"] = speedhack_state.active end
				if library and library.update_dependencies then library:update_dependencies() end
				if flags and flags["Debug"] then
					print("[SpeedHack] active:", speedhack_state.active)
				end
			end,
		})

		-- зависимые элементы для SpeedHack (видимы только при Enabled && Active)
		local speedhack_dep = MovementSec:dependency_box()
		speedhack_dep:setup_dependencies({ { speedhack_toggle, true } })
		
		speedhack_dep:textbox({
			name = "Speed",
			flag = "SpeedHack_Value",
			default = "16",
			placeholder = "16",
			callback = function(val)
				local value = tonumber(val) or 16
				speedhack_state.options.Value.Value = value
			end,
		})
		
		speedhack_dep:dropdown({
			name = "Method",
			flag = "SpeedHack_Method",
			items = SpeedMethodList,
			default = "Velocity",
			callback = function(val)
				speedhack_state.method = val
				if library and library.update_dependencies then library:update_dependencies() end
			end,
		})
		
		-- тип коррекции движения (MoveFix)
		speedhack_dep:dropdown({
			name = "MoveFix",
			flag = "SpeedHack_MoveFix",
			items = CorrectionList,
			default = "None",
			callback = function(val)
				speedhack_state.correction.mode = val
				-- сбрасываем историю сглаживания при смене режима
				speedhack_state.correction.last_dir = nil
			end,
		})
		
		-- дополнительные элементы (видимы при Enabled)
		local wall_dep = MovementSec:dependency_box()
		wall_dep:setup_dependencies({ { speedhack_toggle, true } })
		
		wall_dep:toggle({
			name = "WallCheck",
			flag = "SpeedHack_WallCheck",
			default = false,
			callback = function(val)
				speedhack_state.options.WallCheck.Enabled = val
			end,
		})
		
		local tp_dep = MovementSec:dependency_box()
		tp_dep:setup_dependencies({ { speedhack_toggle, true }, { "SpeedHack_Method", "TP" } })
		
		tp_dep:slider({
			name = "TPFreq",
			flag = "SpeedHack_TPFreq",
			min = 0.05,
			max = 1,
			default = 0.1,
			decimals = 2,
			callback = function(val)
				speedhack_state.options.TPFrequency.Value = val
			end,
		})
		
		local pulse_dep = MovementSec:dependency_box()
		pulse_dep:setup_dependencies({ { speedhack_toggle, true }, { "SpeedHack_Method", "Pulse" } })
		
		pulse_dep:slider({
			name = "PulseLen",
			flag = "SpeedHack_PulseLen",
			min = 0.1,
			max = 5,
			default = 0.5,
			decimals = 1,
			callback = function(val)
				speedhack_state.options.PulseLength.Value = val
			end,
		})
		
		pulse_dep:slider({
			name = "PulseDly",
			flag = "SpeedHack_PulseDly",
			min = 0.1,
			max = 1,
			default = 0.2,
			decimals = 2,
			callback = function(val)
				speedhack_state.options.PulseDelay.Value = val
			end,
		})

		-- сброс активного состояния и соединений при смене персонажа/смерти
		local function bind_character(char)
			-- небольшой тик, чтобы дать прогрузиться
			if vars and vars.run then vars.run.Heartbeat:Wait() end
			speedhack_state.active = false
			if flags then flags["SpeedHack_Active"] = false end
			if library and library.update_dependencies then library:update_dependencies() end
			stop_speedhack()
			-- если тумблер включен, после респавна пересоздаём коннект
			if speedhack_state.enabled then
				start_speedhack()
			end
			-- bind Humanoid.Died
			local hum = char and char:FindFirstChildOfClass("Humanoid")
			if hum then
				if speedhack_state._died_conn then pcall(function() speedhack_state._died_conn:Disconnect() end) end
				speedhack_state._died_conn = hum.Died:Connect(function()
					if flags and flags["Debug"] then print("[SpeedHack] died -> reset active & stop") end
					speedhack_state.active = false
					if flags then flags["SpeedHack_Active"] = false end
					if library and library.update_dependencies then library:update_dependencies() end
					stop_speedhack()
				end)
			end
		end

		-- initial bind and signals
		if lp then
			if lp.Character then bind_character(lp.Character) end
			if speedhack_state._char_added then pcall(function() speedhack_state._char_added:Disconnect() end) end
			speedhack_state._char_added = lp.CharacterAdded:Connect(function(char)
				if flags and flags["Debug"] then print("[SpeedHack] CharacterAdded") end
				bind_character(char)
			end)
			if speedhack_state._char_removing then pcall(function() speedhack_state._char_removing:Disconnect() end) end
			speedhack_state._char_removing = lp.CharacterRemoving:Connect(function()
				if flags and flags["Debug"] then print("[SpeedHack] CharacterRemoving") end
				speedhack_state.active = false
				if flags then flags["SpeedHack_Active"] = false end
				if library and library.update_dependencies then library:update_dependencies() end
				stop_speedhack()
			end)
		end

		-- flyhack system start
		-- используем существующую секцию Movement (MovementSec) для UI
		local flyhack_state = {
			enabled = false,
			active = false,
			connection = nil,
			options = {
				Speed = { Value = 1.5 }, -- множитель; итоговая скорость = Speed * 50
			}
		}

		local function V3(x, y, z)
			local ctor = (vars and vars.Vector3 and vars.Vector3.new) or (Vector3 and Vector3.new)
			return ctor and ctor(x, y, z) or nil
		end

		local function set_noclip(character, state)
			if not character then return end
			for _, part in ipairs(character:GetDescendants()) do
				if part:IsA("BasePart") then
					if state then
						if part:GetAttribute("OriginalCollision") == nil then
							part:SetAttribute("OriginalCollision", part.CanCollide)
							part:SetAttribute("OriginalTouch", part.CanTouch)
							part:SetAttribute("OriginalQuery", part.CanQuery)
						end
						part.CanCollide, part.CanTouch, part.CanQuery = false, false, false
					else
						if part:GetAttribute("OriginalCollision") ~= nil then
							part.CanCollide = part:GetAttribute("OriginalCollision")
							part.CanTouch = part:GetAttribute("OriginalTouch")
							part.CanQuery = part:GetAttribute("OriginalQuery")
							part:SetAttribute("OriginalCollision", nil)
							part:SetAttribute("OriginalTouch", nil)
							part:SetAttribute("OriginalQuery", nil)
						end
					end
				end
			end
		end

		local function start_flyhack()
			if flyhack_state.connection and flyhack_state.connection.Connected then return end
			if not (vars and vars.run) then return end
			flyhack_state.connection = vars.run.Stepped:Connect(function()
				if not (flyhack_state.enabled and flyhack_state.active) then return end
				local char = lp and lp.Character
				if not char then return end
				set_noclip(char, true)
				local hrp = char:FindFirstChild("HumanoidRootPart")
				local hum = char:FindFirstChildOfClass("Humanoid")
				if not (hrp and hum) then return end
				local speed = (flyhack_state.options.Speed.Value or 1.5) * 50
				local velocity = V3(0, 0, 0)
				local UIS = (vars and vars.uis) or game:GetService("UserInputService")
				local Cam = (vars and vars.cam) or (workspace and workspace.CurrentCamera)
				if not UIS or not Cam then return end
				if UIS:IsKeyDown(Enum.KeyCode.Space) then velocity = velocity + V3(0, speed, 0) end
				if UIS:IsKeyDown(Enum.KeyCode.LeftControl) then velocity = velocity + V3(0, -speed, 0) end
				if UIS:IsKeyDown(Enum.KeyCode.W) then velocity = velocity + (Cam.CFrame.LookVector * speed) end
				if UIS:IsKeyDown(Enum.KeyCode.S) then velocity = velocity + (Cam.CFrame.LookVector * -speed) end
				if UIS:IsKeyDown(Enum.KeyCode.D) then velocity = velocity + (Cam.CFrame.RightVector * speed) end
				if UIS:IsKeyDown(Enum.KeyCode.A) then velocity = velocity + (Cam.CFrame.RightVector * -speed) end
				-- применяем скорость и держим состояние свободного падения
				hrp.Velocity = velocity
				pcall(function() hum:ChangeState(Enum.HumanoidStateType.Freefall) end)
			end)
			if flags and flags["Debug"] then print("[FlyHack] started") end
		end

		local function stop_flyhack()
			if flyhack_state.connection then
				pcall(function()
					if flyhack_state.connection.Connected then flyhack_state.connection:Disconnect() end
				end)
				flyhack_state.connection = nil
			end
			local char = lp and lp.Character
			set_noclip(char, false)
			if char then
				local hrp = char:FindFirstChild("HumanoidRootPart")
				local hum = char:FindFirstChildOfClass("Humanoid")
				if hrp then
					-- быстрая фиксация: сброс XZ-компонент за один Stepped тик, как в референс-логике
					hrp.Velocity = V3(0, -2, 0)
					local tmp
					tmp = ((vars and vars.run and vars.run.Stepped) or game:GetService("RunService").Stepped):Connect(function()
						if not hrp or not hrp.Parent then if tmp and tmp.Connected then tmp:Disconnect() end return end
						hrp.Velocity = V3(0, hrp.Velocity.Y, 0)
						if tmp and tmp.Connected then tmp:Disconnect() end
					end)
				end
				if hum then pcall(function() hum:ChangeState(Enum.HumanoidStateType.Landing) end) end
			end
			if flags and flags["Debug"] then print("[FlyHack] stopped") end
		end

		-- мягкая остановка при отключении по кейбинду (не трогаем основное подключение)
		local function soft_stop_flyhack()
			local char = lp and lp.Character
			-- вернуть коллизии сразу, чтобы не оставаться в noclip
			set_noclip(char, false)
			if not char then return end
			local hrp = char:FindFirstChild("HumanoidRootPart")
			local hum = char:FindFirstChildOfClass("Humanoid")
			if hrp then
				-- полный сброс линейной/угловой скорости (Assembly*) + fallback на Velocity
				pcall(function() hrp.AssemblyLinearVelocity = V3(0, 0, 0) end)
				pcall(function() hrp.AssemblyAngularVelocity = V3(0, 0, 0) end)
				-- небольшой импульс вниз и зануление XZ на следующий тик для устранения дрейфа
				hrp.Velocity = V3(0, -2, 0)
				local tmp
				tmp = ((vars and vars.run and vars.run.Stepped) or game:GetService("RunService").Stepped):Connect(function()
					if not hrp or not hrp.Parent then if tmp and tmp.Connected then tmp:Disconnect() end return end
					local vy = hrp.Velocity.Y
					pcall(function() hrp.AssemblyLinearVelocity = V3(0, vy, 0) end)
					hrp.Velocity = V3(0, vy, 0)
					if tmp and tmp.Connected then tmp:Disconnect() end
				end)
			end
			if hum then pcall(function() hum:ChangeState(Enum.HumanoidStateType.Landing) end) end
			if flags and flags["Debug"] then print("[FlyHack] soft-stopped (keybind)") end
		end

		-- UI элементы FlyHack
		local fly_toggle = MovementSec:toggle({
			name = "Flight",
			flag = "FlyHack_Toggle",
			default = false,
			callback = function(val)
				flyhack_state.enabled = val
				if val then start_flyhack() else stop_flyhack() end
				if flags and flags["Debug"] then print("[FlyHack] enabled:", val) end
			end
		})

		if flags then flags["FlyHack_Active"] = flyhack_state.active or false end
		local fly_keybind = fly_toggle:keybind({
			name = "Flight",
			flag = "FlyHack_Keybind",
			default = "b",
			callback = function()
				flyhack_state.active = not flyhack_state.active
				-- если выключили по кейбинду, мягко сбрасываем скорости и возвращаем коллизии
				if not flyhack_state.active then
					soft_stop_flyhack()
				end
				if flags then flags["FlyHack_Active"] = flyhack_state.active end
				if library and library.update_dependencies then library:update_dependencies() end
				if flags and flags["Debug"] then print("[FlyHack] active:", flyhack_state.active) end
			end
		})

		local fly_dep = MovementSec:dependency_box()
		fly_dep:setup_dependencies({ { fly_toggle, true } })
		fly_dep:textbox({
			name = "Spd",
			flag = "FlyHack_Speed",
			default = tostring(flyhack_state.options.Speed.Value or 1.5),
			callback = function(v)
				local num = tonumber(v)
				if num then flyhack_state.options.Speed.Value = num end
			end
		})

		-- привязки к персонажу
		local function bind_fly_character(char)
			if vars and vars.run then vars.run.Heartbeat:Wait() end
			flyhack_state.active = false
			if flags then flags["FlyHack_Active"] = false end
			if library and library.update_dependencies then library:update_dependencies() end
			stop_flyhack()
			if flyhack_state.enabled then start_flyhack() end
			local hum = char and char:FindFirstChildOfClass("Humanoid")
			if hum then
				if flyhack_state._died_conn then pcall(function() flyhack_state._died_conn:Disconnect() end) end
				flyhack_state._died_conn = hum.Died:Connect(function()
					if flags and flags["Debug"] then print("[FlyHack] died -> reset active & stop") end
					flyhack_state.active = false
					if flags then flags["FlyHack_Active"] = false end
					if library and library.update_dependencies then library:update_dependencies() end
					stop_flyhack()
				end)
			end
		end

		if lp then
			if lp.Character then bind_fly_character(lp.Character) end
			if flyhack_state._char_added then pcall(function() flyhack_state._char_added:Disconnect() end) end
			flyhack_state._char_added = lp.CharacterAdded:Connect(function(char)
				if flags and flags["Debug"] then print("[FlyHack] CharacterAdded") end
				bind_fly_character(char)
			end)
			if flyhack_state._char_removing then pcall(function() flyhack_state._char_removing:Disconnect() end) end
			flyhack_state._char_removing = lp.CharacterRemoving:Connect(function()
				if flags and flags["Debug"] then print("[FlyHack] CharacterRemoving") end
				flyhack_state.active = false
				if flags then flags["FlyHack_Active"] = false end
				if library and library.update_dependencies then library:update_dependencies() end
				stop_flyhack()
			end)
  		end
  		-- flyhack system end
 
		-- spider system start
		do
			-- состояние и сервисы
			local ws = (vars and vars.workspace) or workspace
			local run = (vars and vars.run) or game:GetService("RunService")
			local uis = (vars and vars.uis) or game:GetService("UserInputService")
			local cam = (vars and (vars.camera or vars.cam)) or (ws and ws.CurrentCamera)
			local rp = ((vars and vars.RaycastParams and vars.RaycastParams.new) and vars.RaycastParams.new()) or RaycastParams.new()
			rp.RespectCanCollide = true

			local spider_state = {
				enabled = false,
				connection = nil,
				_ib = nil,
				_ie = nil,
				_died_conn = nil,
				_char_added = nil,
				_char_removing = nil,
				shift_down = false,
				active = false,
				mode = "Velocity", -- Velocity | Impulse | CFrame | Climbing
				value = 20,
				state_enabled = true,
				truss = nil,
				rp = rp,
			}

			local function ensure_truss(parent_when_on)
				if not spider_state.truss then
					local t = Instance.new("TrussPart")
					t.Size = Vector3.new(2, 2, 2)
					t.Transparency = 1
					t.Anchored = true
					spider_state.truss = t
				end
				spider_state.truss.Parent = (spider_state.enabled and parent_when_on) or nil
			end

			local function destroy_truss()
				local t = spider_state.truss
				if t then pcall(function() t:Destroy() end) end
				spider_state.truss = nil
			end

			local function start_spider()
				if spider_state.connection and spider_state.connection.Connected then return end
				local signal = (run and (run.PreSimulation or run.Stepped or run.Heartbeat))
				spider_state.connection = signal:Connect(function(dt)
					if not spider_state.enabled then return end
					local char = lp and lp.Character
					local hum = char and char:FindFirstChildOfClass("Humanoid")
					local root = char and char:FindFirstChild("HumanoidRootPart")
					if not (hum and root) then return end

					local chars = { cam, char, spider_state.truss }
					if spider_state.rp then
						spider_state.rp.FilterDescendantsInstances = chars
						pcall(function() spider_state.rp.CollisionGroup = root.CollisionGroup end)
					end

					local shift_down = (uis and (uis:IsKeyDown(Enum.KeyCode.LeftShift) or uis:IsKeyDown(Enum.KeyCode.RightShift))) or spider_state.shift_down
					if shift_down then
						spider_state.active = false
						return
					end

					if spider_state.mode ~= "Climbing" then
						local moveDir = hum.MoveDirection
						if moveDir.Magnitude < 0.05 then
							spider_state.active = false
							return
						end
						local origin = root.Position - Vector3.new(0, (hum.HipHeight or 2) - 0.5, 0)
						local direction = moveDir.Unit * 1 -- фиксированная дистанция 1
						local ray = ws:Raycast(origin, direction, spider_state.rp)
						if spider_state.active and not ray then
							pcall(function()
								local v = root.AssemblyLinearVelocity
								root.AssemblyLinearVelocity = Vector3.new(v.X, 0, v.Z)
							end)
						end
						spider_state.active = ray ~= nil
						if spider_state.active and ray.Normal.Y == 0 then
							if spider_state.state_enabled then
								pcall(function() hum:ChangeState(Enum.HumanoidStateType.Climbing) end)
							end
							pcall(function()
								local vel = root.AssemblyLinearVelocity
								root.AssemblyLinearVelocity = Vector3.new(vel.X, 0, vel.Z)
							end)
							if spider_state.mode == "CFrame" then
								root.CFrame = root.CFrame * CFrame.new(0, spider_state.value * dt, 0)
							elseif spider_state.mode == "Impulse" then
								root:ApplyImpulse(Vector3.new(0, spider_state.value, 0) * root.AssemblyMass)
							else -- Velocity
								pcall(function()
									local vel = root.AssemblyLinearVelocity
									root.AssemblyLinearVelocity = vel + Vector3.new(0, spider_state.value, 0)
								end)
							end
						end
					else
						local origin = root.Position - Vector3.new(0, (hum.HipHeight or 2) - 0.5, 0)
						local direction = root.CFrame.LookVector * 1 -- фиксированная дистанция 1
						local ray = ws:Raycast(origin, direction, spider_state.rp)
						if ray and not shift_down then
							ensure_truss(cam)
							local pos = (ray.Position - ray.Normal * 0.9)
							spider_state.truss.Position = pos or Vector3.new(0, 0, 0)
						else
							if spider_state.truss then
								spider_state.truss.Position = Vector3.new(0, 0, 0)
							end
						end
					end
				end)

				-- Shift override
				if not (spider_state._ib and spider_state._ib.Connected) then
					spider_state._ib = uis.InputBegan:Connect(function(input, gp)
						if gp then return end
						if input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.RightShift then
							spider_state.shift_down = true
						end
					end)
				end
				if not (spider_state._ie and spider_state._ie.Connected) then
					spider_state._ie = uis.InputEnded:Connect(function(input)
						if input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.RightShift then
							spider_state.shift_down = false
						end
					end)
				end

				if spider_state.mode == "Climbing" then ensure_truss(cam) else destroy_truss() end
			end

			local function stop_spider()
				if spider_state.connection then
					pcall(function()
						if spider_state.connection.Connected then spider_state.connection:Disconnect() end
					end)
					spider_state.connection = nil
				end
				if spider_state._ib then pcall(function() spider_state._ib:Disconnect() end); spider_state._ib = nil end
				if spider_state._ie then pcall(function() spider_state._ie:Disconnect() end); spider_state._ie = nil end
				if spider_state._died_conn then pcall(function() spider_state._died_conn:Disconnect() end); spider_state._died_conn = nil end
				spider_state.shift_down = false
				spider_state.active = false
				destroy_truss()
			end

			-- UI: Toggle + Dep
			local spider_toggle = MovementSec:toggle({
				name = "Spider",
				flag = "Spider_Toggle",
				default = false,
				callback = function(v)
					spider_state.enabled = v
					if v then start_spider() else stop_spider() end
					if library and library.update_dependencies then library:update_dependencies() end
				end
			})

			local spider_dep = MovementSec:dependency_box()
			spider_dep:setup_dependencies({ { spider_toggle, true } })

			spider_dep:dropdown({
				name = "Mode",
				flag = "Spider_Mode",
				items = { "Velocity", "Impulse", "CFrame", "Climbing" },
				default = spider_state.mode,
				callback = function(val)
					spider_state.mode = val
					local show = (val ~= "Climbing")
					if flags then flags["Spider_ShowControls"] = show end
					if spider_state.enabled then
						if val == "Climbing" then ensure_truss(cam) else destroy_truss() end
					end
					if library and library.update_dependencies then library:update_dependencies() end
				end
			})

			-- Блок контролов, видим только при Mode ~= Part
			if flags and flags["Spider_ShowControls"] == nil then flags["Spider_ShowControls"] = true end
			local ctrl_dep = MovementSec:dependency_box()
			ctrl_dep:setup_dependencies({ { spider_toggle, true }, { "Spider_ShowControls", true } })

			ctrl_dep:slider({
				name = "Val",
				flag = "Spider_Val",
				min = 1,
				max = 100,
				default = spider_state.value,
				decimals = 0,
				callback = function(val)
					spider_state.value = val
				end
			})

			ctrl_dep:toggle({
				name = "State",
				flag = "Spider_State",
				default = spider_state.state_enabled,
				callback = function(v)
					spider_state.state_enabled = v
				end
			})

			-- перепривязка к персонажу
			local function bind_spider_character(char)
				if run and run.Heartbeat then run.Heartbeat:Wait() end
				stop_spider()
				if spider_state.enabled then start_spider() end
				local hum = char and char:FindFirstChildOfClass("Humanoid")
				if hum then
					if spider_state._died_conn then pcall(function() spider_state._died_conn:Disconnect() end) end
					spider_state._died_conn = hum.Died:Connect(function()
						stop_spider()
					end)
				end
			end

			if lp then
				if lp.Character then bind_spider_character(lp.Character) end
				if spider_state._char_added then pcall(function() spider_state._char_added:Disconnect() end) end
				spider_state._char_added = lp.CharacterAdded:Connect(function(char)
					bind_spider_character(char)
				end)
				if spider_state._char_removing then pcall(function() spider_state._char_removing:Disconnect() end) end
				spider_state._char_removing = lp.CharacterRemoving:Connect(function()
					stop_spider()
				end)
			end
		end
		-- spider system end

		-- gravity system start
	do
	-- состояние и функции Gravity
	local ws = (vars and vars.workspace) or workspace
	local run = (vars and vars.run) or game:GetService("RunService")
	local function V3(x, y, z)
		local ctor = (vars and vars.Vector3 and vars.Vector3.new) or (Vector3 and Vector3.new)
		return ctor and ctor(x, y, z) or nil
	end
	local gravity_state = {
		enabled = false,
		mode = "Workspace", -- Workspace | Impulse | LinearVelocity
		value = 196.2,
		connection = nil,
		prop_conn = nil,
		changed = false,
		original = nil,
	}

	local function disconnect(sig)
		pcall(function()
			if sig and sig.Connected then sig:Disconnect() end
		end)
	end

	local function set_ws_gravity(val)
		if not ws then return end
		gravity_state.changed = true
		ws.Gravity = val
		gravity_state.changed = false
	end

	local function start_gravity()
		if not (run and ws) then return end
		-- сохранить оригинальную гравитацию один раз
		if gravity_state.original == nil then
			gravity_state.original = ws.Gravity
		end
		-- очистить старые подключения, если есть
		disconnect(gravity_state.connection)
		gravity_state.connection = nil
		disconnect(gravity_state.prop_conn)
		gravity_state.prop_conn = nil

		if gravity_state.mode == "Workspace" then
			set_ws_gravity(gravity_state.value)
			gravity_state.prop_conn = ws:GetPropertyChangedSignal("Gravity"):Connect(function()
				if gravity_state.changed then return end
				set_ws_gravity(gravity_state.value)
			end)
		else
			local signal = run.PreSimulation or run.Stepped
			gravity_state.connection = signal:Connect(function(dt)
				if not gravity_state.enabled then return end
				local char = lp and lp.Character
				local hum = char and char:FindFirstChildOfClass("Humanoid")
				local root = char and char:FindFirstChild("HumanoidRootPart")
				if not (hum and root) then return end
				if hum.FloorMaterial == Enum.Material.Air then
					local diff = (ws.Gravity - gravity_state.value)
					if gravity_state.mode == "Impulse" then
						root:ApplyImpulse(V3(0, dt * diff, 0) * root.AssemblyMass)
					else -- LinearVelocity
						local add = V3(0, dt * diff, 0)
						pcall(function()
							root.AssemblyLinearVelocity = root.AssemblyLinearVelocity + add
						end)
					end
				end
			end)
		end
	end

	local function stop_gravity()
		disconnect(gravity_state.connection)
		gravity_state.connection = nil
		disconnect(gravity_state.prop_conn)
		gravity_state.prop_conn = nil
		-- всегда восстанавливаем исходную гравитацию при выключении
		if gravity_state.original ~= nil and ws then
			pcall(function() ws.Gravity = gravity_state.original end)
		end
	end

	-- UI элементы Gravity
	local gravity_toggle = MovementSec:toggle({
		name = "Gravity",
		flag = "Gravity_Toggle",
		default = false,
		callback = function(val)
			gravity_state.enabled = val
			if val then start_gravity() else stop_gravity() end
		end
	})

	local gravity_dep = MovementSec:dependency_box()
	gravity_dep:setup_dependencies({ { gravity_toggle, true } })

	gravity_dep:dropdown({
		name = "Mode",
		flag = "Gravity_Mode",
		items = { "Workspace", "Impulse", "LinearVelocity" },
		default = "Workspace",
		callback = function(v)
			gravity_state.mode = v
			if gravity_state.enabled then
				stop_gravity()
				start_gravity()
			end
		end
	})

	gravity_dep:slider({
		name = "Grv",
		flag = "Gravity_Value",
		min = 0,
		max = 400,
		default = 196.2,
		decimals = 1,
		callback = function(val)
			gravity_state.value = val
			if gravity_state.enabled and gravity_state.mode == "Workspace" then
				set_ws_gravity(gravity_state.value)
			end
		end
	})
end
  -- gravity system end
  
 	-- no slow system start
 	do
 		local noslow_state = {
			enabled = false,
			connection = nil,
			min = 16,
		}
 		
 		local noslow_toggle = MovementSec:toggle({
			name = "NoSlow",
			flag = "NoSlow_Toggle",
			default = false,
			callback = function(val)
				noslow_state.enabled = val
				if val then
					local rs = (vars and vars.rs) or game:GetService("RunService")
					-- подключаемся, если ещё не подключены
					if not (noslow_state.connection and noslow_state.connection.Connected) then
						noslow_state.connection = rs.Heartbeat:Connect(function()
							-- nil-проверки: lp/char/hum/root
							local char = lp and lp.Character
							if not char then return end
							local hum = char:FindFirstChildOfClass("Humanoid")
							if not hum then return end
							local root = hum.RootPart or char:FindFirstChild("HumanoidRootPart")
							if not root then return end
							-- только когда есть направление движения
							local dir = hum.MoveDirection
							if dir.Magnitude > 0 then
								local vel = root.AssemblyLinearVelocity
								local horizMag = (Vector3.new(vel.X, 0, vel.Z)).Magnitude
								if horizMag + 1e-3 < noslow_state.min then
									local u = dir.Unit
									root.AssemblyLinearVelocity = Vector3.new(u.X * noslow_state.min, vel.Y, u.Z * noslow_state.min)
								end
							end
						end)
					end
				else
					-- выключение: корректная очистка
					if noslow_state.connection then
						pcall(function()
							noslow_state.connection:Disconnect()
						end)
						noslow_state.connection = nil
					end
				end
			end
		})
	end
	-- highjump system start
	do
		local uis = (vars and vars.uis) or game:GetService("UserInputService")
		local run = (vars and vars.run) or game:GetService("RunService")
		local ws = (vars and vars.workspace) or workspace

		local highjump_state = {
			enabled = false,
			mode = "Velocity", -- UI only
			power = 50, -- JumpPower value from textbox
			connection = nil,
		}

		local function jump_once()
			local char = lp and lp.Character
			local hum = char and char:FindFirstChildOfClass("Humanoid")
			if not hum then return end
			local state = hum:GetState()
			if state ~= Enum.HumanoidStateType.Running and state ~= Enum.HumanoidStateType.Landed then return end
			local jp = tonumber(highjump_state.power) or 50
			pcall(function()
				if hum.UseJumpPower ~= false then
					hum.JumpPower = jp
				else
					-- fallback: approximate JumpHeight if power mode is disabled
					hum.JumpHeight = math.max(1, jp / 7)
				end
				-- trigger jump
				hum:ChangeState(Enum.HumanoidStateType.Jumping)
			end)
		end

		local function start_highjump()
			if highjump_state.connection and highjump_state.connection.Connected then return end
			highjump_state.connection = run.RenderStepped:Connect(function()
				if not highjump_state.enabled then return end
				if uis:GetFocusedTextBox() then return end
				if uis:IsKeyDown(Enum.KeyCode.Space) then
					jump_once()
				end
			end)
		end

		local function stop_highjump()
			if highjump_state.connection then
				pcall(function()
					if highjump_state.connection.Connected then highjump_state.connection:Disconnect() end
				end)
				highjump_state.connection = nil
			end
		end

		-- UI
		local hj_toggle = MovementSec:toggle({
			name = "HighJump",
			flag = "HighJump_Toggle",
			default = false,
			callback = function(v)
				highjump_state.enabled = v
				if v then start_highjump() else stop_highjump() end
				if library and library.update_dependencies then library:update_dependencies() end
			end
		})

		local hj_dep = MovementSec:dependency_box()
		hj_dep:setup_dependencies({ { hj_toggle, true } })

		hj_dep:dropdown({
			name = "Mode",
			flag = "HighJump_Mode",
			items = { "Impulse", "Velocity", "CFrame", "Instant" },
			default = highjump_state.mode,
			callback = function(val)
				highjump_state.mode = val
			end
		})

		hj_dep:textbox({
			name = "Pwr",
			flag = "HighJump_Power",
			default = tostring(highjump_state.power),
			callback = function(text)
				local num = tonumber(text)
				if not num then return end
				-- clamp reasonable range
				if num < 1 then num = 1 end
				if num > 300 then num = 300 end
				highjump_state.power = num
			end
		})
	end
	-- highjump system end

	-- no jump cooldown system start
	do
		local nojump_state = {
			enabled = false,
			hooked = false,
			old = nil,
			conn = nil,
			baselineJP = nil,
			baselineJH = nil,
		}

		local function ensure_loaded()
			-- auto-exec friendly wait style
			local ok, loaded = pcall(function()
				return game and game.IsLoaded and (game.IsLoaded(game) or game:IsLoaded())
			end)
			if not ok or not loaded then
				pcall(function()
					if game and game.Loaded then
						if game.Loaded.Wait then game.Loaded.Wait(game.Loaded) else game.Loaded:Wait() end
					end
				end)
			end
		end

		local function install_hook_once()
			if nojump_state.hooked then return end
			if type(hookmetamethod) ~= "function" then return end
			-- cache IsA for speed and compat
			local IsA = (game and game.IsA) or function(obj, cls)
				local ok, res = pcall(function()
					return obj and obj.IsA and obj:IsA(cls)
				end)
				return ok and res or false
			end
			local raw_newindex
			local function handler(self, Index, Value)
				local external = false
				if type(checkcaller) == "function" then external = not checkcaller() end
				if nojump_state.enabled and external and Index == "JumpPower" and IsA(self, "Humanoid") then
					return
				end
				-- защитимся от редкого ре-энтри до присвоения orig
				if not raw_newindex then return end
				return raw_newindex(self, Index, Value)
			end
			local wrapper = (type(newcclosure) == "function") and newcclosure(handler) or handler
			local ok, orig = pcall(function()
				return hookmetamethod(game, "__newindex", wrapper)
			end)
			if ok and orig then
				raw_newindex = orig
				nojump_state.old = orig
				nojump_state.hooked = true
			end
		end

		local function start_fallback()
			-- Фолбэк для executors без hookmetamethod/newcclosure
			local rs = (vars and vars.rs) or game:GetService("RunService")
			if nojump_state.conn and nojump_state.conn.Connected then return end
			nojump_state.conn = rs.Heartbeat:Connect(function()
				local char = lp and lp.Character
				if not char then return end
				local hum = char:FindFirstChildOfClass("Humanoid")
				if not hum then return end
				-- фиксируем базовые значения один раз
				if not nojump_state.baselineJP then nojump_state.baselineJP = tonumber(hum.JumpPower) or 50 end
				if not nojump_state.baselineJH then nojump_state.baselineJH = tonumber(hum.JumpHeight) or 7.2 end
				-- если игра обнуляет/занижает, мгновенно восстанавливаем
				local okp = pcall(function()
					if hum.UseJumpPower ~= false then
						if hum.JumpPower < nojump_state.baselineJP then hum.JumpPower = nojump_state.baselineJP end
					else
						if hum.JumpHeight < nojump_state.baselineJH then hum.JumpHeight = nojump_state.baselineJH end
					end
				end)
				if not okp then return end
			end)
		end

		local function stop_fallback()
			if nojump_state.conn then
				pcall(function() nojump_state.conn:Disconnect() end)
				nojump_state.conn = nil
			end
		end

		local nojump_toggle = MovementSec:toggle({
			name = "NoJumpCooldown",
			flag = "NoJumpCooldown_Toggle",
			default = false,
			callback = function(val)
				nojump_state.enabled = val
				if val then
					ensure_loaded()
					install_hook_once()
					if not nojump_state.hooked then
						start_fallback()
					else
						stop_fallback()
					end
				else
					stop_fallback()
				end
			end
		})
	end
	  -- no jump cooldown system end

  	-- strafe system start
  	do
 		local run = (vars and vars.run) or game:GetService("RunService")

  		local strafe_state = {
  			enabled = false,
  			connection = nil,
			mode = "Velocity", -- CFrame | Velocity 
			value = 10,
  		}

		-- sanitize persisted mode: drop unsupported values (e.g., legacy "Impulse")
		if strafe_state.mode ~= "CFrame" and strafe_state.mode ~= "Velocity" then
			strafe_state.mode = "Velocity"
		end

 		local function start_strafe()
 			if strafe_state.connection and strafe_state.connection.Connected then return end
 			local signal = (run and (run.PreSimulation or run.Stepped or run.Heartbeat))
 			strafe_state.connection = signal:Connect(function(dt)
 				if not strafe_state.enabled then return end
 				local char = lp and lp.Character
 				local hum = char and char:FindFirstChildOfClass("Humanoid")
 				local root = char and char:FindFirstChild("HumanoidRootPart")
 				if not (hum and root) then return end
 				-- только в воздухе
 				if hum.FloorMaterial ~= Enum.Material.Air then return end
 				-- направл. по XZ
				local moveDir = hum.MoveDirection
				if moveDir.Magnitude < 0.05 then return end
				local dir = Vector3.new(moveDir.X, 0, moveDir.Z)
				if dir.Magnitude <= 0 then return end
				dir = dir.Unit

				if strafe_state.mode == "CFrame" then
					-- добавочное смещение по XZ в кадр (усилен: dt * 10)
					root.CFrame = root.CFrame + (dir * (strafe_state.value * (dt or 0) * 10))
				else -- Velocity
					-- устанавливаем минимум по XZ = WalkSpeed + Strength, сохраняя Y
					pcall(function()
						local v = root.AssemblyLinearVelocity
						local horiz = Vector3.new(v.X, 0, v.Z)
						local targetMag = math.max(horiz.Magnitude, ((hum and hum.WalkSpeed) or 16) + (strafe_state.value * 3))
						local nv = dir * targetMag
						root.AssemblyLinearVelocity = Vector3.new(nv.X, v.Y, nv.Z)
					end)
				end
  			end)
  		end

 		local function stop_strafe()
 			if strafe_state.connection then
 				pcall(function()
 					if strafe_state.connection.Connected then strafe_state.connection:Disconnect() end
 				end)
 				strafe_state.connection = nil
 			end
 		end
 
 		-- UI
 		local strafe_toggle = MovementSec:toggle({
 			name = "Strafe",
 			flag = "Strafe_Toggle",
 			default = false,
 			callback = function(v)
 				strafe_state.enabled = v
 				if v then start_strafe() else stop_strafe() end
 				if library and library.update_dependencies then library:update_dependencies() end
 			end
 		})

 		local strafe_dep = MovementSec:dependency_box()
		strafe_dep:setup_dependencies({ { strafe_toggle, true } })

		strafe_dep:dropdown({
			name = "Mode",
			flag = "Strafe_Mode",
			items = { "CFrame", "Velocity" },
			default = strafe_state.mode,
			callback = function(val)
				strafe_state.mode = val
			end
		})

		strafe_dep:slider({
			name = "Str",
			flag = "Strafe_Strength",
			min = 1,
			max = 20,
			default = 10,
			decimals = 0,
			callback = function(val)
				strafe_state.value = val
			end
		})
 	end
 	-- strafe system end
 
 
  -- movement system end
 end
 -- misc system end
end

 -- применяем тему после создания всех элементов
for index, value in next, themes.preset do
    pcall(function()
        library:update_theme(index, value)
    end)
end

 -- показываем уведомление о загрузке скрипта
library:notification({
    text = "hello, client is loaded, onyx hub = zalupa ebanaya",
    time = 10
})
