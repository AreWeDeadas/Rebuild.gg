loadstring(game:HttpGet("https://pastebin.com/raw/gimbTwW1"))()
local library, dim2, hex, rgbseq, rgbkey, themes, flags, random, lp = loadstring(game:HttpGet("https://raw.githubusercontent.com/AreWeDeadas/Rebuild.gg/refs/heads/main/another"))()

-- apply default theme before creating UI
library:update_theme("accent", hex("#ffffff"))
library:update_theme("contrast", rgbseq({
	rgbkey(0, hex("#2d2d2d")),
	rgbkey(1, hex("#101010")),
}))
library:update_theme("inline", hex("#313131"))
library:update_theme("outline", hex("#000000"))
library:update_theme("text", hex("#7b7b7b"))
library:update_theme("text_outline", hex("#282828"))
library:update_theme("glow", hex("#ffffff"))

-- load assets before creating UI
library:load_assets()
-- Загрузить звуки
library:load_sounds()

local window = library:window({
	name = os.date("Rebuild.gg - skidded by 32vision - %b %d %Y - Private - onyxhub sucks - cursed by 32vision to win - creds to chagpt "),
	size = dim2(0, 614, 0, 639),
})
-- custom hud system end
local Aimbot = window:tab({ name = "Rage" })
local Misc = window:tab({ name = "Misc" })
local Visuals = window:tab({ name = "Visuals" })
local Players = window:tab({ name = "Players" })
local Settings = window:tab({ name = "Settings" })
--
local watermark = library:watermark({
	default = os.date("Rebuild.gg - fuckass - %b %d %Y - %H:%M:%S"),
})
--
local radar = library:radar({
	size = 200,
	clamp = true,
})
--
local custom_hud = library:custom_hud({
	size = dim2(0, 280, 0, 32),
	position = dim2(0, 250, 0, 300),
	hud_type = "Rust"
})
--

-- cached services and common objects
local vars = {
	ps = game:GetService("Players"),
	rs = game:GetService("RunService"),
	uis = game:GetService("UserInputService"),
	ts = game:GetService("TweenService"),
	hs = game:GetService("HttpService"),
	cam = workspace.CurrentCamera,
	math = math,
	cf = CFrame,
	v2 = Vector2,
	v3 = Vector3,
}

-- enable debug logs
flags["Debug"] = true
print("[Rebuild] Debug enabled")

-- utility system start
local utility = {}
do
	-- validate player has alive character
	function utility:ValidateClient(player)
		if not player then return false end
		local char = player.Character
		if not char then return false end
		local hum = char:FindFirstChildOfClass("Humanoid")
		if not hum or hum.Health <= 0 then return false end
		return true
	end

	-- preferred body part for targeting
	function utility:GetPreferredPart(char)
		return char and (
			char:FindFirstChild("HumanoidRootPart")
			or char:FindFirstChild("Head")
			or char:FindFirstChild("UpperTorso")
			or char:FindFirstChild("Torso")
		) or nil
	end

	-- world position to screen point
	function utility:ToScreen(pos)
		local v3p, on = vars.cam:WorldToViewportPoint(pos)
		return vars.v2.new(v3p.X, v3p.Y), on
	end

	-- mouse helpers
	function utility:GetMouseLocation()
		return vars.uis:GetMouseLocation()
	end
	function utility:GetMouseDistance(screenPoint)
		return (self:GetMouseLocation() - screenPoint).Magnitude
	end

	-- get closest player to mouse on screen
	function utility:GetClosestToMouse()
		local best, bestd = nil, nil
		for _, plr in ipairs(vars.ps:GetPlayers()) do
			if plr ~= lp and self:ValidateClient(plr) then
				local char = plr.Character
				local part = self:GetPreferredPart(char)
				if part then
					local sp, on = self:ToScreen(part.Position)
					if on then
						local d = self:GetMouseDistance(sp)
						if not bestd or d < bestd then
							best, bestd = plr, d
						end
					end
				end
			end
		end
		return best, bestd or vars.math.huge
	end

	-- damage detection framework start
	-- listeners storage
	utility._hit_listeners = {}

	-- target info feed storage
	utility._target = {
		info = nil, -- table with all fields
		listeners = {},
	}

	-- subscribe to hit event
	function utility:OnHit(callback)
		if typeof(callback) == "function" then
			table.insert(self._hit_listeners, callback)
		end
	end

	-- subscribe to target info updates
	function utility:OnTargetUpdate(callback)
		if typeof(callback) == "function" then
			table.insert(self._target.listeners, callback)
		end
	end

	-- internal: emit hit event safely
	function utility:_emit_hit(info)
		for _, fn in ipairs(self._hit_listeners) do
			pcall(fn, info)
		end
	end

	-- internal: print to chat helper
	function utility:_chat(msg)
		local sg = game:GetService("StarterGui")
		pcall(function()
			sg:SetCore("ChatMakeSystemMessage", { Text = msg })
		end)
		print(msg)
	end

	-- public: get current target info and istarget flag
	function utility:GetTargetInfo()
		local info = self._target.info
		return info ~= nil, info
	end

	-- public: set current target info by player (auto-collects fields)
	function utility:SetTargetInfo(player)
		local info = nil
		-- always drive damage detector override immediately
		utility._dd.override_player = player or nil
		if player and player.Character then
			local char = player.Character
			local hum = char:FindFirstChildOfClass("Humanoid")
			local root = hum and hum.RootPart or char:FindFirstChild("HumanoidRootPart")
			local health = hum and hum.Health or nil
			local maxh = hum and hum.MaxHealth or nil
			-- use dot to test method existence, then call via ':' safely
			local cf = root and root.CFrame or ((char.GetPivot and char:GetPivot()) or nil)
			local pos = root and root.Position or (cf and cf.Position or nil)
			info = {
				isTarget = true,
				player = player,
				userId = player.UserId,
				name = player.Name,
				displayName = player.DisplayName,
				character = char,
				humanoid = hum,
				root = root,
				cframe = cf,
				position = pos,
				health = health,
				maxHealth = maxh,
				alive = hum and hum.Health > 0,
				time = os.clock(),
			}
		end
		self._target.info = info
		-- notify listeners
		for _, fn in ipairs(self._target.listeners) do
			pcall(fn, info)
		end
		if flags and flags["Debug"] then
			if info then
				print("[TargetFeed] SetTargetInfo:", info.name)
			else
				print("[TargetFeed] SetTargetInfo (char not ready):", player and player.Name or "nil")
			end
		end
	end

	function utility:ClearTargetInfo()
		self._target.info = nil
		utility._dd.override_player = nil
		for _, fn in ipairs(self._target.listeners) do
			pcall(fn, nil)
		end
		if flags and flags["Debug"] then
			print("[TargetFeed] ClearTargetInfo")
		end
	end

	-- internal state for damage detection
	utility._dd = {
		last_target = nil,
		last_char = nil,
		hum = nil,
		last_health = nil,
		last_max = nil,
		conn = nil,
		hum_conn = nil,
		last_debug_t = 0,
		override_player = nil, -- приоритетная цель, установленная таргетингом вручную
	}

	-- external setter: таргетинг сообщает текущую цель
	function utility:SetCurrentTarget(player)
		utility._dd.override_player = player
		if flags and flags["Debug"] then
			print("[DD] SetCurrentTarget:", player and player.Name)
		end
	end

	function utility:ClearCurrentTarget()
		utility._dd.override_player = nil
		if flags and flags["Debug"] then
			print("[DD] ClearCurrentTarget")
		end
	end

	-- start heartbeat watcher once
	if not utility._dd.conn then
		utility._dd.conn = vars.rs.Heartbeat:Connect(function()
			local dd = utility._dd
			-- используем приоритетно цель, установленную через SetCurrentTarget
			local current = utility._dd.override_player or (targeting_state and targeting_state.current or nil)

			-- periodic debug heartbeat
			if flags and flags["Debug"] then
				local now = os.clock()
				if now - (dd.last_debug_t or 0) > 1 then
					dd.last_debug_t = now
					print(string.format("[DD] hb: current=%s hum=%s lh=%s lm=%s", 
						current and current.Name or "nil",
						(dd.hum and "ok" or "nil"),
						tostring(dd.last_health),
						tostring(dd.last_max)
					))
				end
			end

			-- target switched: hard reset
			if current ~= dd.last_target then
				dd.last_target = current
				dd.last_char = nil
				dd.hum = nil
				dd.last_health = nil
				dd.last_max = nil

				-- disconnect previous humanoid connection
				if dd.hum_conn then pcall(function() dd.hum_conn:Disconnect() end) dd.hum_conn = nil end
				if flags and flags["Debug"] then
					print("[DD] target switched to:", current and current.Name)
				end
			end

			if not current then return end

			-- refresh humanoid if character changed (respawn) or missing
			local char = current.Character
			if char ~= dd.last_char then
				dd.last_char = char
				dd.hum = char and char:FindFirstChildOfClass("Humanoid") or nil
				dd.last_health = nil
				dd.last_max = nil
				-- reconnect HealthChanged for new humanoid
				if dd.hum_conn then pcall(function() dd.hum_conn:Disconnect() end) dd.hum_conn = nil end
				if dd.hum then
					if flags and flags["Debug"] then
						print("[DD] humanoid bound for:", current and current.Name)
					end
					dd.hum_conn = dd.hum.HealthChanged:Connect(function(ch)
						local cm = dd.hum and dd.hum.MaxHealth or 0
						if dd.last_health == nil or dd.last_max == nil or cm ~= dd.last_max then
							dd.last_health = ch
							dd.last_max = cm
							return
						end
						if ch ~= dd.last_health then
							local dmg = dd.last_health - ch
							if dmg > 0 then
								local percent = vars.math.floor(((cm > 0 and ch / cm or 0) * 100) + 0.5)
								local hitinfo = {
									player = current,
									damage = dmg,
									health = ch,
									max = cm,
									percentage = percent,
								}
								if flags and flags["Debug"] then
									print("[DD] hit:", hitinfo.player and hitinfo.player.Name, hitinfo.damage, hitinfo.health, hitinfo.max, hitinfo.percentage)
								end
								utility:_emit_hit(hitinfo)
							end
							dd.last_health = ch
							dd.last_max = cm
						end
					end)
				end
			end

			local hum = dd.hum
			if not hum or not hum.Parent then return end

			local ch = hum.Health
			local cm = hum.MaxHealth

			-- initialize or reset when MaxHealth changes to avoid false positives
			if dd.last_health == nil or dd.last_max == nil or cm ~= dd.last_max then
				dd.last_health = ch
				dd.last_max = cm
				return
			end

			if ch ~= dd.last_health then
				local dmg = dd.last_health - ch
				if dmg > 0 then
					local percent = vars.math.floor(((cm > 0 and ch / cm or 0) * 100) + 0.5)
					local info = {
						player = current,
						damage = dmg,
						health = ch,
						max = cm,
						percentage = percent,
					}
					utility:_emit_hit(info)
				end
				dd.last_health = ch
				dd.last_max = cm
			end
		end)
		-- default listener: print to chat
		utility:OnHit(function(info)
			local name = (info.player and info.player.Name) or "?"
			local dmg = vars.math.floor(info.damage + 0.5)
			local hp = vars.math.floor(info.health + 0.5)
			local mx = vars.math.floor(info.max + 0.5)
			local pct = vars.math.floor(info.percentage + 0.5)
			utility:_chat(string.format("[Hit] %s -%d HP | %d/%d (%d%%)", name, dmg, hp, mx, pct))
		end)
	end
	-- damage detection framework end

end
-- utility system end

-- shared targeting state (used by targeting UI and aimbot)
local targeting_state = { current = nil }
-- targeting system start
do
	-- framework function
	local framework = {}

    -- highlight state (for visuals)
	    -- highlight state (for visuals)
    local hl_state = { 
        last_char = nil, 
        hl = nil,           -- LOS highlight (DepthMode = Occluded), parented to real char
        occ_hl = nil,       -- OCC highlight (AlwaysOnTop), parented to cloned model
        occ_model = nil,    -- cloned model welded to real character parts
        char_added_conn = nil,
        char_removing_conn = nil,
        died_conn = nil, 
        bound_player = nil,
        update_counter = 0
    }
    local HL_NAME = "RB_HL_32v"
    
    -- больше не создаем заранее и не переиспользуем
    local function get_or_create_highlight()
        local h = Instance.new("Highlight")
        h.Name = HL_NAME
        -- default DepthMode adjusted when applied
        h.DepthMode = Enum.HighlightDepthMode.Occluded
        return h
    end

    local function build_occ_model(char)
        -- destroy previous model
        if hl_state.occ_model then pcall(function() hl_state.occ_model:Destroy() end) hl_state.occ_model = nil end
        if not char then return end
        local m = Instance.new("Model")
        m.Name = "RB_TH_OCC"
        m.Parent = workspace
        for _, child in ipairs(char:GetChildren()) do
            if child:IsA("BasePart") then
                local cloned = child:Clone()
                cloned:ClearAllChildren()
                cloned.CanCollide = false
                if cloned:IsA("MeshPart") then cloned.TextureID = "" end
                cloned.Size = cloned.Size * 0.99 -- prevent z-fighting
                cloned.Parent = m
                local weld = Instance.new("WeldConstraint")
                weld.Part0 = cloned
                weld.Part1 = child
                weld.Parent = cloned
            end
        end
        hl_state.occ_model = m
    end

    local function clear_highlight()
        -- soft clear: disable visuals, keep singletons, cleanup cloned model
        if hl_state.hl then
            hl_state.hl.Enabled = false
            hl_state.hl.Adornee = nil
            hl_state.hl.Parent = nil
        end
        if hl_state.occ_hl then
            hl_state.occ_hl.Enabled = false
            hl_state.occ_hl.Adornee = nil
            hl_state.occ_hl.Parent = nil
        end
        if hl_state.occ_model then pcall(function() hl_state.occ_model:Destroy() end) hl_state.occ_model = nil end
        if hl_state.died_conn then pcall(function() hl_state.died_conn:Disconnect() end) hl_state.died_conn = nil end
        if hl_state.char_added_conn then pcall(function() hl_state.char_added_conn:Disconnect() end) hl_state.char_added_conn = nil end
        if hl_state.char_removing_conn then pcall(function() hl_state.char_removing_conn:Disconnect() end) hl_state.char_removing_conn = nil end
        hl_state.last_char = nil
        hl_state.bound_player = nil
    end

    local function clear_highlight_visual()
        -- ТОЛЬКО визуальная очистка: не уничтожаем, а отключаем singleton
        if hl_state.hl then
            hl_state.hl.Enabled = false
            hl_state.hl.Adornee = nil
        end
        if hl_state.occ_hl then
            hl_state.occ_hl.Enabled = false
            hl_state.occ_hl.Adornee = nil
        end
        hl_state.last_char = nil
        -- НЕ трогаем char_added_conn/char_removing_conn/died_conn здесь
    end

	    -- utility getters for flags
    local function get_cp_color(flag, default)
        local v = flags and flags[flag]
        if v == nil then return default end
        local t = typeof(v)
        if t == "table" and v.Color then return v.Color end
        if t == "Color3" then return v end
        return default
    end

    local function get_num(flag, default)
        local v = flags and flags[flag]
        if typeof(v) == "number" then return v end
        return default
    end

    local function apply_highlight(char)
        -- выключаем визуал, если настроек нет или цель отсутствует
        if not char or not flags or not flags["target_highlight"] then
            clear_highlight_visual()
            return
        end

        -- ensure LOS/OCC singletons
        if not hl_state.hl then hl_state.hl = get_or_create_highlight() end
        if not hl_state.occ_hl then hl_state.occ_hl = get_or_create_highlight() end
        if not hl_state.occ_model or not hl_state.occ_model.Parent then build_occ_model(char) end

        -- LOS highlight on real char (Occluded)
        local h = hl_state.hl
        h.DepthMode = Enum.HighlightDepthMode.Occluded
        h.FillColor = get_cp_color("th_fill", Color3.fromRGB(255, 255, 0))
        h.OutlineColor = get_cp_color("th_out", Color3.fromRGB(0, 0, 0))
        h.FillTransparency = get_num("th_ftrs", 0.5)
        h.OutlineTransparency = get_num("th_otrs", 0.5)
        if h.Adornee ~= char then h.Adornee = char end
        if h.Parent ~= char then h.Parent = char end
        h.Enabled = true

        -- OCC highlight on cloned model (AlwaysOnTop)
        local oh = hl_state.occ_hl
        oh.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        oh.FillColor = get_cp_color("th_occ_fill", Color3.fromRGB(0, 170, 255))
        oh.OutlineColor = get_cp_color("th_occ_out", Color3.fromRGB(0, 0, 0))
        oh.FillTransparency = get_num("th_occ_ftrs", 0.3)
        oh.OutlineTransparency = get_num("th_occ_otrs", 0.7)
        if oh.Adornee ~= hl_state.occ_model then oh.Adornee = hl_state.occ_model end
        if oh.Parent ~= hl_state.occ_model then oh.Parent = hl_state.occ_model end
        oh.Enabled = true

        hl_state.last_char = char
    end

    local function bind_humanoid_died(char)
        if not char then return end
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            if hl_state.died_conn then pcall(function() hl_state.died_conn:Disconnect() end) end
            hl_state.died_conn = hum.Died:Connect(function()
                -- цель умерла: убираем только визуал, оставляем подписки для авто-реапплая
                print("[TH] Humanoid died for:", char.Name, "- removing visual highlight")
                clear_highlight_visual()
            end)
        end
    end

    -- utility: disable highlight (не удаляем, только отключаем)
    local function remove_all_highlights(char)
        if not char then return end
        print("[TH] Cleanup highlights for:", char.Name)
        if hl_state.hl then
            hl_state.hl.Enabled = false
            hl_state.hl.Adornee = nil
        end
        -- очищаем другие highlight если есть
        for _, obj in ipairs(char:GetDescendants()) do
            if typeof(obj) == "Instance" and obj:IsA("Highlight") and obj ~= hl_state.hl then
                pcall(function() obj:Destroy() end)
            end
        end
    end

    local function setup_target_highlight_bindings(player)
        if not player then return end
        
        -- отключаем старые подключения
        if hl_state.char_added_conn then 
            pcall(function() hl_state.char_added_conn:Disconnect() end) 
        end
        if hl_state.char_removing_conn then 
            pcall(function() hl_state.char_removing_conn:Disconnect() end) 
        end
        
        hl_state.bound_player = player
        
        -- обработчик удаления персонажа
        hl_state.char_removing_conn = player.CharacterRemoving:Connect(function()
            print("[TH] CharacterRemoving for:", player.Name)
            -- только визуальная очистка, сохраняем подписки
            clear_highlight_visual()
        end)
        
        -- обработчик добавления персонажа (как в scripttoskid)
        hl_state.char_added_conn = player.CharacterAdded:Connect(function(newChar)
            if not newChar then return end
            print("[TH] CharacterAdded for:", player.Name)
            -- ждем загрузки персонажа
            game:GetService("RunService").Heartbeat:Wait()
            
            -- проверяем что этот игрок все еще является текущей целью
            local is_current_target = targeting_state and targeting_state.current and 
                (targeting_state.current == player or 
                 (targeting_state.current.UserId and targeting_state.current.UserId == player.UserId))
            
            if is_current_target and flags and flags["target_highlight"] then
                print("[TH] Reapplying highlight after respawn for:", player.Name)
                apply_highlight(newChar)
                bind_humanoid_died(newChar)
            end
        end)
        
        -- применяем к текущему персонажу если существует
        if player.Character then
            apply_highlight(player.Character)
            bind_humanoid_died(player.Character)
        end
    end
    
    -- простое обновление: при смене цели пересоздаем highlight
    local function is_visible(char)
        if not char then return false end
        local cam = workspace.CurrentCamera
        local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Head")
        if not root then return false end
        local origin = cam.CFrame.Position
        local dir = (root.Position - origin)
        local rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        rayParams.FilterDescendantsInstances = { lp.Character, char, hl_state.occ_model }
        local hit = workspace:Raycast(origin, dir, rayParams)
        return hit == nil
    end

    function framework:update_target_highlight()
        -- выключено в UI -> очищаем и выходим
        if not flags or not flags["target_highlight"] then
            clear_highlight()
            return
        end

        local current = targeting_state and targeting_state.current
        local char = current and current.Character
        if not char then
            clear_highlight()
            return
        end

        -- при смене цели пересоздаем
        if hl_state.last_char ~= char then
            apply_highlight(char)
            bind_humanoid_died(char)
        end

        -- toggle occlusion highlight based on visibility
        local vis = is_visible(char)
        if hl_state.occ_hl then hl_state.occ_hl.Enabled = not vis end
    end

	-- use shared state instead of a private upvalue
	-- current target is stored in `targeting_state.current`
	
	function framework:selectTarget() 
		if flags and flags["Debug"] then print("[Targeting] selectTarget called") end

		if targeting_state.current then
			if flags and flags["Debug"] then print("[Targeting] Releasing target:", targeting_state.current.Name) end
			clear_highlight()
			targeting_state.current = nil
			-- очищаем информацию о цели для детекции урона
			utility:ClearTargetInfo()
			utility:ClearCurrentTarget()
			if flags and flags["Debug"] then print("[Targeting] Target cleared") end
		else
			-- Acquire new target via utility
			local best_player, best_dist = utility:GetClosestToMouse()
			if best_player then
				targeting_state.current = best_player
				-- устанавливаем цель для детекции урона
				utility:SetTargetInfo(best_player)
				utility:SetCurrentTarget(best_player)
				if flags and flags["target_highlight"] then
					setup_target_highlight_bindings(best_player)
				end
				if flags and flags["Debug"] then
					print("[Targeting] Target acquired:", targeting_state.current.Name, "(MouseDist:", vars.math.floor(best_dist), ")")
				end
			else
				if flags and flags["Debug"] then print("[Targeting] No target found") end
			end
		end
	end
	
	-- ui elements
	local rage_col = Aimbot:column()
	local TargetSec, VisSec = rage_col:multi_section({ names = { "Targeting", "Visuals" } })
	
	local targeting_toggle = TargetSec:toggle({
		name = "Enabled",
		flag = "Targeting_Enabled",
		default = false,
	}):keybind({
		name = "Target",
		flag = "Target_Select_Bind",
		default = "t",
		callback = function()
			framework:selectTarget()
		end,
	})

  -- targeting mode dropdown (Sticky/Nuker)
  local targeting_mode = TargetSec:dropdown({
      name = "Mode",
      flag = "Targeting_Mode",
      items = { "Sticky", "Nuker" },
      default = "Sticky",
  })

    local function refresh_hl_from_ui()
        if not flags or not flags["target_highlight"] then return end
        local char = hl_state and hl_state.last_char
        if (not char) and targeting_state and targeting_state.current then
            char = targeting_state.current.Character
            -- обновляем last_char если получили новый персонаж
            if char then
                hl_state.last_char = char
            end
        end
        if char then 
            apply_highlight(char) 
            bind_humanoid_died(char)
        end
    end

    local th_toggle = VisSec:toggle({
        name = "TargetHighlight",
        flag = "target_highlight",
        default = false,
        callback = function(state)
            if state then
                refresh_hl_from_ui()
            else
                clear_highlight()
            end
        end
    })
    -- colorpickers привязаны к toggle (видны только при включенном TargetHighlight)
    th_toggle:colorpicker({ name = "Fill", flag = "th_fill", default = Color3.fromRGB(255, 255, 0), callback = function()
        refresh_hl_from_ui()
    end })
    th_toggle:colorpicker({ name = "Out",  flag = "th_out",  default = Color3.fromRGB(0, 0, 0), callback = function()
        refresh_hl_from_ui()
    end })
    -- occluded colorpickers (для случая, когда цель не видима)
    th_toggle:colorpicker({ name = "OccFill", flag = "th_occ_fill", default = Color3.fromRGB(0, 170, 255), callback = function()
        refresh_hl_from_ui()
    end })
    th_toggle:colorpicker({ name = "OccOut",  flag = "th_occ_out",  default = Color3.fromRGB(0, 0, 0), callback = function()
        refresh_hl_from_ui()
    end })
	-- dependent transparency sliders (interval 0.01)
	local th_dep = VisSec:dependency_box()
	th_dep:setup_dependencies({ { th_toggle, true } })
	th_dep:slider({ name = "FTrs", flag = "th_ftrs", min = 0, max = 1, default = 0.5, interval = 0.01, callback = function()
        refresh_hl_from_ui()
    end })
    th_dep:slider({ name = "OTrs", flag = "th_otrs", min = 0, max = 1, default = 0.5, interval = 0.01, callback = function()
        refresh_hl_from_ui()
    end })
    th_dep:slider({ name = "OccFTrs", flag = "th_occ_ftrs", min = 0, max = 1, default = 0.3, interval = 0.01, callback = function()
        refresh_hl_from_ui()
    end })
    th_dep:slider({ name = "OccOTrs", flag = "th_occ_otrs", min = 0, max = 1, default = 0.7, interval = 0.01, callback = function()
        refresh_hl_from_ui()
    end })

    -- chams system start
    do
        local chams_state = {
            enabled = false,
            folder = nil,
            handles = {},
            fill_color = Color3.fromRGB(255, 0, 0),
            fill_transparency = 0.5,
            last_target = nil
        }

        local function cleanup_chams()
            for _, handle in pairs(chams_state.handles) do
                pcall(function() handle:Destroy() end)
            end
            chams_state.handles = {}
            if chams_state.folder then
                pcall(function() chams_state.folder:Destroy() end)
                chams_state.folder = nil
            end
        end

        local function create_chams(char)
            if not char then return end
            
            -- создаем папку для хранения
            if not chams_state.folder then
                chams_state.folder = Instance.new("Folder")
                chams_state.folder.Name = "RB_Chams"
                chams_state.folder.Parent = workspace.CurrentCamera
            end

            -- очищаем старые
            for _, handle in pairs(chams_state.handles) do
                pcall(function() handle:Destroy() end)
            end
            chams_state.handles = {}

            -- создаем chams для каждой части тела
            for _, part in ipairs(char:GetChildren()) do
                if part:IsA("BasePart") and (
                    part.Name:find("Arm") or 
                    part.Name:find("Leg") or 
                    part.Name:find("Hand") or 
                    part.Name:find("Feet") or 
                    part.Name:find("Foot") or
                    part.Name:find("Torso") or 
                    part.Name == "Head"
                ) then
                    local handle = Instance.new("BoxHandleAdornment")
                    handle.Size = part.Size
                    
                    handle.Adornee = part
                    handle.AlwaysOnTop = true
                    handle.ZIndex = 0
                    handle.Transparency = chams_state.fill_transparency
                    handle.Color3 = chams_state.fill_color
                    handle.Parent = chams_state.folder
                    
                    table.insert(chams_state.handles, handle)
                end
            end
        end

        local function update_chams()
            if not chams_state.enabled then
                cleanup_chams()
                return
            end

            local target = targeting_state and targeting_state.current
            if not target or not target.Character then
                cleanup_chams()
                chams_state.last_target = nil
                return
            end

            -- если цель изменилась, пересоздаем
            if chams_state.last_target ~= target.Character then
                create_chams(target.Character)
                chams_state.last_target = target.Character
            end

            -- обновляем свойства
            for _, handle in pairs(chams_state.handles) do
                if handle and handle.Parent then
                    handle.Color3 = chams_state.fill_color
                    handle.Transparency = chams_state.fill_transparency
                    handle.AlwaysOnTop = true
                end
            end
        end

        -- ui элементы
        local chams_toggle = VisSec:toggle({
            name = "Chams",
            flag = "target_chams",
            default = false,
            callback = function(state)
                chams_state.enabled = state
                if state then
                    update_chams()
                else
                    cleanup_chams()
                end
            end
        })

        chams_toggle:colorpicker({
            name = "Color",
            flag = "chams_color",
            default = Color3.fromRGB(255, 0, 0),
            callback = function(color)
                chams_state.fill_color = color
                update_chams()
            end
        })

        local chams_dep = VisSec:dependency_box()
        chams_dep:setup_dependencies({ { chams_toggle, true } })
        
        chams_dep:slider({
            name = "Trs",
            flag = "chams_trs",
            min = 0,
            max = 1,
            default = 0.5,
            interval = 0.01,
            callback = function(value)
                chams_state.fill_transparency = value
                update_chams()
            end
        })

        -- Walls always on: chams drawn through walls by default

        -- подключаем к обновлению
        table.insert(library.connections, vars.rs.RenderStepped:Connect(function()
            if chams_state.enabled then
                update_chams()
            end
        end))

        -- очистка при смене цели
        utility:OnTargetUpdate(function(info)
            if not info then
                cleanup_chams()
                chams_state.last_target = nil
            end
        end)
    end
    -- chams system end

    -- ChinaHat system start
    do
        local hat = {
            enabled = false,
            style = "Custom", -- Custom/Rainbow/Astolfo
            c1 = Color3.fromRGB(128, 18, 255),
            c2 = Color3.fromRGB(255, 0, 128),
            c3 = Color3.fromRGB(0, 200, 255),
            c4 = Color3.fromRGB(255, 255, 0),
            height = 0.7,
            radius = 2,
            sides = 25,
            hat_trs = 0.35,
            line_trs = 1.0,
            drawings = {},
            conn = nil,
            speed = 0.2,
        }

        local function lerp(a, b, t)
            return a + (b - a) * t
        end

        local function lerp_color(a, b, t)
            return Color3.new(
                lerp(a.R, b.R, t),
                lerp(a.G, b.G, t),
                lerp(a.B, b.B, t)
            )
        end

        local function custom_gradient(t, time)
            -- animated 4-stop gradient using C1..C4
            local tt = (t + (time * hat.speed)) % 1
            if tt < 0.25 then
                return lerp_color(hat.c1, hat.c2, tt / 0.25)
            elseif tt < 0.5 then
                return lerp_color(hat.c2, hat.c3, (tt - 0.25) / 0.25)
            elseif tt < 0.75 then
                return lerp_color(hat.c3, hat.c4, (tt - 0.5) / 0.25)
            else
                return lerp_color(hat.c4, hat.c1, (tt - 0.75) / 0.25)
            end
        end

        -- Generic palette interpolation helper
        local function palette_color(colors, t, time, speed)
            local n = #colors
            if n == 0 then return Color3.new(1,1,1) end
            if n == 1 then return colors[1] end
            local tt = (t + (time * (speed or hat.speed))) % 1
            local seg = tt * n
            local i = math.floor(seg) + 1
            local f = seg - math.floor(seg)
            local a = colors[i]
            local b = colors[(i % n) + 1]
            return lerp_color(a, b, f)
        end

        local function astolfo_color(t, time)
            -- three-tone: pink -> hotpink -> blue (rotating)
            local colors = {
                Color3.fromRGB(255, 105, 180), -- pink
                Color3.fromRGB(255, 75, 150),  -- deeper pink
                Color3.fromRGB(135, 206, 250), -- light blue
            }
            return palette_color(colors, t, time, 0.25)
        end

        local function rainbow_color(t, time)
            local hue = (time * 0.2 + t) % 1
            return Color3.fromHSV(hue, 0.6, 1)
        end

        local function ensure_drawings()
            if #hat.drawings == hat.sides then return end
            -- cleanup first
            for _, pair in ipairs(hat.drawings) do
                pcall(function() if pair[1] then pair[1]:Remove() end end)
                pcall(function() if pair[2] then pair[2]:Remove() end end)
            end
            hat.drawings = {}
            for i = 1, hat.sides do
                local line = Drawing.new("Line")
                local tri = Drawing.new("Triangle")
                line.ZIndex = 2
                line.Thickness = 1
                tri.ZIndex = 1
                tri.Filled = true
                table.insert(hat.drawings, { line, tri })
            end
        end

        local function set_visible_all(v)
            for _, pair in ipairs(hat.drawings) do
                local line, tri = pair[1], pair[2]
                if line then line.Visible = v end
                if tri then tri.Visible = v end
            end
        end

        local function cleanup_hat()
            if hat.conn then
                pcall(function() hat.conn:Disconnect() end)
                hat.conn = nil
            end
            for _, pair in ipairs(hat.drawings) do
                pcall(function() if pair[1] then pair[1]:Remove() end end)
                pcall(function() if pair[2] then pair[2]:Remove() end end)
            end
            hat.drawings = {}
        end

        -- Predefined palettes with neutral names
        local palettes = {
            CustomPalette1  = { Color3.fromRGB(255,94,58),  Color3.fromRGB(255,154,0),  Color3.fromRGB(255,212,0) },
            CustomPalette2  = { Color3.fromRGB(0,212,255),  Color3.fromRGB(0,128,255),  Color3.fromRGB(0,64,128),  Color3.fromRGB(0,40,80) },
            CustomPalette3  = { Color3.fromRGB(255,0,0),    Color3.fromRGB(255,102,0) },
            CustomPalette4  = { Color3.fromRGB(200,255,255),Color3.fromRGB(150,220,255),Color3.fromRGB(100,200,255),Color3.fromRGB(80,160,220), Color3.fromRGB(60,120,190) },
            CustomPalette5  = { Color3.fromRGB(88,0,255),   Color3.fromRGB(255,0,191),  Color3.fromRGB(0,160,255) },
            CustomPalette6  = { Color3.fromRGB(0,255,128),  Color3.fromRGB(255,0,255),  Color3.fromRGB(0,255,255) },
            -- new palettes
            CustomPalette7  = { Color3.fromRGB(255,255,255),Color3.fromRGB(200,200,200),Color3.fromRGB(150,150,150),Color3.fromRGB(100,100,100) },
            CustomPalette8  = { Color3.fromRGB(255,20,147), Color3.fromRGB(186,85,211), Color3.fromRGB(72,61,139) },
            CustomPalette9  = { Color3.fromRGB(0,255,255),  Color3.fromRGB(173,216,230),Color3.fromRGB(25,25,112) },
            CustomPalette10 = { Color3.fromRGB(255,215,0),  Color3.fromRGB(255,165,0),  Color3.fromRGB(255,69,0) },
            CustomPalette11 = { Color3.fromRGB(124,252,0),  Color3.fromRGB(50,205,50),  Color3.fromRGB(0,128,0) },
            CustomPalette12 = { Color3.fromRGB(0,0,0),      Color3.fromRGB(45,0,80),    Color3.fromRGB(120,0,200), Color3.fromRGB(255,0,255) },
            CustomPalette13 = { Color3.fromRGB(0,0,128),    Color3.fromRGB(0,0,255),    Color3.fromRGB(0,191,255), Color3.fromRGB(135,206,250) },
            CustomPalette14 = { Color3.fromRGB(255,105,180),Color3.fromRGB(255,182,193),Color3.fromRGB(135,206,250) },
            CustomPalette15 = { Color3.fromRGB(240,255,255),Color3.fromRGB(176,224,230),Color3.fromRGB(135,206,235), Color3.fromRGB(70,130,180) },
            CustomPalette16 = { Color3.fromRGB(255,255,240),Color3.fromRGB(255,250,205),Color3.fromRGB(250,250,210), Color3.fromRGB(238,232,170) },
        }

        local function get_color_at(frac, time)
            local style = hat.style
            if style == "Rainbow" then
                return rainbow_color(frac, time)
            elseif style == "Astolfo" then
                return astolfo_color(frac, time)
            elseif palettes[style] ~= nil then
                return palette_color(palettes[style], frac, time, 0.2)
            else
                return custom_gradient(frac, time)
            end
        end

        local function update_hat()
            if not hat.enabled then
                cleanup_hat()
                return
            end
            local target = targeting_state and targeting_state.current
            local char = (target and target.Character) or nil
            local head = char and char:FindFirstChild("Head")
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            if not (char and head and hum and hum.Health > 0) then
                cleanup_hat()
                return
            end
            ensure_drawings()

            local cam = workspace.CurrentCamera
            local timeNow = tick()
            local tau = math.pi * 2
            local pos = head.Position + Vector3.new(0, 0.75, 0)
            local topWorld = pos + Vector3.new(0, hat.height, 0)

            -- offscreen/behind camera: just hide this frame to avoid artifacts
            local head2d, onScreen = cam:WorldToViewportPoint(head.Position)
            if (not onScreen) or head2d.Z <= 0 then
                set_visible_all(false)
                return
            end

            for i = 1, hat.sides do
                local line, tri = hat.drawings[i][1], hat.drawings[i][2]
                local last = (i / hat.sides)
                local nextf = ((i % hat.sides) + 1) / hat.sides
                local angA = last * tau
                local angB = nextf * tau
                local lastWorld = pos + Vector3.new(math.cos(angA), 0, math.sin(angA)) * hat.radius
                local nextWorld = pos + Vector3.new(math.cos(angB), 0, math.sin(angB)) * hat.radius

                local a2d = cam:WorldToViewportPoint(lastWorld)
                local b2d = cam:WorldToViewportPoint(nextWorld)
                local t2d = cam:WorldToViewportPoint(topWorld)

                local col = get_color_at(last, timeNow)

                line.From = Vector2.new(a2d.X, a2d.Y)
                line.To = Vector2.new(b2d.X, b2d.Y)
                line.Color = col
                line.Transparency = hat.line_trs
                line.Visible = true

                tri.PointA = Vector2.new(t2d.X, t2d.Y)
                tri.PointB = line.From
                tri.PointC = line.To
                tri.Color = col
                tri.Transparency = hat.hat_trs
                tri.Visible = true
            end
        end

        -- UI
        local hat_toggle = VisSec:toggle({
            name = "ChinaHat",
            flag = "china_hat",
            default = false,
            callback = function(state)
                hat.enabled = state
                if state then
                    update_hat()
                else
                    cleanup_hat()
                end
            end
        })

        hat_toggle:colorpicker({ name = "C1", flag = "hat_c1", default = hat.c1, callback = function(c) hat.c1 = c end })
        hat_toggle:colorpicker({ name = "C2", flag = "hat_c2", default = hat.c2, callback = function(c) hat.c2 = c end })
        hat_toggle:colorpicker({ name = "C3", flag = "hat_c3", default = hat.c3, callback = function(c) hat.c3 = c end })
        hat_toggle:colorpicker({ name = "C4", flag = "hat_c4", default = hat.c4, callback = function(c) hat.c4 = c end })

        local hat_dep = VisSec:dependency_box()
        hat_dep:setup_dependencies({ { hat_toggle, true } })
        local hat_style = hat_dep:dropdown({
            name = "Style",
            flag = "hat_style",
            items = { "Custom", "Rainbow", "Astolfo",
                "CustomPalette1", "CustomPalette2", "CustomPalette3", "CustomPalette4", "CustomPalette5", "CustomPalette6",
                "CustomPalette7", "CustomPalette8", "CustomPalette9", "CustomPalette10", "CustomPalette11", "CustomPalette12",
                "CustomPalette13", "CustomPalette14", "CustomPalette15", "CustomPalette16" },
            default = "Custom",
            callback = function(val) hat.style = val end
        })

        table.insert(library.connections, vars.rs.RenderStepped:Connect(function()
            if hat.enabled then update_hat() end
        end))

        -- cleanup on target cleared and hide during transition
        utility:OnTargetUpdate(function(info)
            if not info then
                cleanup_hat()
            end
        end)
    end
    -- ChinaHat system end

    -- TargetESP system start
    do
        -- state
        local targetesp_state = {
            enabled = false,
            color = hex("#ffffff"),
            size = 1.0,
            speed = 1.0,
            bill = nil,
            img = nil,
            angle = 0,
            conn = nil,
            last_tick = os.clock(),
            asset_items = nil, -- cached dropdown items
            asset_map = nil,   -- name -> asset path
        }

        -- utils
        local function as_asset(path)
            if getcustomasset then return getcustomasset(path) end
            if getsynasset then return getsynasset(path) end
            return path
        end

        -- scan assets folder and prepare dropdown items and name->path map
        local function scan_assets()
            local dir = (library and library.directory or "Rebuild.gg") .. "/assets"
            local items, map = {}, {}
            local ok, files = pcall(function()
                return listfiles and listfiles(dir) or {}
            end)
            if ok and files and #files > 0 then
                table.sort(files)
                for _, f in ipairs(files) do
                    local lower = string.lower(f)
                    if lower:sub(-4) == ".png" or lower:sub(-4) == ".jpg" or lower:sub(-5) == ".jpeg" then
                        local name = f:match("([^/\\]+)$") or f
                        table.insert(items, name)
                        map[name] = as_asset(f)
                    end
                end
            end
            targetesp_state.asset_items = items
            targetesp_state.asset_map = map
            return items, map
        end

        local function set_image_by_name(name)
            if not name or name == "" then return end
            local map = targetesp_state.asset_map or select(2, scan_assets())
            local path = map and map[name]
            if targetesp_state.img then
                targetesp_state.img.Image = path or targetesp_state.img.Image or ""
            end
        end

        local function pick_asset_image()
            local dir = (library and library.directory or "Rebuild.gg") .. "/assets"
            local ok, files = pcall(function()
                return listfiles and listfiles(dir) or {}
            end)
            if not ok or not files or #files == 0 then return nil end
            table.sort(files)
            for _, f in ipairs(files) do
                local lower = string.lower(f)
                if lower:sub(-4) == ".png" or lower:sub(-4) == ".jpg" or lower:sub(-5) == ".jpeg" then
                    return as_asset(f)
                end
            end
            return as_asset(files[1])
        end

        local function ensure_gui()
            if targetesp_state.bill then return end
            local bill = Instance.new("BillboardGui")
            bill.Name = "RB_TargetESP"
            bill.AlwaysOnTop = true
            bill.LightInfluence = 0
            bill.Size = UDim2.new(targetesp_state.size, 0, targetesp_state.size, 0)
            bill.Enabled = true

            local img = Instance.new("ImageLabel")
            img.Name = "CrosshairImage"
            img.BackgroundTransparency = 1
            img.Size = UDim2.new(1, 0, 1, 0)
            img.Position = UDim2.fromScale(0, 0)
            -- prefer selected dropdown item; fallback to first asset; fallback to auto-pick
            if not targetesp_state.asset_items or not targetesp_state.asset_map then
                scan_assets()
            end
            local selected_name = (flags and flags["target_esp_image"]) or (targetesp_state.asset_items and targetesp_state.asset_items[1])
            img.Image = (selected_name and targetesp_state.asset_map and targetesp_state.asset_map[selected_name]) or (pick_asset_image() or "")
            img.ImageColor3 = targetesp_state.color
            img.Parent = bill

            targetesp_state.bill = bill
            targetesp_state.img = img
        end

        local function destroy_gui()
            if targetesp_state.bill then pcall(function() targetesp_state.bill:Destroy() end) end
            targetesp_state.bill = nil
            targetesp_state.img = nil
        end

        local function get_target_part()
            local player = targeting_state and targeting_state.current
            if not player or not player.Character then return nil end
            local char = player.Character
            local selected = flags and flags["aimbot_part"]
            if selected and char:FindFirstChild(selected) then
                return char[selected]
            end
            return utility:GetPreferredPart(char)
        end

        local function update_gui()
            if not targetesp_state.enabled then return end
            ensure_gui()

            local part = get_target_part()
            if not part then
                if targetesp_state.bill then targetesp_state.bill.Parent = nil end
                return
            end

            -- parent & adornee
            targetesp_state.bill.Adornee = part
            targetesp_state.bill.Parent = part

            -- distance scale
            local cam = (vars and vars.cam) or workspace.CurrentCamera
            local dist = (cam.CFrame.Position - part.Position).Magnitude
            local scale = math.clamp(dist / 30, 0.8, 4)
            local final = (flags and (flags["target_esp_size"])) or targetesp_state.size
            final = (final or 1) * scale
            targetesp_state.bill.Size = UDim2.new(final, 0, final, 0)

            -- rotation with delta time
            local now = os.clock()
            local dt = math.max(0, now - (targetesp_state.last_tick or now))
            targetesp_state.last_tick = now
            local spd = (flags and (flags["target_esp_speed"])) or targetesp_state.speed
            targetesp_state.angle = (targetesp_state.angle + (spd or 1) * 180 * dt) % 360
            if targetesp_state.img then
                targetesp_state.img.Rotation = targetesp_state.angle
                local color = (flags and flags["target_esp_color"]) or targetesp_state.color
                if type(color) == "table" then
                    -- Handle different color formats
                    if color.R and color.G and color.B then
                        -- Color3 format with uppercase
                        targetesp_state.img.ImageColor3 = Color3.new(color.R, color.G, color.B)
                    elseif color.r and color.g and color.b then
                        -- Color3 format with lowercase
                        targetesp_state.img.ImageColor3 = Color3.new(color.r, color.g, color.b)
                    else
                        -- Fallback to white if format unknown
                        targetesp_state.img.ImageColor3 = Color3.new(1, 1, 1)
                    end
                else
                    -- Already a Color3 object
                    targetesp_state.img.ImageColor3 = color
                end
            end
        end

        -- UI
        local tesp_toggle = VisSec:toggle({
            name = "TargetEsp",
            flag = "target_esp",
            default = false,
            callback = function(state)
                targetesp_state.enabled = state
                if state then
                    ensure_gui()
                    if not targetesp_state.conn then
                        targetesp_state.conn = vars.rs.RenderStepped:Connect(update_gui)
                        table.insert(library.connections, targetesp_state.conn)
                    end
                else
                    if targetesp_state.conn then
                        pcall(function() targetesp_state.conn:Disconnect() end)
                    end
                    targetesp_state.conn = nil
                    destroy_gui()
                end
            end,
        })
        tesp_toggle:colorpicker({
            name = "Color",
            flag = "target_esp_color",
            default = hex("#ffffff"),
            callback = function(color)
                targetesp_state.color = color
                if targetesp_state.img then targetesp_state.img.ImageColor3 = color end
            end,
        })

        local tesp_dep = VisSec:dependency_box()
        tesp_dep:setup_dependencies({ { tesp_toggle, true } })
        -- populate asset dropdown items once
        local items = (scan_assets())
        local default_item = (items and items[1]) or nil
        tesp_dep:dropdown({
            name = "Image",
            flag = "target_esp_image",
            items = items or {},
            default = default_item,
            callback = function(name)
                set_image_by_name(name)
            end
        })
        tesp_dep:slider({
            name = "Size",
            flag = "target_esp_size",
            min = 0.1,
            max = 40,
            default = 1,
            interval = 0.05,
            callback = function(v)
                targetesp_state.size = v
            end,
        })
        tesp_dep:slider({
            name = "Speed",
            flag = "target_esp_speed",
            min = 0.1,
            max = 10,
            default = 1,
            interval = 0.1,
            callback = function(v)
                targetesp_state.speed = v
            end,
        })

        -- cleanup on target cleared
        utility:OnTargetUpdate(function(info)
            if not info then
                destroy_gui()
            end
        end)

        -- cleanup on unload
        table.insert(library.connections, {
            Disconnect = function()
                if targetesp_state.conn then pcall(function() targetesp_state.conn:Disconnect() end) end
                targetesp_state.conn = nil
                destroy_gui()
            end
        })
    end
    -- TargetESP system end

    -- TargetTracer system
    do
        local tracer_state = {
            enabled = false,
            body_part = "HumanoidRootPart",
            origin = "mouse",
            line = nil,
            outline = nil,
            connection = nil,
            line_thickness = 2,
            outline_thickness = 4,
            line_color = Color3.fromRGB(255, 255, 255),
            outline_color = Color3.fromRGB(0, 0, 0),
            -- 3D style removed
        }
        
        local function cleanup_tracer()
            if tracer_state.line then
                pcall(function() tracer_state.line:Remove() end)
                tracer_state.line = nil
            end
            if tracer_state.outline then
                pcall(function() tracer_state.outline:Remove() end)
                tracer_state.outline = nil
            end
            -- 3D cleanup
            if tracer_state.beam_line then pcall(function() tracer_state.beam_line:Destroy() end) tracer_state.beam_line = nil end
            if tracer_state.beam_outline then pcall(function() tracer_state.beam_outline:Destroy() end) tracer_state.beam_outline = nil end
            if tracer_state.attach_a then pcall(function() tracer_state.attach_a:Destroy() end) tracer_state.attach_a = nil end
            if tracer_state.attach_b then pcall(function() tracer_state.attach_b:Destroy() end) tracer_state.attach_b = nil end
            if tracer_state.start_part then pcall(function() tracer_state.start_part:Destroy() end) tracer_state.start_part = nil end
            if tracer_state.end_part then pcall(function() tracer_state.end_part:Destroy() end) tracer_state.end_part = nil end
            if tracer_state.connection then
                tracer_state.connection:Disconnect()
                tracer_state.connection = nil
            end
        end

        local function ensure_3d()
            if tracer_state.start_part and tracer_state.end_part and tracer_state.beam_line and tracer_state.beam_outline then
                return
            end
            -- create holder parts
            local sp = Instance.new("Part")
            sp.Anchored = true
            sp.CanCollide = false
            sp.CanQuery = false
            sp.Size = Vector3.new(0.2, 0.2, 0.2)
            sp.Transparency = 1
            sp.Name = "TT_Start"
            sp.Parent = workspace
            tracer_state.start_part = sp

            local ep = Instance.new("Part")
            ep.Anchored = true
            ep.CanCollide = false
            ep.CanQuery = false
            ep.Size = Vector3.new(0.2, 0.2, 0.2)
            ep.Transparency = 1
            ep.Name = "TT_End"
            ep.Parent = workspace
            tracer_state.end_part = ep

            local a0 = Instance.new("Attachment")
            a0.Parent = sp
            tracer_state.attach_a = a0

            local a1 = Instance.new("Attachment")
            a1.Parent = ep
            tracer_state.attach_b = a1

            -- outline beam first (wider, black by default)
            local bout = Instance.new("Beam")
            bout.Attachment0 = a0
            bout.Attachment1 = a1
            bout.FaceCamera = true
            bout.Color = ColorSequence.new(tracer_state.outline_color)
            bout.Width0 = 0.3
            bout.Width1 = 0.3
            bout.ZOffset = 0.02
            bout.Transparency = NumberSequence.new(0)
            bout.Enabled = false
            bout.Parent = workspace
            tracer_state.beam_outline = bout

            -- main beam (narrower, on top)
            local bline = Instance.new("Beam")
            bline.Attachment0 = a0
            bline.Attachment1 = a1
            bline.FaceCamera = true
            bline.Color = ColorSequence.new(tracer_state.line_color)
            bline.Width0 = 0.15
            bline.Width1 = 0.15
            bline.ZOffset = 0
            bline.Transparency = NumberSequence.new(0)
            bline.Enabled = false
            bline.Parent = workspace
            tracer_state.beam_line = bline
        end
        
        local function create_tracer()
            if not tracer_state.enabled then
                cleanup_tracer()
                return
            end
            
            -- 3D style removed

            if not tracer_state.outline then
                tracer_state.outline = Drawing.new("Line")
                tracer_state.outline.Visible = false
                tracer_state.outline.Color = tracer_state.outline_color
                tracer_state.outline.Thickness = tracer_state.outline_thickness
            end
            
            if not tracer_state.line then
                tracer_state.line = Drawing.new("Line")
                tracer_state.line.Visible = false
                tracer_state.line.Color = tracer_state.line_color
                tracer_state.line.Thickness = tracer_state.line_thickness
            end
            
            if not tracer_state.connection then
                local RS = (vars and vars.rs) or game:GetService("RunService")
                local UIS = (vars and vars.uis) or game:GetService("UserInputService")
                local Camera = (workspace and workspace.CurrentCamera) or game:GetService("Workspace").CurrentCamera
                
                tracer_state.connection = RS.RenderStepped:Connect(function()
                    if not tracer_state.enabled or not targeting_state.current then
                        if tracer_state.line then tracer_state.line.Visible = false end
                        if tracer_state.outline then tracer_state.outline.Visible = false end
                        if tracer_state.beam_line then tracer_state.beam_line.Enabled = false end
                        if tracer_state.beam_outline then tracer_state.beam_outline.Enabled = false end
                        return
                    end
                    
                    local target = targeting_state.current
                    local char = target and target.Character
                    if not char then
                        if tracer_state.line then tracer_state.line.Visible = false end
                        if tracer_state.outline then tracer_state.outline.Visible = false end
                        return
                    end
                    
                    local part = char:FindFirstChild(tracer_state.body_part)
                    if not part then
                        if tracer_state.line then tracer_state.line.Visible = false end
                        if tracer_state.outline then tracer_state.outline.Visible = false end
                        return
                    end
                    
                    -- 3D style removed

                    local screen_pos, on_screen = Camera:WorldToViewportPoint(part.Position)
                    if not on_screen then
                        if tracer_state.line then tracer_state.line.Visible = false end
                        if tracer_state.outline then tracer_state.outline.Visible = false end
                        -- also hide 3D if exists
                        if tracer_state.beam_line then tracer_state.beam_line.Enabled = false end
                        if tracer_state.beam_outline then tracer_state.beam_outline.Enabled = false end
                        return
                    end
                    
                    local end_pos = Vector2.new(screen_pos.X, screen_pos.Y)
                    local start_pos
                    
                    if tracer_state.origin == "mouse" then
                        start_pos = UIS:GetMouseLocation()
                    elseif tracer_state.origin == "top" then
                        start_pos = Vector2.new(Camera.ViewportSize.X / 2, 0)
                    elseif tracer_state.origin == "bottom" then
                        start_pos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                    elseif tracer_state.origin == "center" then
                        start_pos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                    end
                    
                    if tracer_state.outline then
                        tracer_state.outline.From = start_pos
                        tracer_state.outline.To = end_pos
                        tracer_state.outline.Visible = true
                        tracer_state.outline.Thickness = tracer_state.outline_thickness
                    end
                    
                    if tracer_state.line then
                        tracer_state.line.From = start_pos
                        tracer_state.line.To = end_pos
                        tracer_state.line.Visible = true
                        tracer_state.line.Thickness = tracer_state.line_thickness
                        tracer_state.line.Color = tracer_state.line_color
                    end
                end)
            end
        end
        
        -- UI elements
        local tt_toggle = VisSec:toggle({
            name = "TargetTracer",
            flag = "target_tracer",
            default = false,
            callback = function(state)
                tracer_state.enabled = state
                if state then
                    create_tracer()
                else
                    cleanup_tracer()
                end
            end
        })
        
        -- colorpickers attached to toggle (CustomUI style)
        tt_toggle:colorpicker({
            name = "Out",
            flag = "tt_out",
            default = Color3.fromRGB(0, 0, 0),
            callback = function(color)
                tracer_state.outline_color = color
                if tracer_state.outline then
                    tracer_state.outline.Color = color
                end
            end
        })
        tt_toggle:colorpicker({
            name = "Fill",
            flag = "tt_fill",
            default = Color3.fromRGB(255, 255, 255),
            callback = function(color)
                tracer_state.line_color = color
                if tracer_state.line then
                    tracer_state.line.Color = color
                end
            end
        })

        -- dependency box для остальных настроек
        local tt_dep = VisSec:dependency_box()
        tt_dep:setup_dependencies({ { tt_toggle, true } })
        
        -- dropdowns
        tt_dep:dropdown({
            name = "Part",
            flag = "tt_part",
            items = {
                "HumanoidRootPart", "Head", "UpperTorso", "LowerTorso",
                "LeftUpperArm", "LeftLowerArm", "LeftHand",
                "RightUpperArm", "RightLowerArm", "RightHand",
                "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
                "RightUpperLeg", "RightLowerLeg", "RightFoot"
            },
            default = "HumanoidRootPart",
            callback = function(value)
                tracer_state.body_part = value
            end
        })
        
        tt_dep:dropdown({
            name = "Origin",
            flag = "tt_origin",
            items = { "mouse", "top", "bottom", "center" },
            default = "mouse",
            callback = function(value)
                tracer_state.origin = value
            end
        })
        
        -- Style dropdown removed (3D removed)
        
        -- hide tracer on target cleared (don't destroy, just hide)
        utility:OnTargetUpdate(function(info)
            if not info then
                -- только скрываем, не удаляем полностью
                if tracer_state.line then tracer_state.line.Visible = false end
                if tracer_state.outline then tracer_state.outline.Visible = false end
                if tracer_state.beam_line then tracer_state.beam_line.Enabled = false end
                if tracer_state.beam_outline then tracer_state.beam_outline.Enabled = false end
            end
        end)

        -- cleanup on unload
        table.insert(library.connections, {
            Disconnect = function()
                cleanup_tracer()
            end
        })
    end

  -- nuker runtime: continuously picks closest to mouse, no FOV, no keybind
  do
      local RunService = game:GetService("RunService")
      local Players = game:GetService("Players")
      local LocalPlayer = Players.LocalPlayer
      local Camera = workspace.CurrentCamera
      local UIS = game:GetService("UserInputService")

      local function get_preferred_part(char)
          return char and (char:FindFirstChild("HumanoidRootPart")
              or char:FindFirstChild("Head")
              or char:FindFirstChild("UpperTorso")
              or char:FindFirstChild("Torso"))
      end

      local conn = RunService.RenderStepped:Connect(function()
          if not flags then return end
          if not flags["Targeting_Enabled"] then return end
          if flags["Targeting_Mode"] ~= "Nuker" then return end

          local mouse = UIS:GetMouseLocation()
          local best_player, best_dist
          best_dist = math.huge

          for _, plr in ipairs(Players:GetPlayers()) do
              if plr ~= LocalPlayer then
                  local char = plr.Character
                  local part = get_preferred_part(char)
                  if part then
                      local screen, on_screen = Camera:WorldToViewportPoint(part.Position)
                      if on_screen then
                          local d = (mouse - Vector2.new(screen.X, screen.Y)).Magnitude
                          if d < best_dist then
                              best_dist = d
                              best_player = plr
                          end
                      end
                  end
              end
          end

          targeting_state.current = best_player
          -- visuals sync for Nuker (только при смене персонажа)
          if best_player then
              if flags and flags["target_highlight"] then
                  local char = best_player.Character
                  if char and (hl_state.last_char ~= char) then
                      apply_highlight(char)
                  end
              end
          else
              -- no target -> clear highlight если был активен
              if hl_state and hl_state.hl then
                  clear_highlight()
              end
          end
      end)
      table.insert(library.connections, conn)
  end
end
-- targeting system end

-- aimbot/prediction/resolver UI start
do
    -- create a single column on Rage and place multi-sections inside
    local RageCol = Aimbot:column()
    local AimSec, PredSec, ResSec = RageCol:multi_section({ names = { "Aimbot", "Prediction", "Resolver" } })
    -- Tweaks/OnDamage multi-section in the same column
    local Tweaks, OnDamage = RageCol:multi_section({ names = { "Tweaks", "OnDamage" } })
    
    -- ondamage system start
    do
        -- collect sounds from library directory
        local function get_sound_files()
            local items = {}
            local dir = (library and library.directory or "Rebuild.gg") .. "/sounds"
            local ok, files = pcall(function()
                return listfiles and listfiles(dir) or {}
            end)
            if ok and type(files) == "table" then
                for _, path in ipairs(files) do
                    -- get filename only
                    local name = path:match("[^/\\]+$")
                    if name then table.insert(items, name) end
                end
            end
            table.sort(items)
            return (#items > 0) and items or { "ding.ogg", "bell.wav", "hit.mp3" }
        end

        -- play helper
        local function play_hitsound(file)
            local SoundService = game:GetService("SoundService")
            local sound = SoundService:FindFirstChild("RB_HitSound")
            if not sound then
                sound = Instance.new("Sound")
                sound.Name = "RB_HitSound"
                sound.Looped = false
                sound.Parent = SoundService
            end
            local base = (library and library.directory or "Rebuild.gg") .. "/sounds/" .. tostring(file or "")
            local asset
            if getcustomasset then
                asset = getcustomasset(base)
            elseif getsynasset then
                asset = getsynasset(base)
            end
            if asset then
                sound.SoundId = asset
                sound.Volume = tonumber(flags["hs_volume"]) or 0.5
                local pitch = tonumber(flags["hs_pitch"]) or 1
                sound.PlaybackSpeed = pitch
                pcall(function() sound:Play() end)
            end
        end

        -- UI: hitsound
        local hs_toggle = OnDamage:toggle({ name = "Hitsounds", flag = "hitsound_enabled", default = false })
        local hs_dep = OnDamage:dependency_box()
        hs_dep:setup_dependencies({ { hs_toggle, true } })
        local hs_dropdown = hs_dep:dropdown({ name = "Sound", flag = "hs_file", items = get_sound_files() })
        hs_dep:slider({ name = "Vol", flag = "hs_volume", min = 0, max = 10, default = 0.5, interval = 0.05 })
        hs_dep:slider({ name = "Pitch", flag = "hs_pitch", min = 0.5, max = 2, default = 1, interval = 0.05 })
        hs_dep:toggle({ name = "MuteOriginalSound", flag = "hs_mute_original", default = false })

        -- sound muting framework (targets common hit sounds) per-toggle
        local V = { Sound = {} }
        V.Sound.TargetIds = V.Sound.TargetIds or {
            "rbxassetid://6773912589",
            "6773912589",
            "http://www.roblox.com/asset/?id=6773912589",
        }

        function V.Sound.MuteTargetSound(sound)
            if not sound or not sound:IsA("Sound") then return false end
            local soundId = tostring(sound.SoundId or ""):lower()
            for _, targetId in pairs(V.Sound.TargetIds) do
                if soundId:find(tostring(targetId):lower(), 1, true) then
                    if flags and flags["hs_mute_original"] then
                        pcall(function()
                            sound:Stop()
                            sound.Volume = 0
                            sound.Playing = false
                        end)
                        -- guard future re-plays
                        if not V.Sound._guarded then V.Sound._guarded = {} end
                        if not V.Sound._guarded[sound] then
                            V.Sound._guarded[sound] = sound:GetPropertyChangedSignal("Playing"):Connect(function()
                                if flags and flags["hs_mute_original"] and sound.Playing then
                                    pcall(function()
                                        sound:Stop()
                                        sound.Volume = 0
                                    end)
                                end
                            end)
                        end
                        return true
                    end
                end
            end
            return false
        end

        function V.Sound.MuteExistingSounds()
            for _, obj in ipairs(game:GetDescendants()) do
                if obj:IsA("Sound") then
                    V.Sound.MuteTargetSound(obj)
                end
            end
        end

        -- initial sweep and live hook
        task.defer(function()
            V.Sound.MuteExistingSounds()
        end)
        if not V.Sound._conn then
            V.Sound._conn = game.DescendantAdded:Connect(function(obj)
                if obj:IsA("Sound") then
                    V.Sound.MuteTargetSound(obj)
                end
            end)
        end

        -- runtime bind moved to single subscription at end
    end
    -- ondamage system end

    -- notifications system start
    do
        -- no armor helper (removed by request)

        -- build notification text
        local function build_notification_text(info)
            -- guard info and selection
            info = info or {}
            local parts = {}
            local raw_selected = (type(flags["notif_info"]) == "table") and flags["notif_info"] or {}
            -- normalize selected to array form
            local selected = {}
            if raw_selected[1] ~= nil then
                for i = 1, #raw_selected do
                    selected[#selected+1] = tostring(raw_selected[i])
                end
            else
                for k, v in pairs(raw_selected) do
                    if v then selected[#selected+1] = tostring(k) end
                end
            end
            
            -- get player name
            local name = ""
            if info.player then
                if typeof(info.player) == "Instance" then
                    if flags["notif_name"] == "DisplayName" then
                        name = info.player.DisplayName or info.player.Name or "Player"
                    else
                        name = info.player.Name or info.player.DisplayName or "Player"
                    end
                else
                    name = tostring(info.player)
                end
            end
            
            -- build info parts based on selection (no armor)
            for _, item in ipairs(selected) do
                if item == "Damage" and info.damage then
                    local dmg = tonumber(info.damage)
                    if dmg then table.insert(parts, "Dmg: " .. tostring(math.floor(dmg))) end
                elseif item == "Health" and info.health then
                    local hp = tonumber(info.health)
                    if hp then table.insert(parts, "HP: " .. tostring(math.floor(hp))) end
                elseif item == "RemainingHP" and info.remaining_health then
                    local r = tonumber(info.remaining_health)
                    if r then table.insert(parts, "Left: " .. tostring(math.floor(r))) end
                elseif item == "Part" and info.part then
                    table.insert(parts, "Part: " .. tostring(info.part))
                end
            end
            
            if #parts > 0 then
                return name .. " | " .. table.concat(parts, " | ")
            else
                return name .. " | Hit"
            end
        end

        -- UI: notifications
        local notif_toggle = OnDamage:toggle({ name = "Notifications", flag = "notif_enabled", default = false })
        local notif_dep = OnDamage:dependency_box()
        notif_dep:setup_dependencies({ { notif_toggle, true } })
        notif_dep:slider({ name = "Duration", flag = "notif_duration", min = 0.5, max = 3, default = 1.5, interval = 0.1 })
        notif_dep:dropdown({ 
            name = "Info", 
            flag = "notif_info", 
            items = { "Damage", "Health", "RemainingHP", "Part" },
            multi = true,
            default = { "Damage", "RemainingHP" }
        })
        notif_dep:dropdown({ 
            name = "Name", 
            flag = "notif_name", 
            items = { "DisplayName", "OriginalName" },
            default = "DisplayName"
        })

    end
    -- notifications system end

    -- build notification text from info
    local function build_notification_text(info)
        info = info or {}
        local parts = {}
        local raw_selected = (type(flags["notif_info"]) == "table") and flags["notif_info"] or {}
        
        -- normalize to array
        local selected = {}
        if raw_selected[1] ~= nil then
            for i = 1, #raw_selected do
                selected[#selected+1] = tostring(raw_selected[i])
            end
        else
            for k, v in pairs(raw_selected) do
                if v then selected[#selected+1] = tostring(k) end
            end
        end
        
        -- get name
        local name = ""
        if info.player then
            if typeof(info.player) == "Instance" then
                if flags["notif_name"] == "DisplayName" then
                    name = info.player.DisplayName or info.player.Name or "Player"
                else
                    name = info.player.Name or info.player.DisplayName or "Player"
                end
            else
                name = tostring(info.player)
            end
        end
        
        -- build parts
        for _, item in ipairs(selected) do
            if item == "Damage" and info.damage then
                local dmg = tonumber(info.damage)
                if dmg then table.insert(parts, "Dmg: " .. tostring(math.floor(dmg))) end
            elseif item == "Health" and info.health then
                local hp = tonumber(info.health)
                if hp then table.insert(parts, "HP: " .. tostring(math.floor(hp))) end
            elseif item == "RemainingHP" and info.remaining_health then
                local r = tonumber(info.remaining_health)
                if r then table.insert(parts, "Left: " .. tostring(math.floor(r))) end
            elseif item == "Part" and info.part then
                table.insert(parts, "Part: " .. tostring(info.part))
            end
        end
        
        -- combine
        if #parts > 0 then
            return name .. " | " .. table.concat(parts, " | ")
        else
            return name .. " | Hit"
        end
    end

    -- single OnHit subscription for all features
    utility:OnHit(function(info)
        -- hitsounds
        if flags and flags["hitsound_enabled"] then
            local file = flags["hs_file"]
            if file and file ~= "" then
                play_hitsound(file)
            end
        end
        
        -- notifications
        if not flags or not flags["notif_enabled"] then return end
        
        -- enrich info
        if info and info.player and info.player.Character then
            local char = info.player.Character
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid then
                info.health = humanoid.Health
                info.remaining_health = humanoid.Health
            end
        end
        
        -- build text
        local text = build_notification_text(info)
        local duration = tonumber(flags["notif_duration"]) or 1.5
        if duration <= 0 or duration > 10 or duration ~= duration then
            duration = 1.5
        end
        
        -- show notification
        if library then
            library:notification({
                text = text,
                time = duration
            })
        end
    end)

    -- Aimbot section
    local aimbot_toggle = AimSec:toggle({
        name = "Enabled",
        flag = "aimbot_enabled",
        default = false,
    })
    local aimbot_dep = AimSec:dependency_box()
    aimbot_dep:setup_dependencies({ { aimbot_toggle, true } })
    aimbot_dep:dropdown({
        name = "Part",
        flag = "aimbot_part",
        items = {
            "HumanoidRootPart","Head","UpperTorso","LowerTorso",
            "LeftUpperArm","LeftLowerArm","LeftHand","RightUpperArm","RightLowerArm","RightHand",
            "LeftUpperLeg","LeftLowerLeg","LeftFoot","RightUpperLeg","RightLowerLeg","RightFoot"
        },
        default = "HumanoidRootPart",
    })

    -- Prediction section
    local pred_toggle = PredSec:toggle({
        name = "Enabled",
        flag = "pred_enabled",
        default = false,
    })
    local pred_dep = PredSec:dependency_box()
    pred_dep:setup_dependencies({ { pred_toggle, true } })
    local mode_dd = pred_dep:dropdown({
        name = "Mode",
        flag = "pred_mode",
        items = { "Sets", "Auto" },
        default = "Sets",
    })
    
    -- XYZ labels and textboxes (visible only in Sets mode)
    local sets_dep = PredSec:dependency_box()
    sets_dep:setup_dependencies({ { pred_toggle, true }, { mode_dd, "Sets" } })
    sets_dep:label({ name = "PredictionX" })
    sets_dep:textbox({ flag = "pred_x", default = "0" })
    sets_dep:label({ name = "PredictionY" })
    sets_dep:textbox({ flag = "pred_y", default = "0" })
    sets_dep:label({ name = "PredictionZ" })
    sets_dep:textbox({ flag = "pred_z", default = "0" })
    
    -- Show prediction tracer
    PredSec:toggle({
        name = "ShowPrediction",
        flag = "show_prediction",
        default = false,
    }):colorpicker({
        name = "Color",
        flag = "prediction_color",
        default = hex("#ffffff"),
    })

    -- Resolver section
    local res_toggle = ResSec:toggle({
        name = "Enabled",
        flag = "resolver_enabled",
        default = false,
    })
    local res_dep = ResSec:dependency_box()
    res_dep:setup_dependencies({ { res_toggle, true } })
    res_dep:dropdown({
        name = "Mode",
        flag = "resolver_mode",
        items = { "Velocity", "Recalculate", "MoveDirection", "LookVector", "CalculateCFrame" },
        default = "Velocity",
    })
end
-- aimbot/prediction/resolver UI end

-- aimbot runtime start
do
    -- preferences
    local PreferredParts = { "HumanoidRootPart", "Head", "UpperTorso", "Torso" }

    -- ping -> scalar prediction table (Auto mode)
    local predictionTable = {
        {20,0.08960952},
        {21,0.091171428},{22,0.092733336},{23,0.094295244},{24,0.095857152},{25,0.09741906},
        {26,0.098980968},{27,0.100542876},{28,0.102104784},{29,0.103666692},{30,0.11252476},
        {31,0.112978758},{32,0.113432756},{33,0.113886754},{34,0.114340752},{35,0.11479475},
        {36,0.115248748},{37,0.115702746},{38,0.116156744},{39,0.116610742},{40,0.11706474},
        {41,0.117518738},{42,0.117972736},{43,0.118426734},{44,0.118880732},{45,0.11933473},
        {46,0.119788728},{47,0.120242726},{48,0.120696724},{49,0.121150722},{50,0.13544},
        {51,0.1348236},{52,0.1342072},{53,0.1335908},{54,0.1329744},{55,0.132358},
        {56,0.1317416},{57,0.1311252},{58,0.1305088},{59,0.1298924},{60,0.129276},
        {61,0.1286596},{62,0.1280432},{63,0.1274268},{64,0.1268104},{65,0.1264236},
        {66,0.1262627},{67,0.1261018},{68,0.1259409},{69,0.12578},{70,0.12533},
        {71,0.125474},{72,0.125618},{73,0.125762},{74,0.125906},{75,0.12605},
        {76,0.126194},{77,0.126338},{78,0.126482},{79,0.126626},{80,0.13934},
        {81,0.1395937},{82,0.1398474},{83,0.1401011},{84,0.1403548},{85,0.1406085},
        {86,0.1408622},{87,0.1411159},{88,0.1413696},{89,0.1416233},{90,0.141877},
        {91,0.1421307},{92,0.1423844},{93,0.1426381},{94,0.1428918},{95,0.1431455},
        {96,0.1433992},{97,0.1436529},{98,0.1439066},{99,0.1441603},{100,0.141987},
        {101,0.1423107},{102,0.1426344},{103,0.1429581},{104,0.1432818},{105,0.1436055},
        {106,0.1439292},{107,0.1442529},{108,0.1445766},{109,0.1449003},{110,0.144634},
        {111,0.1449577},{112,0.1452814},{113,0.1456051},{114,0.1459288},{115,0.1462525},
        {116,0.1465762},{117,0.1468999},{118,0.1472236},{119,0.1475473},{120,0.147281},
        {121,0.1476047},{122,0.1479284},{123,0.1482521},{124,0.1485758},{125,0.1488995},
        {126,0.1492232},{127,0.1495469},{128,0.1498706},{129,0.1501943},{130,0.149928},
        {131,0.1502517},{132,0.1505754},{133,0.1508991},{134,0.1512228},{135,0.1515465},
        {136,0.1518702},{137,0.1521939},{138,0.1525176},{139,0.1528413},{140,0.152575},
        {141,0.1528987},{142,0.1532224},{143,0.1535461},{144,0.1538698},{145,0.1541935},
        {146,0.1545172},{147,0.1548409},{148,0.1551646},{149,0.1554883},{150,0.155222},
        {151,0.1555457},{152,0.1558694},{153,0.1561931},{154,0.1565168},{155,0.1568405},
        {156,0.1571642},{157,0.1574879},{158,0.1578116},{159,0.1581353},{160,0.157869},
        {161,0.1581927},{162,0.1585164},{163,0.1588401},{164,0.1591638},{165,0.1594875},
        {166,0.1598112},{167,0.1601349},{168,0.1604586},{169,0.1607823},{170,0.160516},
        {171,0.1608397},{172,0.1611634},{173,0.1614871},{174,0.1618108},{175,0.1621345},
        {176,0.1624582},{177,0.1627819},{178,0.1631056},{179,0.1634293},{180,0.163163},
        {181,0.1634867},{182,0.1638104},{183,0.1641341},{184,0.1644578},{185,0.1647815},
        {186,0.1651052},{187,0.1654289},{188,0.1657526},{189,0.1660763},{190,0.16581},
        {191,0.1661337},{192,0.1664574},{193,0.1667811},{194,0.1671048},{195,0.1674285},
        {196,0.1677522},{197,0.1680759},{198,0.1683996},{199,0.1687233},{200,0.168457},
        {201,0.1687807},{202,0.1691044},{203,0.1694281},{204,0.1697518},{205,0.1700755},
        {206,0.1703992},{207,0.1707229},{208,0.1710466},{209,0.1713703},{210,0.171104},
        {211,0.1714277},{212,0.1717514},{213,0.1720751},{214,0.1723988},{215,0.1727225},
        {216,0.1730462},{217,0.1733699},{218,0.1736936},{219,0.1740173},{220,0.173751},
        {221,0.1740747},{222,0.1743984},{223,0.1747221},{224,0.1750458},{225,0.1753695},
        {226,0.1756932},{227,0.1760169},{228,0.1763406},{229,0.1766643},{230,0.176398},
        {231,0.1767217},{232,0.1770454},{233,0.1773691},{234,0.1776928},{235,0.1780165},
        {236,0.1783402},{237,0.1786639},{238,0.1789876},{239,0.1793113},{240,0.179045},
        {241,0.1793687},{242,0.1796924},{243,0.1800161},{244,0.1803398},{245,0.1806635},
        {246,0.1809872},{247,0.1813109},{248,0.1816346},{249,0.1819583},{250,0.181692},
        {251,0.1820157},{252,0.1823394},{253,0.1826631},{254,0.1829868},{255,0.1833105},
        {256,0.1836342},{257,0.1839579},{258,0.1842816},{259,0.1846053},{260,0.184339},
        {261,0.1846627},{262,0.1849864},{263,0.1853101},{264,0.1856338},{265,0.1859575},
        {266,0.1862812},{267,0.1866049},{268,0.1869286},{269,0.1872523},{270,0.186986},
        {271,0.1873097},{272,0.1876334},{273,0.1879571},{274,0.1882808},{275,0.1886045},
        {276,0.1889282},{277,0.1892519},{278,0.1895756},{279,0.1898993},{280,0.189633},
        {281,0.1899567},{282,0.1902804},{283,0.1906041},{284,0.1909278},{285,0.1912515},
        {286,0.1915752},{287,0.1918989},{288,0.1922226},{289,0.1925463},{290,0.19228},
        {291,0.1926037},{292,0.1929274},{293,0.1932511},{294,0.1935748},{295,0.1938985},
        {296,0.1942222},{297,0.1945459},{298,0.1948696},{299,0.1951933},{300,0.194927}
    }

    local function get_auto_scalar()
        local stats = game:GetService("Stats")
        local pingMs
        local ok, _ = pcall(function()
            local s = stats.Network.ServerStatsItem["Data Ping"]:GetValueString() -- e.g. "45 ms"
            pingMs = tonumber((s or ""):match("%d+"))
        end)
        if not ok or not pingMs then return 0 end
        local bestVal, bestDiff
        for _, pair in ipairs(predictionTable) do
            local diff = math.abs(pingMs - pair[1])
            if not bestDiff or diff < bestDiff then
                bestDiff = diff
                bestVal = pair[2]
            end
        end
        return bestVal or 0
    end

    local function get_target_part(player)
        if not player or not player.Character then return nil end
        local char = player.Character
        -- prefer user-selected part
        local selected = flags and flags["aimbot_part"]
        if selected and char:FindFirstChild(selected) then
            return char[selected]
        end
        for _, name in ipairs(PreferredParts) do
            local p = char:FindFirstChild(name)
            if p then return p end
        end
        return nil
    end

    local resolver_cache = { lastPos = nil, lastTick = nil, lastPart = nil }

    local function get_predicted_position(part)
        if not part then return nil end
        local pos = part.Position
        if flags["pred_enabled"] then
            -- resolver velocity selection
            local vel
            local resolverOn = flags["resolver_enabled"]
            local modeRes = flags["resolver_mode"]
            if resolverOn and modeRes and modeRes ~= "Velocity" then
                if modeRes == "Recalculate" or modeRes == "CalculateCFrame" then
                    if resolver_cache.lastPart ~= part then
                        resolver_cache.lastPos, resolver_cache.lastTick, resolver_cache.lastPart = part.Position, tick(), part
                    end
                    local now = tick()
                    local dt = (resolver_cache.lastTick and (now - resolver_cache.lastTick)) or 0
                    if dt > 0 and resolver_cache.lastPos then
                        vel = (part.Position - resolver_cache.lastPos) / dt
                    else
                        vel = part.AssemblyLinearVelocity or part.Velocity or Vector3.zero
                    end
                    resolver_cache.lastPos, resolver_cache.lastTick = part.Position, now
                elseif modeRes == "MoveDirection" then
                    local humanoid = part.Parent and part.Parent:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        vel = humanoid.MoveDirection * (humanoid.WalkSpeed or 16)
                    end
                elseif modeRes == "LookVector" then
                    local humanoid = part.Parent and part.Parent:FindFirstChildOfClass("Humanoid")
                    local speed = (humanoid and humanoid.WalkSpeed) or 16
                    vel = part.CFrame.LookVector * (speed * 1.5)
                end
            end
            vel = vel or part.AssemblyLinearVelocity or part.Velocity or Vector3.zero
            local mode = flags["pred_mode"]
            if mode == "Auto" then
                local s = get_auto_scalar()
                pos = pos + (vel * Vector3.new(s, s, s))
            else
                local vx = tonumber(flags["pred_x"]) or 0
                local vy = tonumber(flags["pred_y"]) or 0
                local vz = tonumber(flags["pred_z"]) or 0
                pos = pos + (vel * Vector3.new(vx, vy, vz))
            end
        end
        return pos
    end

    local mt = getrawmetatable(game)
    local oldIndex = mt.__index
    setreadonly(mt, false)

    mt.__index = newcclosure(function(self, key)
        -- enable only when aimbot is on
        if not checkcaller() and key and (key == "Hit" or key == "Silent" or key == "Target") and flags and flags["aimbot_enabled"] then
            local player = targeting_state.current
            local part = get_target_part(player)
            if part then
                local predicted = get_predicted_position(part) or part.Position
                if key == "Hit" then
                    return CFrame.new(predicted)
                elseif key == "Silent" or key == "Target" then
                    return part
                end
            end
        end
        return oldIndex(self, key)
    end)

    setreadonly(mt, true)
end
-- aimbot runtime end

-- prediction tracer runtime start
do
    local Drawing = Drawing
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera
    
    -- guard against duplicates: cleanup previous tracer if exists
    do
        local prev = getgenv().PredictionTracer
        if prev and prev.cleanup then
            pcall(prev.cleanup)
        end
    end
    local PT = { }
    getgenv().PredictionTracer = PT
    
    -- create tracer outline (for nicer look)
    local tracerOutline = Drawing.new("Line")
    tracerOutline.Visible = false
    tracerOutline.Thickness = 6 -- base, will sync to tracer.Thickness + 2
    tracerOutline.Transparency = 0.7
    tracerOutline.Color = Color3.fromRGB(0, 0, 0)
    PT.tracerOutline = tracerOutline
    
    -- create tracer line
    local tracer = Drawing.new("Line")
    tracer.Visible = false
    tracer.Thickness = 1.5 -- slightly thinner
    tracer.Transparency = 1
    PT.tracer = tracer
    
    -- base tip radius for end circles
    local baseTipR = 4
    
    -- endpoint circles (start/end) with outlines
    local startOutline = Drawing.new("Circle")
    startOutline.Visible = false
    startOutline.Filled = false -- outline stroke to match tracer thickness
    startOutline.Color = Color3.fromRGB(0, 0, 0)
    startOutline.Transparency = 0.8
    startOutline.Radius = 4 -- outline radius
    PT.startOutline = startOutline
    
    local startCircle = Drawing.new("Circle")
    startCircle.Visible = false
    startCircle.Filled = true
    startCircle.Color = Color3.fromRGB(255, 255, 255)
    startCircle.Transparency = 1
    startCircle.Radius = 2
    PT.startCircle = startCircle
    
    local endOutline = Drawing.new("Circle")
    endOutline.Visible = false
    endOutline.Filled = false -- outline stroke to match tracer thickness
    endOutline.Color = Color3.fromRGB(0, 0, 0)
    endOutline.Transparency = 0.8
    endOutline.Radius = 4
    PT.endOutline = endOutline
    
    local endCircle = Drawing.new("Circle")
    endCircle.Visible = false
    endCircle.Filled = true
    endCircle.Color = Color3.fromRGB(255, 255, 255)
    endCircle.Transparency = 1
    endCircle.Radius = 2
    PT.endCircle = endCircle
    
    -- preferences (reuse from aimbot)
    local PreferredParts = { "HumanoidRootPart", "Head", "UpperTorso", "Torso" }
    -- ping -> scalar prediction table (Auto mode)
    local predictionTable = {
        {20, 0.08960952},{30, 0.11252476},{50, 0.13544},{65, 0.1264236},{70, 0.12533},
        {80, 0.13934},{100, 0.141987},{110, 0.144634},{120, 0.147281},{130, 0.149928},
        {140, 0.152575},{150, 0.155222},{160, 0.157869},{170, 0.160516},{180, 0.163163},
        {190, 0.16581},{200, 0.168457},{210, 0.171104},{220, 0.173751},{230, 0.176398},
        {240, 0.179045},{250, 0.181692},{260, 0.184339},{270, 0.186986},{280, 0.189633},
        {290, 0.19228},{300, 0.194927}
    }

    local lastAuto = { t = 0, val = 0 }
    local function get_auto_scalar()
        local now = tick and tick() or os.clock()
        if now - (lastAuto.t or 0) < 0.25 then
            return lastAuto.val or 0
        end
        local stats = game:GetService("Stats")
        local pingMs
        local ok, _ = pcall(function()
            local s = stats.Network.ServerStatsItem["Data Ping"]:GetValueString()
            pingMs = tonumber((s or ""):match("%d+"))
        end)
        if not ok or not pingMs then return lastAuto.val or 0 end
        local bestVal, bestDiff
        for _, pair in ipairs(predictionTable) do
            local diff = math.abs(pingMs - pair[1])
            if not bestDiff or diff < bestDiff then
                bestDiff = diff
                bestVal = pair[2]
            end
        end
        lastAuto.t = now
        lastAuto.val = bestVal or lastAuto.val or 0
        return lastAuto.val or 0
    end
    
    local function get_target_part(player)
        if not player or not player.Character then return nil end
        local char = player.Character
        -- prefer user-selected part
        local selected = flags and flags["aimbot_part"]
        if selected and char:FindFirstChild(selected) then
            return char[selected]
        end
        for _, name in ipairs(PreferredParts) do
            local p = char:FindFirstChild(name)
            if p then return p end
        end
        return nil
    end
    
    local function get_predicted_position(part)
        if not part then return nil end
        local pos = part.Position
        if flags["pred_enabled"] then
            local vel = part.AssemblyLinearVelocity or part.Velocity or Vector3.zero
            local mode = flags["pred_mode"]
            if mode == "Auto" then
                local s = get_auto_scalar()
                pos = pos + (vel * Vector3.new(s, s, s))
            else
                local vx = tonumber(flags["pred_x"]) or 0
                local vy = tonumber(flags["pred_y"]) or 0
                local vz = tonumber(flags["pred_z"]) or 0
                pos = pos + (vel * Vector3.new(vx, vy, vz))
            end
        end
        return pos
    end
    
    -- update tracer
    local conn = RunService.RenderStepped:Connect(function()
        if flags["show_prediction"] and targeting_state.current then
            local part = get_target_part(targeting_state.current)
            if part then
                local predicted = get_predicted_position(part)
                if predicted then
                    local screen_pos, on_screen = Camera:WorldToViewportPoint(predicted)
                    if on_screen then
                        -- get mouse position
                        local mouse_pos = UserInputService:GetMouseLocation()
                        
                        -- update tracer outline (behind main line)
                        tracerOutline.From = mouse_pos
                        tracerOutline.To = Vector2.new(screen_pos.X, screen_pos.Y)
                        tracerOutline.Thickness = math.max(1, (tracer.Thickness or 2) + 2)
                        if not tracerOutline.Visible then tracerOutline.Visible = true end

                        -- update tracer
                        tracer.From = mouse_pos
                        tracer.To = Vector2.new(screen_pos.X, screen_pos.Y)
                        local newColor = (flags["prediction_color"] and flags["prediction_color"].Color) or Color3.fromRGB(255, 255, 255)
                        if tracer.Color ~= newColor then tracer.Color = newColor end
                        if not tracer.Visible then tracer.Visible = true end

                        -- update endpoint circles
                        local tipColor = tracer.Color
                        local endPos = Vector2.new(screen_pos.X, screen_pos.Y)

                        -- inner circles first (to use their radius for outlines)
                        startCircle.Position = mouse_pos
                        startCircle.Radius = math.max(1, baseTipR * 0.25) -- mouse tip: 0.25x
                        if startCircle.Color ~= tipColor then startCircle.Color = tipColor end
                        if not startCircle.Visible then startCircle.Visible = true end

                        endCircle.Position = endPos
                        endCircle.Radius = math.max(1, baseTipR * 0.5) -- end tip: 0.5x
                        if endCircle.Color ~= tipColor then endCircle.Color = tipColor end
                        if not endCircle.Visible then endCircle.Visible = true end

                        -- outlines sync after inner set
                        local outlineThk = math.max(1, (tracer.Thickness or 2) + 2)
                        startOutline.Position = mouse_pos
                        startOutline.Thickness = outlineThk
                        startOutline.Radius = startCircle.Radius + (outlineThk / 2)
                        if not startOutline.Visible then startOutline.Visible = true end

                        endOutline.Position = endPos
                        endOutline.Thickness = outlineThk
                        endOutline.Radius = endCircle.Radius + (outlineThk / 2)
                        if not endOutline.Visible then endOutline.Visible = true end
                    else
                        if tracer.Visible then tracer.Visible = false end
                        if tracerOutline.Visible then tracerOutline.Visible = false end
                        if startCircle.Visible then startCircle.Visible = false end
                        if endCircle.Visible then endCircle.Visible = false end
                        if startOutline.Visible then startOutline.Visible = false end
                        if endOutline.Visible then endOutline.Visible = false end
                    end
                else
                    if tracer.Visible then tracer.Visible = false end
                    if tracerOutline.Visible then tracerOutline.Visible = false end
                    if startCircle.Visible then startCircle.Visible = false end
                    if endCircle.Visible then endCircle.Visible = false end
                    if startOutline.Visible then startOutline.Visible = false end
                    if endOutline.Visible then endOutline.Visible = false end
                end
            else
                if tracer.Visible then tracer.Visible = false end
                if tracerOutline.Visible then tracerOutline.Visible = false end
                if startCircle.Visible then startCircle.Visible = false end
                if endCircle.Visible then endCircle.Visible = false end
                if startOutline.Visible then startOutline.Visible = false end
                if endOutline.Visible then endOutline.Visible = false end
            end
        else
            if tracer.Visible then tracer.Visible = false end
            if tracerOutline.Visible then tracerOutline.Visible = false end
            if startCircle.Visible then startCircle.Visible = false end
            if endCircle.Visible then endCircle.Visible = false end
            if startOutline.Visible then startOutline.Visible = false end
            if endOutline.Visible then endOutline.Visible = false end
        end
    end)
    table.insert(library.connections, conn)
    PT.conn = conn

    -- provide cleanup for future reloads
    PT.cleanup = function()
        pcall(function() if PT.conn then PT.conn:Disconnect() end end)
        local function safe_remove(obj)
            if obj and obj.Remove then pcall(function() obj:Remove() end) end
        end
        safe_remove(PT.tracer)
        safe_remove(PT.tracerOutline)
        safe_remove(PT.startCircle)
        safe_remove(PT.startOutline)
        safe_remove(PT.endCircle)
        safe_remove(PT.endOutline)
        getgenv().PredictionTracer = nil
    end
end
-- prediction tracer runtime end

-- target tracer system start
do
    local vars = {
        rs = game:GetService("RunService"),
        uis = game:GetService("UserInputService"),
        camera = workspace.CurrentCamera
    }
    
    -- tracer state
    local tracer_state = {
        line = nil,
        line_outline = nil,
        enabled = false,
        part = "HumanoidRootPart",
        origin = "mouse",
        connection = nil
    }
    
    -- r15 body parts
    local r15_parts = {
        "Head", "UpperTorso", "LowerTorso", "HumanoidRootPart",
        "LeftUpperArm", "LeftLowerArm", "LeftHand",
        "RightUpperArm", "RightLowerArm", "RightHand",
        "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
        "RightUpperLeg", "RightLowerLeg", "RightFoot"
    }
    
    -- cleanup function
    local function cleanup_tracer()
        if tracer_state.line then
            pcall(function() tracer_state.line:Remove() end)
            tracer_state.line = nil
        end
        if tracer_state.line_outline then
            pcall(function() tracer_state.line_outline:Remove() end)
            tracer_state.line_outline = nil
        end
        if tracer_state.connection then
            pcall(function() tracer_state.connection:Disconnect() end)
            tracer_state.connection = nil
        end
    end

end

getgenv().load_config = function(name)
	library:load_config(readfile(library.directory .. "/configs/" .. name .. ".cfg"))
end

local column = Settings:column()
local section = column:section({ name = "Options" })
local old_config = library:get_config()
config_holder = section:list({ flag = "config_name_list" })
section:textbox({ flag = "config_name_text_box" })
section:button_holder({})
section:button({
    name = "Create",
    callback = function()
        writefile(library.directory .. "/configs/" .. flags["config_name_text_box"] .. ".cfg", library:get_config())
        library:config_list_update()
    end,
})
section:button({
	name = "Delete",
	callback = function()
		delfile(library.directory .. "/configs/" .. flags["config_name_list"] .. ".cfg")
		library:config_list_update()
	end,
})
section:button_holder({})
section:button({
	name = "Load",
	callback = function()
		library:load_config(readfile(library.directory .. "/configs/" .. flags["config_name_list"] .. ".cfg"))
		library:notification({
			text = "Loaded Config: " .. flags["config_name_list"],
			time = 3,
		})
	end,
})
section:button({
	name = "Save",
	callback = function()
		writefile(library.directory .. "/configs/" .. flags["config_name_list"] .. ".cfg", library:get_config())
		library:config_list_update()
		library:notification({
			text = "Saved Config: " .. flags["config_name_list"],
			time = 3,
		})
	end,
})
section:button_holder({})
section:button({
	name = "Refresh Configs",
	callback = function()
		library:config_list_update()
	end,
})
section:button_holder({})
section:button({
	name = "Unload Config",
	callback = function()
		library:load_config(old_config)
	end,
})
section:button({
	name = "Unload Menu",
	callback = function()
		library:load_config(old_config)

		for _, gui in library.guis do
			gui:Destroy()
		end

		for _, connection in library.connections do
			connection:Disconnect()
		end
	end,
})

local Theme, Game, HUD = Settings:column():multi_section({ names = { "Theme", "Game", "HUD" } })
Theme:label({ name = "Accent" }):colorpicker({
	name = "Accent",
	color = hex("#ffffff"),
	flag = "accent",
	callback = function(color, alpha)
		library:update_theme("accent", color)
	end,
})
Theme
	:label({ name = "Contrast" })
	:colorpicker({
		name = "Low",
		color = hex("#2d2d2d"),
		flag = "low_contrast",
		callback = function(color)
			if flags["high_contrast"] and flags["low_contrast"] then
				library:update_theme(
					"contrast",
					rgbseq({
						rgbkey(0, flags["low_contrast"].Color),
						rgbkey(1, flags["high_contrast"].Color),
					})
				)
			end
		end,
	})
	:colorpicker({
		name = "High",
		color = hex("#101010"),
		flag = "high_contrast",
		callback = function(color)
			library:update_theme(
				"contrast",
				rgbseq({
					rgbkey(0, flags["low_contrast"].Color),
					rgbkey(1, flags["high_contrast"].Color),
				})
			)
		end,
	})
Theme:label({ name = "Inline" }):colorpicker({
	name = "Inline",
	color = hex("#313131"),
	flag = "theme_inline",
	callback = function(color, alpha)
		library:update_theme("inline", color)
	end,
})
Theme:label({ name = "Outline" }):colorpicker({
	name = "Outline",
	color = hex("#000000"),
	flag = "theme_outline",
	callback = function(color, alpha)
		library:update_theme("outline", color)
	end,
})
Theme
	:label({ name = "Text Color" })
	:colorpicker({
		name = "Main",
		color = hex("#7b7b7b"),
		flag = "theme_text",
		callback = function(color, alpha)
			library:update_theme("text", color)
		end,
	})
	:colorpicker({
		name = "Outline",
		color = hex("#282828"),
		flag = "theme_text_outline",
		callback = function(color, alpha)
			library:update_theme("text_outline", color)
		end,
	})
Theme:label({ name = "Glow" }):colorpicker({
	name = "Glow",
	color = hex("#ffffff"),
	flag = "theme_glow",
	callback = function(color, alpha)
		library:update_theme("glow", color)
	end,
})
HUD:label({ name = "UI Bind" }):keybind({
	callback = window.set_menu_visibility,
	key = Enum.KeyCode.Insert,
})
HUD:toggle({
	name = "Keybind List",
	flag = "keybind_list",
	callback = function(bool)
		library.keybind_list_frame.Visible = bool
	end,
})
HUD:toggle({
    name = "CustomUI",
    flag = "custom_hud_enabled",
    callback = function(bool)
        custom_hud.set_visible(bool)
    end,
})
:colorpicker({
    name = "Health",
    flag = "hud_health_color",
    color = custom_hud.colors.health_bar,
    callback = function(color)
        custom_hud.colors.health_bar = color
        custom_hud.update_bar_colors()
    end,
})
:colorpicker({
    name = "Armor",
    flag = "hud_armor_color",
    color = custom_hud.colors.armor_bar,
    callback = function(color)
        custom_hud.colors.armor_bar = color
        custom_hud.update_bar_colors()
    end,
})
:colorpicker({
    name = "Text",
    flag = "hud_text_color",
    color = custom_hud.colors.text,
    callback = function(color)
        custom_hud.colors.text = color
        custom_hud.update_bar_colors()
    end,
})


-- build watermark text based on selected HUD -> Watermark -> Type items
local PLACE_NAME_CACHE
local function build_watermark_text()
    local sel = flags["watermark_type"]
    local out = {}

    -- cache place name once
    local function get_place_name()
        if PLACE_NAME_CACHE ~= nil then
            return PLACE_NAME_CACHE
        end
        local ok, info = pcall(function()
            return game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId)
        end)
        local name = ok and info and info.Name or tostring(game.PlaceId)
        PLACE_NAME_CACHE = name
        return name
    end

    if type(sel) == "table" then
        -- normalize selection to a set for stable ordering output
        local selected = {}
        for _, key in next, sel do selected[key] = true end
        if selected["Date"] then out[#out + 1] = os.date("%y:%m:%d") end
        if selected["Time"] then out[#out + 1] = os.date("%H:%M:%S") end
        if selected["Place"] then out[#out + 1] = get_place_name() end
        if selected["User"] then out[#out + 1] = (lp and lp.Name or "?") end
    end

    if #out == 0 then
        -- fallback: keep prior behavior-like time stamp
        out[1] = os.date("%H:%M:%S")
    end

    return "Rebuild.gg - " .. table.concat(out, " - ")
end

local wm_toggle = HUD:toggle({
    name = "Watermark",
    flag = "watermark",
    callback = function(bool)
        watermark.set_visible(bool)
        if bool then
            -- immediate refresh on toggle enable
            watermark.change_text(build_watermark_text())
        end
    end,
})
local wm_dep = HUD:dependency_box()
wm_dep:setup_dependencies({
    { wm_toggle, true }
})
wm_dep:dropdown({
    name = "Type",
    flag = "watermark_type",
    items = { "Time", "Date", "Place", "User" },
    multi = true,
    default = { "Time" },
    callback = function(selected)
        -- immediate refresh on selection change
        watermark.change_text(build_watermark_text())
    end,
})

-- radar hud start
local radar_toggle = HUD:toggle({
    name = "Radar",
    flag = "hud_radar",
    callback = function(bool)
        radar.set_visible(bool)
    end,
})
local radar_dep = HUD:dependency_box()
radar_dep:setup_dependencies({
    { radar_toggle, true },
})
radar_dep:slider({
    name = "Zoom",
    flag = "radar_zoom",
    min = 0.1,
    max = 2,
    default = 1,
    interval = 0.1,
    callback = function(v)
        radar.set_zoom(v)
    end,
})
-- radar hud end
Game:button_holder({})
Game:button({
	name = "Copy JobId",
	callback = function()
		setclipboard(game.JobId)
	end,
})
Game:button_holder({})
Game:button({
	name = "Copy GameID",
	callback = function()
		setclipboard(game.GameId)
	end,
})
Game:button_holder({})
Game:button({
	name = "Copy Join Script",
	callback = function()
		setclipboard(
			'game:GetService("TeleportService"):TeleportToPlaceInstance('
				.. game.PlaceId
				.. ', "'
				.. game.JobId
				.. '", game.Players.LocalPlayer)'
		)
	end,
})
Game:button_holder({})
Game:button({
	name = "Rejoin",
	callback = function()
		game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, lp)
	end,
})
Game:button_holder({})
Game:button({
	name = "Join New Server",
	callback = function()
		local apiRequest = game:GetService("HttpService"):JSONDecode(
			game:HttpGetAsync(
				"https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
			)
		)
		local data = apiRequest.data[random(1, #apiRequest.data)]

		if data.playing <= flags["max_players"] then
			game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, data.id)
		end
	end,
})
Game:slider({
    name = "Max Players",
    flag = "max_players",
    min = 0,
    max = 40,
    default = 15,
    interval = 1,
})
--
Aimbot.open_tab()

task.spawn(function()
    while task.wait(1) do
        watermark.change_text(build_watermark_text())
    end
end)
--

-- radar runtime start
do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    local function track_player(p)
        if p ~= lp then
            radar.add_dot(p)
        end
    end

    for _, p in ipairs(Players:GetPlayers()) do
        track_player(p)
    end

    table.insert(library.connections, Players.PlayerAdded:Connect(track_player))
    table.insert(library.connections, Players.PlayerRemoving:Connect(function(p)
        radar.remove_dot(p)
    end))

    table.insert(library.connections, RunService.RenderStepped:Connect(function()
        -- radar update
        if radar and flags["hud_radar"] then
            for _, p in ipairs(Players:GetPlayers()) do
                if p ~= lp then
                    local char = p.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        radar.update_dot(p, hrp.Position)
                    end
                end
            end
        end
        
        -- target highlight update (throttled)
        if framework and framework.update_target_highlight then
            framework:update_target_highlight()
        end
    end))
end
-- radar runtime end

library:config_list_update()

for index, value in next, themes.preset do
	pcall(function()
		library:update_theme(index, value)
	end)
end
