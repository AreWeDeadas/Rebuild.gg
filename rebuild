loadstring(game:HttpGet("https://pastebin.com/raw/gimbTwW1"))() -- ac bypass just dont touch or replace
local library, dim2, hex, rgbseq, rgbkey, themes, flags, random, lp = loadstring(game:HttpGet("https://raw.githubusercontent.com/AreWeDeadas/Rebuild.gg/refs/heads/main/%D0%BC2"))()

-- compatibility shim start
-- safe cloneref fallback (без прямого обращения к getgenv для линтера)
local getgenv_fn = rawget(_G, "getgenv")
local env = type(getgenv_fn) == "function" and (getgenv_fn() or _G) or _G
local _cloneref = rawget(env, "cloneref")
local function safe_cloneref(obj)
    if type(_cloneref) == "function" then
        local ok, res = pcall(_cloneref, obj)
        if ok then return res end
    end
    return obj
end

-- alias primitives if library didn't export them
local vec2, vec3 = Vector2.new, Vector3.new
local dim, rect, cfr = UDim.new, Rect.new, CFrame.new
local angle = CFrame.Angles
local dim_offset = UDim2.fromOffset

local color = Color3.new
local rgb = Color3.fromRGB
local numseq = NumberSequence.new
local numkey = NumberSequenceKeypoint.new

-- cached services with cloneref
local uis = safe_cloneref(game:GetService("UserInputService"))
local players = safe_cloneref(game:GetService("Players"))
local ws = safe_cloneref(game:GetService("Workspace"))
local http_service = safe_cloneref(game:GetService("HttpService"))
local gui_service = safe_cloneref(game:GetService("GuiService"))
local lighting = safe_cloneref(game:GetService("Lighting"))
local run = safe_cloneref(game:GetService("RunService"))
local stats = safe_cloneref(game:GetService("Stats"))
local coregui = safe_cloneref(game:GetService("CoreGui"))
local debris = safe_cloneref(game:GetService("Debris"))
local tween_service = safe_cloneref(game:GetService("TweenService"))
local sound_service = safe_cloneref(game:GetService("SoundService"))
local starter_gui = safe_cloneref(game:GetService("StarterGui"))
local rs_service = safe_cloneref(game:GetService("ReplicatedStorage"))

-- frequently used math shortcuts
local max, min, abs, floor, ceil = math.max, math.min, math.abs, math.floor, math.ceil
local sin, cos, tan, pi, rad = math.sin, math.cos, math.tan, math.pi, math.rad
local atan2, acos, sqrt, pow = math.atan2, math.acos, math.sqrt, math.pow

-- player/camera
local camera = ws.CurrentCamera
lp = lp or players.LocalPlayer
local gui_offset = safe_cloneref(gui_service):GetGuiInset().Y
-- compatibility shim end

-- кеширование часто используемых переменных
local vars = {
    rs = run,
    uis = uis,
    players = players,
    ws = ws,
    stats = stats,
    camera = camera,
    lp = lp,
    vec2 = Vector2.new,
    vec3 = Vector3.new,
    cfr = CFrame.new,
    math = math,
    vector3 = Vector3.new,
    color3 = Color3.new,
    task = task,
    enum = Enum,
}

-- единый конфиг
local config = {
    Targeting = {
        Keybind = vars.enum.KeyCode.Q,
        Player = nil,
        RefreshMs = 150,
        Fov = 100,
        Mode = "Sticky", -- Sticky | Cursor | Fov
        FovShow = false,
        FovColor = hex("#FFFFFF"),
        AutoSelect = true,
        Checks = {
            visible = false,
            knocked = false,
            forcefield = false,
        },
        ResetOn = {
            knocked = false,
            death = false,
        },
        BindActive = false,
    },
    Aimbot = {
        Enabled = false,
        ShowPrediction = false,
        SelectedPart = "Head",
        BackTrackAim = false,
        PredColor = color(1, 0.4, 0.4),
        BTPredColor = color(0.4, 0.8, 1),
    },
    BackTrack = {
        Enabled = false,
        Time = 1.0, -- seconds (1-5)
        Visualise = {
            Material = "Neon",
            Transparency = 0.5,
        },
    },
    Debug = {
        Enabled = false,
        Throttle = 0.5,
    },
}

-- default theme override start
do
    -- применяем тему по умолчанию из пользовательского конфига
    local function h(s)
        return hex("#" .. s)
    end

    themes.preset.outline = h("866d77")
    themes.preset.glow = h("4d494b")
    themes.preset.high_contrast = h("8a8a8a")
    themes.preset.text = h("dfdfdf")
    themes.preset.inline = h("555555")
    themes.preset.text_outline = h("000000")
    themes.preset.low_contrast = h("474747")
    themes.preset.accent = h("fda4c8")

    -- начальное применение контраста (градиент низкий → высокий)
    pcall(function()
        library:update_theme(
            "contrast",
            rgbseq({
                rgbkey(0, themes.preset.low_contrast),
                rgbkey(1, themes.preset.high_contrast),
            })
        )
    end)
end
-- default theme override end

-- создание окна
local window = library:window({
    name = "fuckassScript - rebuild.gg - beta - closed " .. os.date("%b %d %Y"),
    size = dim2(0, 900, 0, 600),
    position = dim2(0, 500, 0, 300)
})

-- watermark
local watermark = library:watermark({
    default = "Rebuild - " .. os.date("%H:%M:%S")
})

-- ensure hidden by default (unless enabled via config later)
pcall(function()
    if watermark and watermark.set_visible then
        watermark.set_visible(false)
    end
end)
if library and library.keybind_list_frame then
    library.keybind_list_frame.Visible = false
end


-- utility framework start
local utility
do
    utility = {}
    
    -- R15 body parts (централизованный список)
    local R15_BODY_PARTS = {
        "Head", "UpperTorso", "LowerTorso",
        "RightUpperArm", "LeftUpperArm", "RightLowerArm", "LeftLowerArm",
        "RightHand", "LeftHand", "RightUpperLeg", "LeftUpperLeg",
        "RightLowerLeg", "LeftLowerLeg", "RightFoot", "LeftFoot"
    }
    
    function utility:GetR15BodyParts()
        return R15_BODY_PARTS
    end
    
    function utility:IsR15BodyPart(partName)
        for _, name in ipairs(R15_BODY_PARTS) do
            if partName == name then return true end
        end
        return false
    end
    
    -- валидация игрока
    function utility:ValidateClient(player)
        if not player or player == vars.lp then return nil end
        local character = player.Character
        if not character then return nil end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local rootpart = character:FindFirstChild("HumanoidRootPart")
        if not humanoid or not rootpart or humanoid.Health <= 0 then return nil end
        return character, humanoid, rootpart
    end
    
    -- получение информации об игроке
    function utility:GetPlayerInfo(player)
        local character = player and player.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        local rootpart = humanoid and humanoid.RootPart
        return character, humanoid, rootpart
    end
    
    -- безопасный юнит вектор
    function utility:SafeUnit(vector)
        if vector.Magnitude > 1e-8 then
            return vector.Unit
        end
        return Vector3.zero
    end
    
    -- конвертация в экранные координаты
    function utility:ToScreen(position)
        local pos, onScreen = vars.camera:WorldToViewportPoint(position)
        return pos, onScreen
    end
    
    -- проверка на форсфилд
    function utility:HasForcefield(player)
        local char = player and player.Character
        if not char then return false end
        return char:FindFirstChildOfClass("ForceField") ~= nil
    end
    
    -- проверка на нокдаун
    function utility:IsKnocked(player)
        local char = player and player.Character
        if not char then return false end
        local bodyEffects = char:FindFirstChild("BodyEffects")
        if not bodyEffects then return false end
        local ko = bodyEffects:FindFirstChild("K.O")
        if not ko then return false end
        local ok, val = pcall(function()
            return ko.Value
        end)
        return ok and val == true
    end
    
    -- проверка видимости
    function utility:IsVisible(worldPos, targetCharacter)
        if not worldPos then return false end
        local origin = vars.camera.CFrame.Position
        local rp = RaycastParams.new()
        rp.FilterType = Enum.RaycastFilterType.Exclude
        rp.FilterDescendantsInstances = {vars.lp.Character, targetCharacter}
        local result = vars.ws:Raycast(origin, (worldPos - origin), rp)
        return result == nil
    end
    
    -- расстояние между позициями
    function utility:GetDistance(pos1, pos2)
        if not pos1 or not pos2 then return math.huge end
        return (pos1 - pos2).Magnitude
    end
    
    -- расстояние до мыши
    function utility:GetMouseDistance(screenPos)
        local mouse = vars.lp:GetMouse()
        local dx = mouse.X - screenPos.X
        local dy = mouse.Y - screenPos.Y
        return math.sqrt(dx*dx + dy*dy)
    end
    

    
    -- получение части тела игрока
    function utility:GetBodyPart(character, partName)
        if not character then return nil end
        return character:FindFirstChild(partName)
    end
    
    -- предикт позиции
    function utility:PredictPosition(part, velocity, time)
        if not part or not velocity then return part and part.Position end
        return part.Position + (velocity * time)
    end
    
    -- получение скорости объекта
    function utility:GetVelocity(part)
        if not part then return Vector3.zero end
        local velocity = part.AssemblyLinearVelocity or part.Velocity
        return velocity or Vector3.zero
    end
    

    

    
    -- получение ping (безопасно; кэш + авто-отключение на ошибке)
    function utility:GetPing()
        -- кэш структуры
        utility._pingCache = utility._pingCache or { value = (config and config.Network and tonumber(config.Network.DefaultPing)) or 0, t = 0, disabled = false }
        local cache = utility._pingCache

        -- если ранее упали по capability, больше не пытаемся читать Stats
        if cache.disabled then
            return cache.value
        end

        -- не обновлять чаще, чем раз в 3 секунды
        local now = os.clock()
        if (now - (cache.t or 0)) < 3 then
            return cache.value
        end

        local ok, value = pcall(function()
            local stats = game:GetService("Stats")
            local item = stats and stats.Network and stats.Network.ServerStatsItem and stats.Network.ServerStatsItem["Data Ping"]
            if item and item.GetValue then
                return item:GetValue()
            end
            return nil
        end)

        if ok and type(value) == "number" then
            cache.value = value
            cache.t = now
            return cache.value
        else
            -- отключаем дальнейшие попытки, чтобы не спамить ошибки
            cache.disabled = true
            cache.t = now
            return cache.value
        end
    end
    
    -- безопасный юнит вектор
    function utility:SafeUnit(vector)
        if vector.Magnitude > 1e-8 then
            return vector.Unit
        end
        return vars.vec3(0, 0, 0)
    end
    
    -- клэмп значения
    function utility:Clamp(value, min, max)
        return math.max(min, math.min(max, value))
    end
    
    -- проверка на стену между точками
    function utility:HasWallBetween(pos1, pos2, ignoreList)
        if not pos1 or not pos2 then return true end
        local rp = RaycastParams.new()
        rp.FilterType = Enum.RaycastFilterType.Exclude
        rp.FilterDescendantsInstances = ignoreList or {vars.lp.Character}
        
        local result = vars.ws:Raycast(pos1, (pos2 - pos1), rp)
        return result ~= nil
    end
    

    -- проверка наличия инструмента
    function utility:HasTool(character)
        if not character then return false end
        return character:FindFirstChildWhichIsA("Tool") ~= nil
    end
    
    -- получение текущего инструмента
    function utility:GetTool(character)
        if not character then return nil end
        return character:FindFirstChildWhichIsA("Tool")
    end
    
    -- активация инструмента
    function utility:ActivateTool(tool)
        if not tool then return false end
        local ok = pcall(function()
            if tool.Activate then tool:Activate() end
        end)
        return ok
    end
    

    -- симуляция выстрела
    function utility:SimulateShot()
        -- 1) VirtualUser
        local ok = false
        pcall(function()
            vars.vu = vars.vu or game:GetService("VirtualUser")
            local cam = vars.ws.CurrentCamera
            local cf = cam and cam.CFrame or CFrame.new()
            vars.vu:Button1Down(Vector2.new(), cf)
            task.wait(0.02)
            vars.vu:Button1Up(Vector2.new(), cf)
            ok = true
        end)
        if ok then return true end
        
        -- 2) Эксплойт API
        local env = rawget(_G, "getgenv") and getgenv() or _G
        local click = rawget(env, "mouse1click")
        if type(click) == "function" then
            pcall(click)
            return true
        end
        
        -- 3) VirtualInputManager
        pcall(function()
            local vim = game:GetService("VirtualInputManager")
            local pos = vars.uis:GetMouseLocation()
            vim:SendMouseButtonEvent(pos.X, pos.Y, 0, true, game, 0)
            task.wait(0.02)
            vim:SendMouseButtonEvent(pos.X, pos.Y, 0, false, game, 0)
            ok = true
        end)
        
        return ok
    end
    
    -- получение ближайшей части тела к позиции
    function utility:GetClosestBodyPart(character, position)
        if not character or not position then return nil end
        local closestPart = nil
        local closestDist = math.huge
        
        for _, part in ipairs(character:GetChildren()) do
            if part:IsA("BasePart") then
                local dist = (part.Position - position).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closestPart = part
                end
            end
        end
        
        return closestPart, closestDist
    end
    

    
end
-- utility framework end

-- tabs start (ordered before Settings)
do
    -- Rage tab start
    local rage_tab = window:tab({ name = "Rage" })
    -- общий указатель для доступа к таргетингу и бэктреку из других блоков (например, Aimbot hooks)
    local TargetingAPI = nil
    local BackTrackAPI = nil
    do
        -- targeting system start
        do
            -- кеш уже определён вверху в таблице vars

            -- конфиг используется из единой таблицы config.Targeting

            -- внутреннее состояние
            local state = {
                time = os.clock(),
                pass = true,
                humanoidConn = nil,
                charConn = nil,
            }

            -- debug logger (gated)
            local lastLogAt = 0
            local function dbg(...)
                if config.Debug and config.Debug.Enabled then
                    print(...)
                end
            end
            local function dbg_throttled(...)
                if not (config.Debug and config.Debug.Enabled) then return end
                local now = os.clock()
                local th = (config.Debug.Throttle or 0.5)
                if now - lastLogAt >= th then
                    lastLogAt = now
                    print(...)
                end
            end

            -- используем локальные утилиты

            local function disconnect_target_events()
                if state.humanoidConn then state.humanoidConn:Disconnect() state.humanoidConn = nil end
                if state.charConn then state.charConn:Disconnect() state.charConn = nil end
            end

            local function attach_target_events(player)
                disconnect_target_events()
                if not player then return end

                -- отслеживаем респавн персонажа: перепривязка к новому humanoid
                state.charConn = player.CharacterAdded:Connect(function(newChar)
                    -- подождём появление Humanoid и HRP
                    task.spawn(function()
                        local hum = nil
                        local hrp = nil
                        pcall(function()
                            hum = newChar:WaitForChild("Humanoid", 5)
                            hrp = newChar:WaitForChild("HumanoidRootPart", 5)
                        end)
                        if hum and hrp then
                            if state.humanoidConn then state.humanoidConn:Disconnect() state.humanoidConn = nil end
                            state.humanoidConn = hum.Died:Connect(function()
                                if config.Targeting.ResetOn and config.Targeting.ResetOn.death then
                                    -- мгновенный сброс цели на смерть
                                    local prev = config.Targeting.Player
                                    config.Targeting.Player = nil
                                    state.pass = true
                                    disconnect_target_events()
                                    if prev then
                                        dbg("[Targeting] Cleared (Death):", player.Name)
                                    end
                                else
                                    state.pass = false
                                    -- не очищаем Player; ждём нового CharacterAdded
                                    dbg("[Targeting] Died (await respawn):", player.Name)
                                end
                            end)
                            state.pass = true
                            dbg("[Targeting] Respawn detected, reattached:", player.Name)
                        else
                            dbg("[Targeting] Respawn missing humanoid/hrp:", player.Name)
                        end
                    end)
                end)

                -- первичное подключение к текущему humanoid, если есть
                local character, humanoid = utility:ValidateClient(player)
                if character and humanoid then
                    state.humanoidConn = humanoid.Died:Connect(function()
                        if config.Targeting.ResetOn and config.Targeting.ResetOn.death then
                            local prev = config.Targeting.Player
                            config.Targeting.Player = nil
                            state.pass = true
                            disconnect_target_events()
                            if prev then
                                dbg("[Targeting] Cleared (Death):", player.Name)
                            end
                        else
                            state.pass = false
                            dbg("[Targeting] Died (await respawn):", player.Name)
                        end
                    end)
                end
            end

            -- локальный модуль
            local targeting = {}

            function targeting.get_config()
                return config.Targeting
            end

            function targeting.get()
                if not config.Targeting.Player then return nil end
                local character, humanoid, rootpart = utility:ValidateClient(config.Targeting.Player)
                if not character then return nil end
                return {
                    player = config.Targeting.Player,
                    character = character,
                    humanoid = humanoid,
                    rootpart = rootpart,
                    pass = state.pass,
                }
            end

            function targeting.clear()
                local prev = config.Targeting.Player
                config.Targeting.Player = nil
                state.pass = true
                disconnect_target_events()
                -- debug: target cleared
                if prev then
                    dbg("[Targeting] Cleared:", prev.Name)
                else
                    dbg("[Targeting] Cleared: none")
                end
            end

            -- экспорт API наружу
            TargetingAPI = targeting

            function targeting.set_bind_active(active)
                config.Targeting.BindActive = active and true or false
            end

            function targeting.update_target(distance)
                local bestDist = distance or config.Targeting.Fov or math.huge
                local best
                local knocked_log = {}
                local mouse = vars.lp:GetMouse()

                for _, plr in ipairs(vars.players:GetPlayers()) do
                    if plr ~= vars.lp then
                        local character, humanoid, rootpart = utility:ValidateClient(plr)
                        if character and humanoid and rootpart then
                            local sp, onScreen = utility:ToScreen(rootpart.Position)
                            if onScreen then
                                -- применяем Skip-фильтры до расчета дистанции
                                local skip = false
                                if config.Targeting.Checks.forcefield and utility:HasForcefield(plr) then
                                    skip = true
                                end
                                if not skip then
                                    local ko = utility:IsKnocked(plr)
                                    if ko and config.Targeting.Checks.knocked then
                                        table.insert(knocked_log, plr.Name)
                                    end
                                    -- если включен ResetOn.knocked, не берём нокнутых кандидатов даже без Skip
                                    if (config.Targeting.ResetOn and config.Targeting.ResetOn.knocked) and ko then
                                        skip = true
                                    elseif config.Targeting.Checks.knocked and ko then
                                        skip = true
                                    end
                                end
                                if not skip and config.Targeting.Checks.visible then
                                    if not utility:IsVisible(rootpart.Position, character) then
                                        skip = true
                                    end
                                end
                                if not skip then
                                    local dist = utility:GetMouseDistance(sp)
                                    if dist < bestDist then
                                        bestDist = dist
                                        best = plr
                                    end
                                end
                            end
                        end
                    end
                end

                if #knocked_log > 0 then
                    -- это лог поиска, не ResetOn: чтобы не путать с очисткой текущей цели
                    dbg_throttled("[Targeting] SearchSkipped(KO):", table.concat(knocked_log, ", "))
                end

                if best then
                    config.Targeting.Player = best
                    attach_target_events(best)
                    -- моментальная валидация/ResetOn сразу после выбора
                    targeting.update_checks()
                    -- debug: target selected
                    local name = best and best.Name or "?"
                    local dist = bestDist and math.floor(bestDist) or -1
                    dbg("[Targeting] Selected:", name, "Dist:", dist)
                end

                return config.Targeting.Player
            end

            function targeting.update_checks()
                if not config.Targeting.Player then
                    state.pass = false
                    return state.pass
                end

                local character, humanoid, rootpart = utility:ValidateClient(config.Targeting.Player)
                if not character then
                    state.pass = false
                    return state.pass
                end

                local failed = false
                local reason_knocked = false
                local knocked_now = utility:IsKnocked(config.Targeting.Player)

                if config.Targeting.Checks.forcefield and utility:HasForcefield(config.Targeting.Player) then
                    failed = true
                end

                if config.Targeting.Checks.knocked and knocked_now then
                    failed = true
                    reason_knocked = true
                end

                if config.Targeting.Checks.visible then
                    local ok = utility:IsVisible(rootpart.Position, character)
                    if not ok then failed = true end
                end

                state.pass = not failed
                -- ResetOn.knocked должен работать независимо от Skip-флага
                if (config.Targeting.ResetOn and config.Targeting.ResetOn.knocked) and knocked_now then
                    -- мгновенный сброс при нокдауне
                    local prev = config.Targeting.Player
                    config.Targeting.Player = nil
                    state.pass = true
                    disconnect_target_events()
                    if prev then
                        print("[Targeting] Cleared (Knocked):", prev.Name)
                    end
                end
                return state.pass
            end

            -- FOV circle render helpers
            function targeting.create_fov_circle()
                -- уже создано
                if state.fovGui and state.fovGui.gui then return end

                local sg = Instance.new("ScreenGui")
                sg.Name = "RB_FOV"
                sg.IgnoreGuiInset = false
                sg.DisplayOrder = 2147483647
                sg.ResetOnSpawn = false
                sg.Parent = coregui

                local fr = Instance.new("Frame")
                fr.Name = "Circle"
                fr.BackgroundTransparency = 1
                fr.BorderSizePixel = 0
                fr.AnchorPoint = Vector2.new(0.5, 0.5)
                fr.Parent = sg

                local corner = Instance.new("UICorner")
                corner.Parent = fr
                corner.CornerRadius = UDim.new(0.5, 0)

                local stroke = Instance.new("UIStroke")
                stroke.Parent = fr
                stroke.Thickness = 1.5
                stroke.Color = config.Targeting.FovColor or Color3.new(1,1,1)
                stroke.Transparency = 0

                state.fovGui = {
                    gui = sg,
                    frame = fr,
                    corner = corner,
                    stroke = stroke,
                }

                -- первичное обновление размера/позиции
                targeting.update_fov_circle()
            end

            function targeting.update_fov_circle()
                if not (state.fovGui and state.fovGui.frame) then return end
                local r = (config.Targeting.Fov or 100)
                local d = r * 2
                state.fovGui.frame.Size = UDim2.fromOffset(d, d)

                -- позиция по центру на курсоре
                local mouse = vars.lp:GetMouse()
                local mx, my = mouse.X, mouse.Y
                state.fovGui.frame.Position = UDim2.fromOffset(mx, my)
            end

            function targeting.think()
                if not config.Targeting.BindActive then return targeting.get() end

                -- всегда валидируем текущую цель, чтобы ResetOn.knocked работал во всех режимах
                if config.Targeting.Player then
                    targeting.update_checks()
                end

                local mode = config.Targeting.Mode
                if mode == "Cursor" then
                    -- авто: ближайший к курсору без ограничений (кадрово)
                    targeting.update_target(math.huge)
                elseif mode == "Fov" then
                    -- авто: ближайший в пределах FOV (кадрово)
                    targeting.update_target(config.Targeting.Fov or 100)
                else
                    -- Sticky: после валидации ничего не делаем (цель удерживается)
                end

                return targeting.get()
            end

            vars.players.PlayerRemoving:Connect(function(plr)
                if config.Targeting.Player == plr then
                    print("[Targeting] PlayerRemoving -> Cleared:", plr.Name)
                    targeting.clear()
                end
            end)

            local col = rage_tab:column()

            -- UI блок Targeting
            local left, right = col:multi_section({
                names = {"Targeting", "Options"}
            })
            -- BackTrack мультисекция
            local bt_left, bt_right = col:multi_section({
                names = {"BackTrack", "Visualise"}
            })
                -- backtrack                -- state
                local bt = {
                    enabled = config.BackTrack.Enabled,
                    mode = config.BackTrack.Mode or "PastTracking",
                    time = math.max(1.0, math.min(5.0, config.BackTrack.Time or 1.0)),
                    freeze_delay = config.BackTrack.FreezeDelay or 1000,
                    histories = {},   -- [player] = { { time=t, parts={ [part]=cframe } }, ... }
                    clones = {},      -- [player] = { model=Model, map={ [origPart]=clonePart }, hrp=Part, torso=Part, hum=Humanoid }
                    conns = {},
                    orig_canquery = {}, -- per-player original Hitbox.CanQuery
                    last_cleanup = 0, -- последняя принудительная очистка
                    stuck_detection = {}, -- [player] = { pos=Vector3, time=number, count=number }
                }

                -- helpers
                local function release_hitbox(plr)
                    if not plr then return end
                    local hbFolder = vars.ws:FindFirstChild("Players")
                    local plFolder = hbFolder and hbFolder:FindFirstChild(plr.Name)
                    local hitbox = plFolder and plFolder:FindFirstChild("Hitbox")
                    if hitbox and hitbox:IsA("BasePart") then
                        -- удаление только constraint'ов связанных с backtrack
                        for _, constraint in ipairs(hitbox:GetChildren()) do
                            if constraint:IsA("Constraint") then
                                pcall(function() constraint:Destroy() end)
                            end
                        end
                        
                        -- очистка constraint'ов в папке игрока связанных с hitbox
                        if plFolder then
                            for _, constraint in ipairs(plFolder:GetDescendants()) do
                                if constraint:IsA("WeldConstraint") or constraint:IsA("Motor6D") or constraint:IsA("Weld") then
                                    local connected = false
                                    pcall(function()
                                        if constraint.Part0 == hitbox or constraint.Part1 == hitbox then 
                                            connected = true 
                                        end
                                    end)
                                    if connected then pcall(function() constraint:Destroy() end) end
                                end
                            end
                        end
                        
                        -- восстановление оригинального состояния hitbox
                        pcall(function()
                            -- восстановление CanQuery
                            if bt.orig_canquery[plr] ~= nil then
                                hitbox.CanQuery = bt.orig_canquery[plr]
                            else
                                hitbox.CanQuery = true -- дефолтное значение
                            end
                            
                            -- возврат к оригинальному персонажу
                            local character = plr.Character
                            if character and character:FindFirstChild("HumanoidRootPart") then
                                hitbox.CFrame = character.HumanoidRootPart.CFrame
                            end
                            
                            -- восстановление физических свойств к дефолту
                            hitbox.Anchored = false
                            hitbox.CanCollide = false
                            hitbox.CanTouch = false
                            hitbox.AssemblyLinearVelocity = vars.vec3(0, 0, 0)
                            hitbox.AssemblyAngularVelocity = vars.vec3(0, 0, 0)
                            hitbox.Velocity = vars.vec3(0, 0, 0)
                            hitbox.RotVelocity = vars.vec3(0, 0, 0)
                            hitbox.Transparency = 1 -- невидимый
                            hitbox.Material = vars.enum.Material.Plastic -- дефолтный материал
                        end)
                    end
                end

                -- функция обновления визуальных свойств клонов
                local function update_clone_visuals()
                    if bt.clones then
                        for plr, cloneData in pairs(bt.clones) do
                            if cloneData.model then
                                for _, part in ipairs(cloneData.model:GetChildren()) do
                                    if part:IsA("BasePart") then
                                        if utility:IsR15BodyPart(part.Name) then
                                            -- применяем выбранный материал и прозрачность только к частям тела
                                            local material = config.BackTrack.Visualise.Material
                                            if material == "Neon" then
                                                part.Material = vars.enum.Material.Neon
                                            elseif material == "ForceField" then
                                                part.Material = vars.enum.Material.ForceField
                                            elseif material == "Glass" then
                                                part.Material = vars.enum.Material.Glass
                                            end
                                            part.Transparency = config.BackTrack.Visualise.Transparency
                                        else
                                            -- все остальные части (аксессуары) остаются прозрачными с материалом Plastic
                                            part.Material = vars.enum.Material.Plastic
                                            part.Transparency = 1
                                        end
                                    end
                                end
                            end
                        end
                    end
                end

                -- expose API for aimbot to use clone parts
                BackTrackAPI = {
                    get_part = function(plr, partName)
                        if not plr then return nil end
                        local info = bt.clones[plr]
                        if not info then return nil end
                        local desired = tostring(partName or "Head")
                        for orig, clone in pairs(info.map) do
                            if typeof(orig) == "Instance" and orig.Name == desired then
                                return clone
                            end
                        end
                        -- fallback to HRP
                        return info.hrp or info.torso
                    end
                }

                -- UI
                -- Toggle для включения BackTrack
                local bt_toggle = bt_left:toggle({
                    name = "Enabled",
                    flag = "bt_enabled",
                    default = bt.enabled,
                    callback = function(on)
                        bt.enabled = on
                        config.BackTrack.Enabled = on
                        if on then
                            -- start
                            if not bt.conns.hb then bt.conns.hb = vars.rs.Heartbeat:Connect(function()


                                -- только текущая цель
                                local tg = TargetingAPI and TargetingAPI.get and TargetingAPI.get() or nil
                                if not tg or not tg.player or tg.player == vars.lp then
                                    -- no target: только очистка backtrack состояния, не трогаем hitbox других игроков
                                    if bt.target then
                                        release_hitbox(bt.target)
                                        local info = bt.clones[bt.target]
                                        if info and info.model then pcall(function() info.model:Destroy() end) end
                                        bt.clones[bt.target] = nil
                                        bt.histories[bt.target] = nil
                                        bt.orig_canquery[bt.target] = nil
                                        if bt.stuck_detection[bt.target] then
                                            bt.stuck_detection[bt.target] = nil
                                        end
                                        bt.target = nil
                                    end
                                    return
                                end

                                local plr = tg.player
                                -- backtrack только для цели aimbot'а, не для локального игрока
                                if not plr or plr == vars.lp then
                                    -- если нет цели или цель = локальный игрок, только восстанавливаем состояние
                                    if bt.target then
                                        release_hitbox(bt.target)
                                        local info = bt.clones[bt.target]
                                        if info and info.model then pcall(function() info.model:Destroy() end) end
                                        bt.clones[bt.target] = nil
                                        bt.histories[bt.target] = nil
                                        bt.orig_canquery[bt.target] = nil
                                        if bt.stuck_detection[bt.target] then
                                            bt.stuck_detection[bt.target] = nil
                                        end
                                        bt.target = nil
                                    end
                                    return
                                end
                                -- смена цели => полная очистка старого
                                if bt.target and bt.target ~= plr then
                                    local old = bt.target
                                    local info = bt.clones[old]
                                    release_hitbox(old)
                                    if info and info.model then pcall(function() info.model:Destroy() end) end
                                    bt.clones[old] = nil
                                    bt.histories[old] = nil
                                    bt.orig_canquery[old] = nil
                                    -- очистка флага хитбокса
                                    if bt.hitbox_cleaned and bt.hitbox_cleaned[old] then
                                        bt.hitbox_cleaned[old] = nil
                                    end
                                    if bt.freeze_time and bt.freeze_time[old] then
                                        bt.freeze_time[old] = nil
                                    end
                                    -- очистка данных детекции застревания
                                    if bt.stuck_detection[old] then
                                        bt.stuck_detection[old] = nil
                                    end
                                    -- дополнительная очистка для предотвращения застревания
                                    bt.last_target_switch = os.clock()
                                end
                                bt.target = plr

                                -- пропускаем кадр если недавно была смена цели
                                if bt.last_target_switch and (os.clock() - bt.last_target_switch) < 0.1 then
                                    return
                                end

                                local character, humanoid, rootpart = utility:ValidateClient(plr)
                                if not (character and humanoid and rootpart) then return end

                                -- ensure container folder
                                local folder = vars.ws:FindFirstChild("BackTrack") or Instance.new("Folder")
                                folder.Name = "BackTrack"
                                if folder.Parent ~= vars.ws then folder.Parent = vars.ws end

                                -- create or reuse lightweight proxy clone (no collisions)
                                if not bt.clones[plr] then
                                    local model = Instance.new("Model")
                                    model.Name = "BT_" .. plr.Name
                                    model.Parent = folder
                                    local map = {}
                                    local hrpClone, torsoClone
                                    for _, child in ipairs(character:GetDescendants()) do
                                        if child:IsA("BasePart") and not child.Parent:IsA("Accessory") then
                                            local c = child:Clone()
                                            -- полная очистка всех constraint'ов и соединений
                                            for _, d in ipairs(c:GetDescendants()) do
                                                if d:IsA("Motor6D") or d:IsA("Weld") or d:IsA("WeldConstraint") or 
                                                   d:IsA("Attachment") or d:IsA("Constraint") or d:IsA("JointInstance") then
                                                    d:Destroy()
                                                end
                                            end
                                            -- очистка прямых детей тоже
                                            for _, d in ipairs(c:GetChildren()) do
                                                if d:IsA("Motor6D") or d:IsA("Weld") or d:IsA("WeldConstraint") or 
                                                   d:IsA("Attachment") or d:IsA("Constraint") or d:IsA("JointInstance") then
                                                    d:Destroy()
                                                end
                                            end
                                            -- настройка физики клона
                                            c.CanCollide = false; c.CanQuery = false; c.CanTouch = false
                                            c.Anchored = true; c.Massless = true
                                            c.AssemblyLinearVelocity = vars.vec3(0, 0, 0)
                                            c.AssemblyAngularVelocity = vars.vec3(0, 0, 0)
                                            -- применение настроек визуализации
                                            if utility:IsR15BodyPart(c.Name) then
                                                -- применяем выбранный материал и прозрачность только к частям тела
                                                local material = config.BackTrack.Visualise.Material
                                                if material == "Neon" then
                                                    c.Material = vars.enum.Material.Neon
                                                elseif material == "ForceField" then
                                                    c.Material = vars.enum.Material.ForceField
                                                elseif material == "Glass" then
                                                    c.Material = vars.enum.Material.Glass
                                                end
                                                c.Transparency = config.BackTrack.Visualise.Transparency
                                            else
                                                -- все остальные части (аксессуары) остаются прозрачными с материалом Plastic
                                                c.Material = vars.enum.Material.Plastic
                                                c.Transparency = 1
                                            end
                                            c.Parent = model
                                            map[child] = c
                                            if c.Name == "HumanoidRootPart" then hrpClone = c end
                                            if c.Name == "UpperTorso" then torsoClone = c end
                                        end
                                    end
                                    model.PrimaryPart = hrpClone or torsoClone
                                    bt.clones[plr] = { model = model, map = map, hrp = hrpClone, torso = torsoClone }
                                end

                                -- режим работы
                                local mode = config.BackTrack.Mode or "PastTracking"
                                
                                if mode == "PastTracking" then
                                    -- запись истории только по карте клона
                                    local now = os.clock()
                                    local cloneInfo = bt.clones[plr]
                                    local hist = bt.histories[plr]
                                    if not hist then hist = {}; bt.histories[plr] = hist end
                                    local snapshot = { time = now, parts = {} }
                                    for orig, _ in pairs(cloneInfo.map) do
                                        snapshot.parts[orig] = orig.CFrame
                                    end
                                    table.insert(hist, 1, snapshot)
                                    local cutoff = now - (bt.time + 0.5)
                                    local n = #hist
                                    while n > 0 and hist[n].time < cutoff do
                                        table.remove(hist, n)
                                        n = n - 1
                                    end

                                    -- playback
                                    if #hist > 0 then
                                        local targetT = os.clock() - bt.time
                                        local idx = 1
                                        for i, entry in ipairs(hist) do
                                            if entry.time <= targetT then idx = i; break end
                                        end
                                        local entry = hist[idx]
                                        if entry then
                                            for orig, c in pairs(cloneInfo.map) do
                                                local cf = entry.parts[orig]
                                                if cf then
                                                    c.CFrame = cf
                                                    c.CanCollide = false; c.CanQuery = false; c.CanTouch = false
                                                    c.Anchored = true
                                                    -- применение настроек визуализации
                                                    if utility:IsR15BodyPart(c.Name) then
                                                        -- применяем выбранный материал и прозрачность только к частям тела
                                                        local material = config.BackTrack.Visualise.Material
                                                        if material == "Neon" then
                                                            c.Material = vars.enum.Material.Neon
                                                        elseif material == "ForceField" then
                                                            c.Material = vars.enum.Material.ForceField
                                                        elseif material == "Glass" then
                                                            c.Material = vars.enum.Material.Glass
                                                        end
                                                        c.Transparency = config.BackTrack.Visualise.Transparency
                                                    else
                                                        -- все остальные части (аксессуары) остаются прозрачными с материалом Plastic
                                                        c.Material = vars.enum.Material.Plastic
                                                        c.Transparency = 1
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    
                                elseif mode == "Freeze" then
                                    -- Freeze режим - просто замораживаем клоны на месте с задержкой
                                    local cloneInfo = bt.clones[plr]
                                    local now = os.clock()
                                    
                                    -- инициализация времени заморозки
                                    if not bt.freeze_time then bt.freeze_time = {} end
                                    
                                    -- обновляем позицию с задержкой
                                    local freeze_delay = (config.BackTrack.FreezeUpdate or 500) / 1000
                                    if not bt.freeze_time[plr] or (now - bt.freeze_time[plr]) >= freeze_delay then
                                        bt.freeze_time[plr] = now
                                        -- сохраняем текущие позиции
                                        for orig, c in pairs(cloneInfo.map) do
                                            c.CFrame = orig.CFrame
                                            c.CanCollide = false
                                            c.CanQuery = false
                                            c.CanTouch = false
                                            c.Anchored = true
                                        end
                                    end
                                end

                                -- relocate Hitbox to clone's HRP/UpperTorso every frame
                                local cloneInfo = bt.clones[plr]
                                if cloneInfo then
                                    local hbFolder = vars.ws:FindFirstChild("Players")
                                    local plFolder = hbFolder and hbFolder:FindFirstChild(plr.Name)
                                    local hitbox = plFolder and plFolder:FindFirstChild("Hitbox")
                                    if hitbox and hitbox:IsA("BasePart") then
                                        -- remove weld constraints on first frame
                                        if not bt.hitbox_cleaned then
                                            bt.hitbox_cleaned = bt.hitbox_cleaned or {}
                                            if not bt.hitbox_cleaned[plr] then
                                                bt.hitbox_cleaned[plr] = true
                                                
                                                -- полная очистка всех constraint'ов связанных с hitbox
                                                for _, constraint in ipairs(hitbox:GetChildren()) do
                                                    if constraint:IsA("Constraint") then
                                                        constraint:Destroy()
                                                    end
                                                end
                                                
                                                -- очистка constraint'ов в папке игрока
                                                for _, constraint in ipairs(plFolder:GetDescendants()) do
                                                    if constraint:IsA("WeldConstraint") or constraint:IsA("Motor6D") or constraint:IsA("Weld") then
                                                        local connected = false
                                                        pcall(function()
                                                            if constraint.Part0 == hitbox or constraint.Part1 == hitbox then 
                                                                connected = true 
                                                            end
                                                        end)
                                                        if connected then constraint:Destroy() end
                                                    end
                                                end
                                            end
                                        end

                                        local targetPart = cloneInfo.hrp or cloneInfo.torso
                                        if targetPart then
                                            -- capture original CanQuery once
                                            if bt.orig_canquery[plr] == nil then
                                                bt.orig_canquery[plr] = hitbox.CanQuery
                                            end
                                            hitbox.Anchored = true
                                            hitbox.CanCollide = false; hitbox.CanQuery = true; hitbox.CanTouch = false
                                            -- принудительная очистка velocity для предотвращения застревания
                                            hitbox.AssemblyLinearVelocity = vars.vec3(0, 0, 0)
                                            hitbox.AssemblyAngularVelocity = vars.vec3(0, 0, 0)
                                            -- дополнительная очистка для предотвращения застревания
                                            pcall(function()
                                                hitbox.Velocity = vars.vec3(0, 0, 0)
                                                hitbox.RotVelocity = vars.vec3(0, 0, 0)
                                            end)
                                            -- debug visibility (всегда прозрачный hitbox)
                                            hitbox.Transparency = 1
                                            pcall(function() hitbox.Material = vars.enum.Material.Plastic end)
                                            -- move hitbox to clone position every frame
                                            local newPos = targetPart.CFrame.Position
                                            hitbox.CFrame = targetPart.CFrame
                                            
                                            -- детекция застревания hitbox
                                            local stuckData = bt.stuck_detection[plr]
                                            if not stuckData then
                                                bt.stuck_detection[plr] = { pos = newPos, time = now, count = 0 }
                                            else
                                                local distance = (newPos - stuckData.pos).Magnitude
                                                if distance < 0.1 then -- hitbox почти не двигается
                                                    stuckData.count = stuckData.count + 1
                                                    if stuckData.count > 30 then -- застрял на 30+ кадров
                                                        -- принудительная очистка застрявшего hitbox
                                                        pcall(function()
                                                            for _, d in ipairs(hitbox:GetDescendants()) do
                                                                if d:IsA("Constraint") or d:IsA("JointInstance") then d:Destroy() end
                                                            end
                                                            for _, d in ipairs(plFolder:GetDescendants()) do
                                                                if d:IsA("WeldConstraint") or d:IsA("Motor6D") or d:IsA("Weld") then
                                                                    if d.Part0 == hitbox or d.Part1 == hitbox then d:Destroy() end
                                                                end
                                                            end
                                                            hitbox.AssemblyLinearVelocity = vars.vec3(0, 0, 0)
                                                            hitbox.AssemblyAngularVelocity = vars.vec3(0, 0, 0)
                                                        end)
                                                        stuckData.count = 0 -- сброс счетчика
                                                    end
                                                else
                                                    stuckData.pos = newPos
                                                    stuckData.count = 0
                                                end
                                            end
                                        end
                                    end
                                end
                        end)
                    end
                    else
                        -- stop
                        if bt.conns.hb then bt.conns.hb:Disconnect() bt.conns.hb = nil end
                        for plr, info in pairs(bt.clones) do
                            release_hitbox(plr)
                            pcall(function() if info.model then info.model:Destroy() end end)
                            bt.clones[plr] = nil
                        end
                        -- полная очистка состояния
                        bt.histories = {}
                        bt.target = nil
                        bt.orig_canquery = {}
                        bt.stuck_detection = {}
                        bt.last_cleanup = 0
                        bt.hitbox_cleaned = nil
                        bt.freeze_time = nil
                    end
                    end,
                })
                
                -- Dependency box для режимов
                local bt_dep = bt_left:dependency_box()
                bt_dep:setup_dependencies({ { bt_toggle, true } })
                
                -- Dropdown с режимами
                local bt_dropdown = bt_dep:dropdown({
                    name = "Mode",
                    flag = "bt_mode",
                    items = {"PastTracking", "Freeze"},
                    default = config.BackTrack.Mode or "PastTracking",
                    callback = function(mode)
                        config.BackTrack.Mode = mode
                        bt.mode = mode
                    end,
                })

                -- Dependency box для PastTracking режима
                local past_dep = bt_dep:dependency_box()
                past_dep:setup_dependencies({ { bt_dropdown, "PastTracking" } })
                
                -- Слайдер для PastTracking режима
                past_dep:slider({
                    name = "Delay",
                    flag = "bt_past_delay",
                    min = 50,
                    max = 5000,
                    default = (config.BackTrack.PastDelay or bt.time * 1000),
                    interval = 50,
                    suffix = "ms",
                    callback = function(v)
                        bt.time = math.max(0.05, math.min(v / 1000, 5))
                        config.BackTrack.Time = bt.time
                        config.BackTrack.PastDelay = v
                    end,
                })
                
                -- Dependency box для Freeze режима
                local freeze_dep = bt_dep:dependency_box()
                freeze_dep:setup_dependencies({ { bt_dropdown, "Freeze" } })
                
                -- Слайдер для Freeze режима - интервал обновления
                freeze_dep:slider({
                    name = "Update",
                    flag = "bt_freeze_update",
                    min = 50,
                    max = 5000,
                    default = config.BackTrack.FreezeUpdate or 500,
                    interval = 50,
                    suffix = "ms",
                    callback = function(v)
                        config.BackTrack.FreezeUpdate = v
                        bt.freeze_delay = math.max(0.05, math.min(v / 1000, 5)) -- конвертируем в секунды
                    end,
                })

                -- Visualise секция
                local vis_dropdown = bt_right:dropdown({
                    name = "Material",
                    flag = "bt_vis_material",
                    items = {"Neon", "ForceField", "Glass"},
                    default = config.BackTrack.Visualise.Material,
                    callback = function(material)
                        config.BackTrack.Visualise.Material = material
                        update_clone_visuals()
                    end,
                })
                
                bt_right:slider({
                    name = "Trs",
                    flag = "bt_vis_transparency",
                    min = 0,
                    max = 1,
                    default = config.BackTrack.Visualise.Transparency,
                    interval = 0.1,
                    callback = function(v)
                        config.BackTrack.Visualise.Transparency = v
                        update_clone_visuals()
                    end,
                })

                -- auto-start if enabled from config
                if bt.enabled and bt_toggle.set then
                    bt_toggle.set(true)
                end
                -- backtrack system end
            
            -- Toggle + Keybind (сверху секции)
            local toggle = left:toggle({
                name = "Enabled",
                flag = "tg_enabled",
                callback = function(on)
                    targeting.set_bind_active(on)
                    if not on then
                        targeting.clear()
                    end
                end,
            }):keybind({
                key = config.Targeting.Keybind,
                flag = "tg_key",
                callback = function()
                    if not config.Targeting.BindActive then return end
                    if config.Targeting.Mode ~= "Sticky" then return end
                    if config.Targeting.Player then
                        -- повторное нажатие: отхват цели
                        targeting.clear()
                    else
                        -- первое нажатие: взять цель в FOV
                        local dist = (config.Targeting.Fov == 100) and math.huge or config.Targeting.Fov
                        targeting.update_target(dist)
                    end
                end,
            })

            -- Mode dropdown (ниже тогла)
            local mode_dd = left:dropdown({
                name = "Mode",
                flag = "tg_mode",
                items = {"Sticky", "Cursor", "Fov"},
                default = "Sticky",
                callback = function(selected)
                    config.Targeting.Mode = selected
                    print("[Targeting] Mode:", selected)
                    if selected ~= "Fov" then
                        -- скрыть круг если выходим из режима Fov
                        if state.fovGui and state.fovGui.gui then
                            state.fovGui.gui.Parent = nil
                        end
                    else
                        -- если включено отображение, создадим/покажем круг
                        if config.Targeting.FovShow then
                            if not state.fovGui or not state.fovGui.gui then
                                targeting.create_fov_circle()
                            else
                                state.fovGui.gui.Parent = coregui
                            end
                        end
                    end
                end,
            })

            -- Dependency: Fov controls only for Fov mode
            local fov_dep = left:dependency_box()
            fov_dep:setup_dependencies({ { mode_dd, "Fov" } })
            fov_dep:slider({
                name = "Fov",
                flag = "tg_fov",
                min = 1,
                max = 800,
                default = config.Targeting.Fov,
                interval = 1,
                callback = function(v)
                    config.Targeting.Fov = v
                    if state.fovGui and state.fovGui.frame then
                        local d = (config.Targeting.Fov or 100) * 2
                        state.fovGui.frame.Size = UDim2.fromOffset(d, d)
                        state.fovGui.corner.CornerRadius = UDim.new(0.5, 0)
                    end
                end,
            })
            local fov_show_toggle = fov_dep:toggle({
                name = "Enabled",
                flag = "tg_fov_show",
                default = config.Targeting.FovShow,
                callback = function(on)
                    config.Targeting.FovShow = on
                    if on then
                        if not state.fovGui or not state.fovGui.gui then
                            targeting.create_fov_circle()
                        else
                            state.fovGui.gui.Parent = coregui
                        end
                        if state.fovGui and state.fovGui.stroke then
                            state.fovGui.stroke.Color = config.Targeting.FovColor
                        end
                    else
                        if state.fovGui and state.fovGui.gui then
                            state.fovGui.gui.Parent = nil
                        end
                    end
                end
            }):colorpicker({
                name = "Color",
                flag = "tg_fov_color",
                color = config.Targeting.FovColor,
                callback = function(color)
                    config.Targeting.FovColor = color
                    if state.fovGui and state.fovGui.stroke then
                        state.fovGui.stroke.Color = color
                    end
                end
            })

            -- обновление состояния
            run.RenderStepped:Connect(function()
                targeting.think()
                -- обновление круга FOV
                if config.Targeting.BindActive and config.Targeting.Mode == "Fov" and config.Targeting.FovShow then
                    if not state.fovGui or not state.fovGui.gui then
                        targeting.create_fov_circle()
                    end
                    targeting.update_fov_circle()
                else
                    -- не удаляем, а просто скрываем
                    if state.fovGui and state.fovGui.gui then
                        state.fovGui.gui.Parent = nil
                    end
                end
            end)

            -- правая секция Options
            do
                -- Skip label
                right:label({ name = "Skip" })

                -- Covered -> Checks.visible
                right:toggle({
                    name = "Covered",
                    flag = "tg_chk_visible",
                    default = config.Targeting.Checks.visible,
                    callback = function(on)
                        config.Targeting.Checks.visible = on
                    end
                })

                

                -- Knocked -> Checks.knocked
                right:toggle({
                    name = "Knocked",
                    flag = "tg_chk_knocked",
                    default = config.Targeting.Checks.knocked,
                    callback = function(on)
                        config.Targeting.Checks.knocked = on
                    end
                })

                -- Forcefield -> Checks.forcefield
                right:toggle({
                    name = "Forcefield",
                    flag = "tg_chk_force",
                    default = config.Targeting.Checks.forcefield,
                    callback = function(on)
                        config.Targeting.Checks.forcefield = on
                    end
                })

                -- ResetOn label
                right:label({ name = "ResetOn" })

                -- Reset on Knocked
                right:toggle({
                    name = "Knocked",
                    flag = "tg_reset_knocked",
                    default = config.Targeting.ResetOn.knocked,
                    callback = function(on)
                        config.Targeting.ResetOn.knocked = on
                    end
                })

                -- Reset on Death
                right:toggle({
                    name = "Death",
                    flag = "tg_reset_death",
                    default = config.Targeting.ResetOn.death,
                    callback = function(on)
                        config.Targeting.ResetOn.death = on
                    end
                })
            end

            

            
        end
        -- targeting system end

        -- мультисекция Aimbot/Calculate
        do
            -- гарантируем, что есть секция конфига Aimbot
            config.Aimbot = config.Aimbot or { Enabled = false, SelectedPart = "Head", UseNamecall = false, Resolver = { Enabled = false, Mode = "Velocity" }, ShowPrediction = false }
            -- блок предикшена по умолчанию
            config.Aimbot.Prediction = config.Aimbot.Prediction or {
                Enabled = false,
                Type = "Sets",
                Sets = { X = 0, Y = 0, Z = 0 },
                DivisionMul = 1,
            }
            -- BackTrackAim default
            config.Aimbot.BackTrackAim = (config.Aimbot.BackTrackAim == true) and true or false
            -- Prediction colors
            config.Aimbot.PredColor = config.Aimbot.PredColor or Color3.new(1, 0.4, 0.4)
            config.Aimbot.BTPredColor = config.Aimbot.BTPredColor or Color3.new(0.4, 0.8, 1)
            -- Tweaks defaults
            config.Tweaks = config.Tweaks or {
                AutoAir = false,
                AutoShoot = false,
            }

            local aim_col, calc_col, tweaks_col = rage_tab:multi_section({
                names = {"Aimbot", "Calculate", "Tweaks"}
            })

            -- Aimbot Enabled
            local aim_toggle = aim_col:toggle({
                name = "Enabled",
                flag = "aim_enabled",
                default = config.Aimbot.Enabled,
                callback = function(on)
                    config.Aimbot.Enabled = on
                end
            })

            -- контейнер зависимостей для элементов, зависящих от Enabled
            local aim_dep = aim_col:dependency_box()
            aim_dep:setup_dependencies({ { aim_toggle, true } })

            -- BackTrackAim: прицел по клону BackTrack
            aim_dep:toggle({
                name = "BackTrackAim",
                flag = "aim_bt",
                default = (config.Aimbot.BackTrackAim or false),
                callback = function(on)
                    config.Aimbot.BackTrackAim = on
                end
            })

            -- Показ луча предикшена (видим только при Enabled) 
            local sp_toggle = aim_dep:toggle({
                name = "ShowPrediction",
                flag = "aim_show_pred",
                default = config.Aimbot.ShowPrediction,
                callback = function(on)
                    config.Aimbot.ShowPrediction = on
                end
            })
            :colorpicker({
                name = "PredClr",
                flag = "aim_pred_clr",
                color = config.Aimbot.PredColor,
                callback = function(color)
                    config.Aimbot.PredColor = color
                end
            })
            :colorpicker({
                name = "BTPred",
                flag = "aim_bt_pred_clr",
                color = config.Aimbot.BTPredColor,
                callback = function(color)
                    config.Aimbot.BTPredColor = color
                end
            })

            -- AimPart (читабельные сокращения R15 в CamelCase)
            do
                local label_to_part = {
                    Head = "Head",
                    Root = "HumanoidRootPart",
                    UpperTorso = "UpperTorso",
                    LowerTorso = "LowerTorso",
                    RightUpperArm = "RightUpperArm",
                    RightLowerArm = "RightLowerArm",
                    RightHand = "RightHand",
                    LeftUpperArm = "LeftUpperArm",
                    LeftLowerArm = "LeftLowerArm",
                    LeftHand = "LeftHand",
                    RightUpperLeg = "RightUpperLeg",
                    RightLowerLeg = "RightLowerLeg",
                    RightFoot = "RightFoot",
                    LeftUpperLeg = "LeftUpperLeg",
                    LeftLowerLeg = "LeftLowerLeg",
                    LeftFoot = "LeftFoot",
                }
                local items = {
                    "Head","Root","UpperTorso","LowerTorso",
                    "RightUpperArm","RightLowerArm","RightHand",
                    "LeftUpperArm","LeftLowerArm","LeftHand",
                    "RightUpperLeg","RightLowerLeg","RightFoot",
                    "LeftUpperLeg","LeftLowerLeg","LeftFoot",
                }
                local function part_to_label(part)
                    for k, v in pairs(label_to_part) do if v == part then return k end end
                    return "Head"
                end
                local default_label = part_to_label(config.Aimbot.SelectedPart or "Head")
                aim_dep:dropdown({
                    name = "AimPart",
                    flag = "aim_part",
                    items = items,
                    default = default_label,
                    callback = function(sel)
                        local mapped = label_to_part[sel]
                        if mapped then config.Aimbot.SelectedPart = mapped end
                    end
                })
            end

            -- Resolver UI (теперь зависит от Aimbot Enabled)
            do
                -- контекстный лейбл
                aim_dep:label({ name = "Resolver" })

                -- тогл Resolver скрыт, пока Aimbot Enabled = false
                local res_toggle = aim_dep:toggle({
                    name = "Enabled",
                    flag = "aim_resolver_enabled",
                    default = (config.Aimbot.Resolver and config.Aimbot.Resolver.Enabled) or false,
                    callback = function(on)
                        config.Aimbot.Resolver = config.Aimbot.Resolver or { Mode = "Velocity" }
                        config.Aimbot.Resolver.Enabled = on
                    end
                })

                -- настройки Resolver видимы только при включённом самом Resolver
                local res_dep = aim_dep:dependency_box()
                res_dep:setup_dependencies({ { res_toggle, true } })

                -- компактный маппинг: полные имена в UI -> короткие ключи в конфиге
                local map = { Velocity = "Velocity", MoveDirection = "MoveDir", LookVector = "LookVec", Recalculate = "Recalc", CalculateCFrame = "CalcCFrame" }
                local items = {"Velocity","MoveDirection","LookVector","Recalculate","CalculateCFrame"}
                local current_mode = (config.Aimbot.Resolver and config.Aimbot.Resolver.Mode) or "Velocity"
                local default_label = (current_mode == "Velocity" and "Velocity")
                    or (current_mode == "MoveDir" and "MoveDirection")
                    or (current_mode == "LookVec" and "LookVector")
                    or (current_mode == "Recalc" and "Recalculate")
                    or (current_mode == "CalcCFrame" and "CalculateCFrame")
                    or "Velocity"

                res_dep:dropdown({
                    name = "Type",
                    flag = "aim_resolver_type",
                    items = items,
                    default = default_label,
                    callback = function(sel)
                        config.Aimbot.Resolver = config.Aimbot.Resolver or { Enabled = false }
                        config.Aimbot.Resolver.Mode = map[sel] or "Velocity"
                    end
                })
            end

            -- Calculate: Prediction UI
            do
                local pred_toggle = calc_col:toggle({
                    name = "Prediction",
                    flag = "aim_pred_enabled",
                    default = config.Aimbot.Prediction.Enabled,
                    callback = function(on)
                        config.Aimbot.Prediction.Enabled = on
                    end
                })

                local dep_pred = calc_col:dependency_box()
                dep_pred:setup_dependencies({ { pred_toggle, true } })

                local type_dd = dep_pred:dropdown({
                    name = "Type",
                    flag = "aim_pred_type",
                    items = {"Sets","Division","Auto"},
                    default = config.Aimbot.Prediction.Type or "Sets",
                    callback = function(sel)
                        config.Aimbot.Prediction.Type = sel
                    end
                })

                -- Division settings (Multiplier)
                local dep_div = dep_pred:dependency_box()
                dep_div:setup_dependencies({ { type_dd, "Division" } })
                dep_div:slider({
                    name = "Mul",
                    flag = "aim_pred_div_mul",
                    min = 0,
                    max = 0.2,
                    default = (config.Aimbot.Prediction.DivisionMul and math.min(config.Aimbot.Prediction.DivisionMul, 0.2)) or 0.05,
                    interval = 0.001,
                    callback = function(v)
                        config.Aimbot.Prediction.DivisionMul = (utility and utility:Clamp(v, 0, 0.2)) or math.max(0, math.min(0.2, v))
                    end
                })

                local dep_sets = dep_pred:dependency_box()
                dep_sets:setup_dependencies({ { type_dd, "Sets" } })
                dep_sets:label({ text = "prediction x" })
                dep_sets:textbox({
                    name = "x",
                    flag = "aim_pred_x",
                    placeholder = "x",
                    default = tostring(config.Aimbot.Prediction.Sets.X or 0),
                    callback = function(txt)
                        local v = tonumber(txt)
                        if v then config.Aimbot.Prediction.Sets.X = v end
                    end
                })
                dep_sets:label({ text = "prediction y" })
                dep_sets:textbox({
                    name = "y",
                    flag = "aim_pred_y",
                    placeholder = "y",
                    default = tostring(config.Aimbot.Prediction.Sets.Y or 0),
                    callback = function(txt)
                        local v = tonumber(txt)
                        if v then config.Aimbot.Prediction.Sets.Y = v end
                    end
                })
                dep_sets:label({ text = "prediction z" })
                dep_sets:textbox({
                    name = "z",
                    flag = "aim_pred_z",
                    placeholder = "z",
                    default = tostring(config.Aimbot.Prediction.Sets.Z or 0),
                    callback = function(txt)
                        local v = tonumber(txt)
                        if v then config.Aimbot.Prediction.Sets.Z = v end
                    end
                })
            end

            -- Tweaks UI
            do
                -- autoreload system start
                local rs = game:GetService("RunService")
                local players = game:GetService("Players")
                local rep = game:GetService("ReplicatedStorage")

                local autoreload_conn
                local lastReload = 0

                local function start_autoreload()
                    if autoreload_conn then return end
                    autoreload_conn = rs.Heartbeat:Connect(function()
                        local lp = players.LocalPlayer
                        local char = lp and lp.Character
                        if not char then return end

                        local tool = char:FindFirstChildWhichIsA("Tool")
                        if not tool then return end
                        local ammo = tool:FindFirstChild("Ammo")
                        if not ammo or not ammo.Value then return end

                        if ammo.Value <= 0 then
                            local now = time()
                            if (now - lastReload) >= 1 then
                                local mainEvent = rep:FindFirstChild("MainEvent")
                                if mainEvent then
                                    mainEvent:FireServer("Reload", tool)
                                    lastReload = now
                                end
                            end
                        end
                    end)
                end

                local function stop_autoreload()
                    if autoreload_conn then
                        autoreload_conn:Disconnect()
                        autoreload_conn = nil
                    end
                end

                if (config.Tweaks and config.Tweaks.AutoReload) then
                    start_autoreload()
                end
                -- autoreload system end

                tweaks_col:toggle({
                    name = "AutoAir",
                    flag = "tw_autoair",
                    default = (config.Tweaks and config.Tweaks.AutoAir) or false,
                    callback = function(on)
                        config.Tweaks = config.Tweaks or {}
                        config.Tweaks.AutoAir = on
                    end
                })
                tweaks_col:toggle({
                    name = "AutoShoot",
                    flag = "tw_autoshoot",
                    default = (config.Tweaks and config.Tweaks.AutoShoot) or false,
                    callback = function(on)
                        config.Tweaks = config.Tweaks or {}
                        config.Tweaks.AutoShoot = on
                    end
                })
                tweaks_col:toggle({
                    name = "AutoReload",
                    flag = "tw_autoreload",
                    default = (config.Tweaks and config.Tweaks.AutoReload) or false,
                    callback = function(on)
                        config.Tweaks = config.Tweaks or {}
                        config.Tweaks.AutoReload = on
                        if on then
                            start_autoreload()
                        else
                            stop_autoreload()
                        end
                    end
                })
            end
        end

        -- Общие функции Resolver для Aimbot (доступны всем подпроцессам)
        -- хранение предыдущей позиции для режимов Recalc/CalcCFrame
        local resolver_state = { lastPos = nil, lastTick = 0 }
        
        local function get_resolved_velocity(part, humanoid)
            local mode = (config.Aimbot.Resolver and config.Aimbot.Resolver.Mode) or "Velocity"
            if not (config.Aimbot.Resolver and config.Aimbot.Resolver.Enabled) then
                return utility:GetVelocity(part)
            end
            if mode == "Velocity" then
                return utility:GetVelocity(part)
            elseif mode == "MoveDir" then
                if humanoid then
                    local md = humanoid.MoveDirection or vars.vector3()
                    local ws = humanoid.WalkSpeed or 16
                    return md * ws
                end
                return utility:GetVelocity(part)
            elseif mode == "LookVec" then
                local vel = utility:GetVelocity(part)
                local mag = vel.Magnitude
                return part.CFrame.LookVector * mag
            elseif mode == "Recalc" or mode == "CalcCFrame" then
                local now = os.clock()
                local pos = part.Position
                local v = utility:GetVelocity(part)
                if resolver_state.lastPos and resolver_state.lastTick and resolver_state.lastTick > 0 then
                    local dt = now - resolver_state.lastTick
                    if dt > 0 then
                        v = (pos - resolver_state.lastPos) / dt
                    end
                end
                resolver_state.lastPos = pos
                resolver_state.lastTick = now
                return v
            end
            return utility:GetVelocity(part)
        end

        -- Prediction function
        local function get_prediction_position(part, humanoid)
            if not part then return nil end
            local velocity = get_resolved_velocity(part, humanoid)
            if not velocity then velocity = vars.vector3() end

            if config.Aimbot.Prediction.Enabled then
                local ptype = config.Aimbot.Prediction.Type or "Sets"
                if ptype == "Sets" then
                    local sx = config.Aimbot.Prediction.Sets.X or 0
                    local sy = config.Aimbot.Prediction.Sets.Y or 0
                    local sz = config.Aimbot.Prediction.Sets.Z or 0
                    return part.Position + vars.vector3(sx, sy, sz)
                elseif ptype == "Division" then
                    local mul = config.Aimbot.Prediction.DivisionMul or 1
                    return utility:PredictPosition(part, velocity, mul)
                end
            end
            return part.Position
        end

        -- Auto Prediction helpers (ping -> multiplier). Пользователь не настраивает.
        -- формат: { ping_ms, mul }
        local predictionTable = {
            {20, 0.08960952},
            {30, 0.11252476},
            {50, 0.13544},
            {65, 0.1264236},
            {70, 0.12533},
            {80, 0.13934},
            {100, 0.141987},
            {110, 0.144634},
            {120, 0.147281},
            {130, 0.149928},
            {140, 0.152575},
            {150, 0.155222},
            {160, 0.157869},
            {170, 0.160516},
            {180, 0.163163},
            {190, 0.16581},
            {200, 0.168457},
            {210, 0.171104},
            {220, 0.173751},
            {230, 0.176398},
            {240, 0.179045},
            {250, 0.181692},
            {260, 0.184339},
            {270, 0.186986},
            {280, 0.189633},
            {290, 0.19228},
            {300, 0.194927},
        }

        local function get_current_ping_ms()
            return utility:GetPing()
        end

        local function get_auto_mul(ping_ms)
            local bestMul, bestDiff = 0, math.huge
            for i = 1, #predictionTable do
                local p = predictionTable[i][1]
                local m = predictionTable[i][2]
                local d = math.abs((ping_ms or 0) - p)
                if d < bestDiff then
                    bestDiff = d
                    bestMul = m
                end
            end
            return bestMul
        end

        -- aimbot namecall hook start (по умолчанию выключен через UseNamecall=false)
        do
            -- точка прицеливания
            local function get_target_pos()
                if not (config.Aimbot and config.Aimbot.Enabled) then return nil end
                if not TargetingAPI or not TargetingAPI.get then return nil end
                local tg = TargetingAPI.get()
                if not tg then return nil end
                local sel = (config.Aimbot.SelectedPart or "Head")
                local part
                if config.Aimbot.BackTrackAim and BackTrackAPI and BackTrackAPI.get_part then
                    part = BackTrackAPI.get_part(tg.player, sel)
                end
                if not part then
                    part = utility:GetBodyPart(tg.character, sel) or tg.rootpart
                end
                return part and part.Position or nil
            end

            local __nm
            pcall(function()
                __nm = hookmetamethod(game, "__namecall", function(self, ...)
                    if not (config.Aimbot and config.Aimbot.Enabled and config.Aimbot.UseNamecall) then
                        return __nm(self, ...)
                    end
                    local method = getnamecallmethod and getnamecallmethod() or nil
                    if method == "FireServer" and typeof(self) == "Instance" and self == rs_service:FindFirstChild("MainEvent") then
                        local args = { ... }
                        if args[1] == "UpdateMousePos" then
                            local p = get_target_pos()
                            if p then
                                args[2] = p
                                return __nm(self, unpack(args))
                            end
                        end
                    end
                    return __nm(self, ...)
                end)
            end)
        end
        -- aimbot namecall hook end

        -- aimbot __index hook start
        do
            local function get_target_part()
                if not (config.Aimbot and config.Aimbot.Enabled) then return nil end
                if not TargetingAPI or not TargetingAPI.get then return nil end
                local tg = TargetingAPI.get()
                if not tg then return nil end
                local sel = (config.Aimbot.SelectedPart or "Head")
                local part
                if config.Aimbot.BackTrackAim and BackTrackAPI and BackTrackAPI.get_part then
                    part = BackTrackAPI.get_part(tg.player, sel)
                end
                if not part then
                    part = utility:GetBodyPart(tg.character, sel) or tg.rootpart
                end
                return part
            end

            local __idx
            

            pcall(function()
                __idx = hookmetamethod(game, "__index", function(t, k)
                    if t and typeof(t) == "Instance" and t:IsA("Mouse") and (k == "Hit" or k == "Target") then
                        -- работаем только когда Aimbot.Enabled включён
                        if not (config.Aimbot and config.Aimbot.Enabled) then
                            return __idx(t, k)
                        end
                        local tg = TargetingAPI and TargetingAPI.get and TargetingAPI.get() or nil
                        local part = nil
                        local humanoid = nil
                        if tg then
                            local sel = (config.Aimbot.SelectedPart or "Head")
                            if config.Aimbot.BackTrackAim and BackTrackAPI and BackTrackAPI.get_part then
                                part = BackTrackAPI.get_part(tg.player, sel)
                            end
                            if not part then
                                part = utility:GetBodyPart(tg.character, sel) or tg.rootpart
                            end
                            humanoid = tg.humanoid
                        end
                        if part then
                            if k == "Hit" then
                                local pos = part.Position
                                -- применяем предикшн при включении
                                local pred = config.Aimbot.Prediction
                                if pred and pred.Enabled then
                                    if pred.Type == "Sets" then
                                        local vel = get_resolved_velocity(part, humanoid)
                                        local sx = tonumber(pred.Sets and pred.Sets.X) or 0
                                        local sy = tonumber(pred.Sets and pred.Sets.Y) or 0
                                        local sz = tonumber(pred.Sets and pred.Sets.Z) or 0
                                        pos = pos + vars.vector3(vel.X * sx, vel.Y * sy, vel.Z * sz)
                                    elseif pred.Type == "Division" then
                                        local vel = get_resolved_velocity(part, humanoid)
                                        local mul = utility:Clamp(tonumber(config.Aimbot.Prediction.DivisionMul) or 0.05, 0, 0.2)
                                        pos = utility:PredictPosition(part, vel, mul)
                                    elseif pred.Type == "Auto" then
                                        local vel = get_resolved_velocity(part, humanoid)
                                        local ping = get_current_ping_ms()
                                        local mul = get_auto_mul(ping)
                                        pos = utility:PredictPosition(part, vel, mul)
                                    end
                                end
                                return CFrame.new(pos)
                            else -- k == "Target"
                                return part
                            end
                        end
                    end
                    return __idx(t, k)
                end)
            end)
        end
        -- aimbot __index hook end

        -- aimbot prediction beam start
        do
            local vis = { line = nil }

            -- создаём Drawing линию для prediction beam
            local function ensure_beam()
                if not Drawing then return false end -- проверка на Drawing API
                if not vis.line then
                    vis.line = Drawing.new('Line')
                    vis.line.Thickness = 2
                    vis.line.Transparency = 0.8
                    vis.line.Color = color(1, 0.4, 0.4) -- дефолтный цвет
                    vis.line.Visible = false
                end
                return vis.line ~= nil
            end

            local function get_predicted_pos_for_visual()
                if not (config.Aimbot and config.Aimbot.Enabled and config.Aimbot.ShowPrediction) then return nil end
                if not TargetingAPI or not TargetingAPI.get then return nil end
                local tg = TargetingAPI.get()
                if not tg then return nil end
                local sel = (config.Aimbot.SelectedPart or "Head")
                -- живая часть цели (резерв)
                local livePart = utility:GetBodyPart(tg.character, sel) or tg.rootpart
                local chosen = livePart
                -- для визуала используем клон только если включён прицел в BackTrack (BackTrackAim)
                if (config.Aimbot and config.Aimbot.BackTrackAim) and BackTrackAPI and BackTrackAPI.get_part then
                    local btPart = BackTrackAPI.get_part(tg.player, sel)
                    if btPart then
                        -- wallcheck: рейкастом от правой руки локального игрока до btPart
                        local char = vars.lp and vars.lp.Character
                        local hand = char and (char:FindFirstChild("RightHand") or char:FindFirstChild("Right Arm") or char:FindFirstChild("RightLowerArm") or char:FindFirstChild("RightUpperArm"))
                        local rp = char and char:FindFirstChild("HumanoidRootPart")
                        local origin = (hand and hand.Position) or (rp and rp.Position) or vars.camera.CFrame.Position
                        local ws = (vars.ws or workspace)
                        local params = RaycastParams.new()
                        params.FilterType = Enum.RaycastFilterType.Exclude
                        params.FilterDescendantsInstances = {char, tg.character}
                        local dir = btPart.Position - origin
                        local hit = ws:Raycast(origin, dir, params)
                        local clear = (not hit) or hit.Instance == btPart or (hit.Instance and btPart and hit.Instance:IsDescendantOf(btPart))
                        if clear then
                            chosen = btPart
                        end
                    end
                end
                if not chosen then return nil end
                return get_prediction_position(chosen, tg.humanoid)
            end

            vars.rs.RenderStepped:Connect(function()
                if config.Aimbot.Enabled and config.Aimbot.ShowPrediction then
                    local p = get_predicted_pos_for_visual()
                    if p and ensure_beam() then
                        -- позиция мыши через UIS (как у FOV / без смещения)
                        local ml = vars.uis:GetMouseLocation()
                        local mousePos = vec2(ml.X, ml.Y)
                        
                        -- конвертировать 3D позицию цели в 2D экранные координаты
                        local screenPos, onScreen = vars.camera:WorldToViewportPoint(p)
                        
                        if onScreen then
                            local targetPos = vec2(screenPos.X, screenPos.Y)
                            
                            -- настроить линию
                            vis.line.From = mousePos
                            vis.line.To = targetPos
                            
                            -- выбрать цвет луча: проверяем есть ли BackTrack клон для текущей цели
                            local tg = TargetingAPI and TargetingAPI.get and TargetingAPI.get()
                            local useBT = false
                            if tg and config.Aimbot.BackTrackAim and BackTrackAPI and BackTrackAPI.get_part then
                                local sel = (config.Aimbot.SelectedPart or "Head")
                                local btPart = BackTrackAPI.get_part(tg.player, sel)
                                if btPart then
                                    -- wallcheck для цвета: если bt виден, подсвечиваем BTPredColor
                                    local char = vars.lp and vars.lp.Character
                                    local hand = char and (char:FindFirstChild("RightHand") or char:FindFirstChild("Right Arm") or char:FindFirstChild("RightLowerArm") or char:FindFirstChild("RightUpperArm"))
                                    local rp = char and char:FindFirstChild("HumanoidRootPart")
                                    local origin = (hand and hand.Position) or (rp and rp.Position) or vars.camera.CFrame.Position
                                    local ws = (vars.ws or workspace)
                                    local params = RaycastParams.new()
                                    params.FilterType = Enum.RaycastFilterType.Exclude
                                    params.FilterDescendantsInstances = {char, tg.character}
                                    local dir = btPart.Position - origin
                                    local hit = ws:Raycast(origin, dir, params)
                                    useBT = (not hit) or hit.Instance == btPart or (hit.Instance and btPart and hit.Instance:IsDescendantOf(btPart))
                                end
                            end
                            
                            local clr = useBT and (config.Aimbot.BTPredColor or color(0.4, 0.8, 1)) or (config.Aimbot.PredColor or color(1, 0.4, 0.4))
                            vis.line.Color = clr
                            vis.line.Visible = true
                        else
                            vis.line.Visible = false
                        end
                    else
                        if vis.line then vis.line.Visible = false end
                    end
                else
                    if vis.line then vis.line.Visible = false end
                end
            end)
        end
        -- aimbot prediction beam end

        -- Tweaks AutoShoot: держим LMB/Activate при наличии оружия и цели
            local autos = { busy = false, last = 0 }
            vars.rs.RenderStepped:Connect(function()
                if not (config.Tweaks and config.Tweaks.AutoShoot) then return end
                if autos.busy or (os.clock() - autos.last) < 0.1 then return end
                -- нужна валидная цель
                local tgt = TargetingAPI and TargetingAPI.get and TargetingAPI.get()
                if not tgt or not tgt.character or not tgt.rootpart then return end
                local ok_checks = (TargetingAPI and TargetingAPI.update_checks and TargetingAPI.update_checks())
                if ok_checks == false then return end
                local ch = vars.lp and vars.lp.Character
                if not ch then return end
                local tool = utility:GetTool(ch)
                if not tool then return end
                autos.busy = true
                autos.last = os.clock()
                if not utility:ActivateTool(tool) then
                    utility:SimulateShot()
                end
                task.delay(0.05, function() autos.busy = false end)
            end)
        -- tweaks autoshoot end

        -- tweaks autoair start
        do
            -- Проверка по вертикальной скорости цели и активация оружия
            local aa = { busy = false, lastShot = 0 }

            -- wallcheck helper: проверка прямой видимости до цели
            local function has_line_of_sight(targetChar, targetPart)
                if not targetChar or not targetPart then return false end
                local cam = vars.ws and vars.ws.CurrentCamera
                local origin = cam and cam.CFrame and cam.CFrame.Position
                if not origin then
                    local lpChar = vars.lp and vars.lp.Character
                    local head = lpChar and lpChar:FindFirstChild("Head")
                    origin = head and head.Position
                end
                if not origin then return false end
                local targetPos = targetPart.Position
                local dir = targetPos - origin
                local params = RaycastParams.new()
                params.FilterType = Enum.RaycastFilterType.Exclude
                params.FilterDescendantsInstances = { (vars.lp and vars.lp.Character), targetChar }
                local result = vars.ws:Raycast(origin, dir.Unit * dir.Magnitude, params)
                if not result then return true end
                return result.Instance:IsDescendantOf(targetChar)
            end

            local function simulate_shot_legacy()
                -- 1) VirtualUser (надежнее для игр с проверками ввода)
                local ok = false
                pcall(function()
                    vars.vu = vars.vu or game:GetService("VirtualUser")
                    local cam = vars.ws.CurrentCamera
                    local cf = cam and cam.CFrame or CFrame.new()
                    vars.vu:Button1Down(Vector2.new(), cf)
                    task.wait(0.02)
                    vars.vu:Button1Up(Vector2.new(), cf)
                    ok = true
                end)    
                if ok then return true end

                -- 2) Эксплойт API: mouse1click
                local getgenv_fn = rawget(_G, "getgenv")
                local env = (type(getgenv_fn) == "function" and getgenv_fn()) or {}
                local click = rawget(env, "mouse1click")
                if type(click) == "function" then
                    pcall(click)
                    return true
                end

                -- 3) VirtualInputManager
                pcall(function()
                    local vim = game:GetService("VirtualInputManager")
                    local pos = vars.uis:GetMouseLocation()
                    vim:SendMouseButtonEvent(pos.X, pos.Y, 0, true, game, 0)
                    task.wait(0.02)
                    vim:SendMouseButtonEvent(pos.X, pos.Y, 0, false, game, 0)
                    ok = true
                end)
                return ok
            end

            run.RenderStepped:Connect(function()
                if not (config.Tweaks and config.Tweaks.AutoAir) then return end
                local tgt = TargetingAPI and TargetingAPI.get and TargetingAPI.get()
                if not tgt then return end
                if not tgt.character or not tgt.rootpart then return end
                
                -- проверка валидности цели
                local ok_checks = (TargetingAPI and TargetingAPI.update_checks and TargetingAPI.update_checks())
                if ok_checks == false then return end

                -- wallcheck: не стреляем если цель за стеной
                if not has_line_of_sight(tgt.character, tgt.rootpart) then return end

                local vel = utility:GetVelocity(tgt.rootpart)
                local vy = vel and vel.Y or 0

                if vy > 15 then
                    if not aa.busy and (os.clock() - aa.lastShot) > 0.12 then
                        aa.busy = true
                        aa.lastShot = os.clock()
                        utility:SimulateShot()
                        task.delay(0.1, function()
                            aa.busy = false
                        end)
                    end
                end
            end)
        end
        -- tweaks autoair end
    end

    -- Misc tab start
    local misc_tab = window:tab({ name = "Misc" })
    do
        local col = misc_tab:column()
        local section = col:section({ name = "misc" })
        -- здесь будут элементы Misc
    end
    -- Misc tab end

    -- Visuals tab start
    local visuals_tab = window:tab({ name = "Visuals" })
    do
        local col = visuals_tab:column()
        local section = col:section({ name = "visuals" })
        -- здесь будут элементы Visuals
    end
    -- Visuals tab end
end
-- tabs end

local settings_tab = window:tab({ name = "Settings", enabled = true })

getgenv().load_config = function(name)
	library:load_config(readfile(library.directory .. "/configs/" .. name .. ".cfg"))
end

local column = settings_tab:column()
local section = column:section({ name = "Config" })
local old_config = library:get_config()
config_holder = section:list({ flag = "config_name_list" })
section:textbox({ flag = "config_name_text_box" })
section:button_holder({})
section:button({
	name = "Create",
	callback = function()
		writefile(library.directory .. "/configs/" .. flags["config_name_text_box"] .. ".cfg", library:get_config())
		library:config_list_update()
	end,
})
section:button({
	name = "Delete",
	callback = function()
		delfile(library.directory .. "/configs/" .. flags["config_name_list"] .. ".cfg")
		library:config_list_update()
	end,
})
section:button_holder({})
section:button({
	name = "Load",
	callback = function()
		library:load_config(readfile(library.directory .. "/configs/" .. flags["config_name_list"] .. ".cfg"))
		library:notification({
			text = "Loaded Config: " .. flags["config_name_list"],
			time = 3,
		})
	end,
})
section:button({
	name = "Save",
	callback = function()
		writefile(library.directory .. "/configs/" .. flags["config_name_list"] .. ".cfg", library:get_config())
		library:config_list_update()
		library:notification({
			text = "Saved Config: " .. flags["config_name_list"],
			time = 3,
		})
	end,
})
section:button_holder({})
section:button({
	name = "Refresh Configs",
	callback = function()
		library:config_list_update()
	end,
})
section:button_holder({})
section:button({
	name = "Unload Config",
	callback = function()
		library:load_config(old_config)
	end,
})
section:button({
	name = "Unload Menu",
	callback = function()
		library:load_config(old_config)

		for _, gui in library.guis do
			gui:Destroy()
		end

		for _, connection in library.connections do
			connection:Disconnect()
		end
	end,
})

local column = settings_tab:column()
local section = column:section({ name = "Theme" })
section:label({ name = "Accent" }):colorpicker({
	name = "Accent",
	color = themes.preset.accent,
	flag = "accent",
	callback = function(color, alpha)
		library:update_theme("accent", color)
	end,
})
section
	:label({ name = "Contrast" })
	:colorpicker({
		name = "Low",
		color = themes.preset.low_contrast,
		flag = "low_contrast",
		callback = function(color)
			if flags["high_contrast"] and flags["low_contrast"] then
				library:update_theme(
					"contrast",
					rgbseq({
						rgbkey(0, flags["low_contrast"].Color),
						rgbkey(1, flags["high_contrast"].Color),
					})
				)
			end
		end,
	})
	:colorpicker({
		name = "High",
		color = themes.preset.high_contrast,
		flag = "high_contrast",
		callback = function(color)
			library:update_theme(
				"contrast",
				rgbseq({
					rgbkey(0, flags["low_contrast"].Color),
					rgbkey(1, flags["high_contrast"].Color),
				})
			)
		end,
	})
section:label({ name = "Inline" }):colorpicker({
    name = "Inline",
    color = themes.preset.inline,
    flag = "inline",
    callback = function(color, alpha)
        library:update_theme("inline", color)
    end,
})
section:label({ name = "Outline" }):colorpicker({
    name = "Outline",
    color = themes.preset.outline,
    flag = "outline",
    callback = function(color, alpha)
        library:update_theme("outline", color)
    end,
})
section
    :label({ name = "Text Color" })
    :colorpicker({
        name = "Main",
        color = themes.preset.text,
        flag = "text",
        callback = function(color, alpha)
            library:update_theme("text", color)
        end,
    })
    :colorpicker({
        name = "Outline",
        color = themes.preset.text_outline,
        flag = "text_outline",
        callback = function(color, alpha)
            library:update_theme("text_outline", color)
        end,
    })
section:label({ name = "Glow" }):colorpicker({
    name = "Glow",
    color = themes.preset.glow,
    flag = "glow",
    callback = function(color, alpha)
        library:update_theme("glow", color)
    end,
})
section:label({ name = "UI Bind" }):keybind({
	callback = window.set_menu_visibility,
	key = Enum.KeyCode.Insert,
})
section:toggle({
    name = "Keybind List",
    flag = "keybind_list",
    callback = function(bool)
        library.keybind_list_frame.Visible = bool
    end,
})
section:toggle({
    name = "Watermark",
    flag = "watermark",
    callback = function(bool)
        watermark.set_visible(bool)
    end,
})
section:button_holder({})
section:button({
	name = "Copy JobId",
	callback = function()
		setclipboard(game.JobId)
	end,
})
section:button_holder({})
section:button({
	name = "Copy GameID",
	callback = function()
		setclipboard(game.GameId)
	end,
})
section:button_holder({})
section:button({
	name = "Copy Join Script",
	callback = function()
		setclipboard(
			'game:GetService("TeleportService"):TeleportToPlaceInstance('
				.. game.PlaceId
				.. ', "'
				.. game.JobId
				.. '", game.Players.LocalPlayer)'
		)
	end,
})
section:button_holder({})
section:button({
	name = "Rejoin",
	callback = function()
		game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, lp)
	end,
})
section:button_holder({})
section:button({
	name = "Join New Server",
	callback = function()
		local apiRequest = game:GetService("HttpService"):JSONDecode(
			game:HttpGetAsync(
				"https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
			)
		)
		local data = apiRequest.data[random(1, #apiRequest.data)]

		if data.playing <= flags["max_players"] then
			game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, data.id)
		end
	end,
})
section:slider({
	name = "Max Players",
	flag = "max_players",
	min = 0,
	max = 40,
	default = 15,
	interval = 1,
})
--
task.spawn(function()
	while task.wait(1) do
		watermark.change_text(os.date("32vision - fullskidded - %b %d %Y - %H:%M:%S"))
	end
end)
--

library:config_list_update()

for index, value in next, themes.preset do
	pcall(function()
		library:update_theme(index, value)
	end)
end

library.keybind_list_frame.Visible = false
watermark.set_visible(false)
